
+++
title = "数据库"
date = "2025-06-13T13:21:31Z"
authors = ["Zhonghe-zhao"]
[taxonomies]
tags = [ "ComputerScience",  "DB", ]
[extra]
author = "Zhonghe-zhao"
avatar = "https://avatars.githubusercontent.com/u/147113943?v=4"
issue_url = "https://github.com/Zhonghe-zhao/DailyBlog/issues/21"
[extra.reactions]
thumbs_up = 0
thumbs_down = 0
laugh = 0
heart = 0
hooray = 0
confused = 0
rocket = 0
eyes = 0

[[extra.comments]]
url = "https://github.com/Zhonghe-zhao/DailyBlog/issues/21#issuecomment-2973487437"
author_name = "Zhonghe-zhao"
author_avatar = "https://avatars.githubusercontent.com/u/147113943?v=4"
content = '''# pg的并发控制

**MVCC 维护数据的一致性：** 每个 SQL 语句都会看到一段时间前的数据快照（ 数据库版本 ），而不管底层数据的当前状态如何，也就是当 事务开始的时候，拍了一张当前数据库的快照，实现事务的隔离性，防止读到别人正在修改的数据（防止脏读，不可重复读，幻读）

## 对于银行系统：

> Read Committed + 显示行级锁


## 锁的使用

锁的分类：

**行锁：**  会对“特定的那一行数据”加锁，阻止其他事务同时修改它。只有当持有锁的事务提交时，下一个被阻塞的事务才能执行，锁定一行，影响最小，适合高并发写操作

**表锁：**  锁定整张表，影响较大，适合批量写入或结构变更。
 
**锁的行为**

**共享锁：** 多个事务同时读，不能写

**排他锁：**当前事务独占资源


'''
updated_at = "2025-06-15T04:30:12Z"

[[extra.comments]]
url = "https://github.com/Zhonghe-zhao/DailyBlog/issues/21#issuecomment-2973513984"
author_name = "Zhonghe-zhao"
author_avatar = "https://avatars.githubusercontent.com/u/147113943?v=4"
content = '''# MVCC

MVCC解决的问题是什么？ MVCC使用的思想是什么

## 解决的问题：

解决并发事务中的读写冲突（保证 读不阻塞写，写不阻塞读，保证数据的一致性，提高并发性能）

思想：

读操作读“旧版本”

写操作创建“新版本”

同时存在多个版本，互不干扰



'''
updated_at = "2025-06-15T05:36:31Z"

[[extra.comments]]
url = "https://github.com/Zhonghe-zhao/DailyBlog/issues/21#issuecomment-2973529014"
author_name = "Zhonghe-zhao"
author_avatar = "https://avatars.githubusercontent.com/u/147113943?v=4"
content = '''# 索引

如何快速想要找出你想要的数据， 就像书没有了目录，想找到自己想要的那一页是很困难的，所以可以为数据建立索引查询，更加方便

索引：

 二叉树（普通）： 导致数据倾斜变成链表， 

二叉树（平衡）： 变得越来越高（多次分叉）多次I/O操作

二叉树（B树）:   一个节点存储多个数据，一个节点可以有多个分叉（查询效率不稳定， 不稳定？）（数据不适合范围性查找）

二叉树（B+树）： 

哈希索引：

位图索引：

'''
updated_at = "2025-06-15T06:17:22Z"

+++

# 数据库知识梳理

## 什么是数据库？

数据的仓库 高效的保存和查询数据 

## 为什么要 保存和查询数据  如何保证数据被正常存储 和 如何查询数据？

保存数据：系统能长期使用和分析这些数据， 

查询数据： 用户能根据条件快速找出需要的信息

**如何保证数据正确被保存和正确的查询数据？**

1. 数据库事务
2. 约束
3. 日志
4. 数据备份
5. DBMS

## 什么是数据库事务

保证一组操作要么全部成功、要么全部失败的机制，核心用于**保证数据一致性。**

事务的四大特性：

ACID 

**为什么事务可以避免并发冲突？**

隔离机制： 数据库的隔离级别 + 锁机制

事务的隔离级别：

自上向下 性能由高到低 

- 读未提交：虽然级别最低 但也有它的作用。实时监控数据的变化， 对数据一致性要求不严格，允许读到脏数据但能换取速度。
- 读已提交 ： 事务只能读导已经提交的数据（避免脏读）  
- 可重复读 ：在事务内对同一行多次读取是一样的（其他事务不能修改）
- 可串行化： 对读的范围加 锁 拒绝其它插入

## 对于可重复读

在 可重复读隔离级别下，一个事务在开始后所读取的数据会基于快照，一直一致，同一条记录无论读多少次，看到的都是事务开始时的版本，即使其他事务已经修改并提交了这条记录。每个事务会生成一个快照版本号，之后所有查询都基于这个版本读取；不会加锁，但能保证多次读取一致（除非手动加锁，无法防幻读）；

**对于可串行化：**

在某些数据库（如 MySQL）用强锁机制实现。

在 PostgreSQL 中通过MVCC + 并发冲突检测（SSI）实现，更智能但也有事务被中止的风险。

## 对于幻读情况

出现了**“幻影数据”** → 第二次出现了之前“范围里没有”的新行 → 这就是幻读。为什么可重复读 不能 避免幻读？ MVCC快照机制 只保证读过的记录内容不变，没读过的新行还是可以看到！

**所以可以使用 锁！避免Serializable隔离级别带来的严重性能差**

**所以对于锁的使用时机，如何正确的使用锁，死锁？ 等一些情况 需要对锁有一定的了解和调试！**

所以**Serializable**的问题 时性能问题！ 只需要开发者修改一下隔离级别，就行轻松避免 脏读等问题！


**并发事务产生的问题：**

_脏读_： 读到未提交的数据

_不可重复读_： 同一次查询 两次读的结果不同 

_序列化异常_： 成功提交一组事务的结果与一次运行这些事务的所有可能顺序不一致。

疑惑： 不可重复读 怎么了？ A读100 b修改为50 再次读取不应该就是50吗 难道还要让他读到100？

解答： 在事务A未提交时，事务B提交了修改，导致事务A中同一数据多次读取结果不一致，破坏了事务的隔离性，可能导致逻辑错误或数据不稳定。 

_幻读_： 查询范围内数据被别人新增

## 问题：

假设账户初始余额是 100，有两个事务并发执行：

事务 A：读余额 → 如果 ≥100，则扣 100

事务 B：读余额 → 如果 ≥100，则扣 100

如果没有串行控制，两者几乎同时读到 100，都满足条件，各自扣 100，最终余额变成 -100！

Serializable的隔离级别可以让数据库检测到并发冲突，强制回滚其中一个事务，性能会大大折扣

Serializable的工作原理：

 事务之间如果有“不可串行化的依赖”，就会强制让一个事务回滚；

PostgreSQL 的 Serializable 是通过 检测事务冲突图 实现的（SSI），不是加锁；

## 数据库锁机制

## 存储引擎

负责存储、处理和检索数据的核心组件

应对不同的场景 ， 不同的场景会用到不同的存储引擎 

数据的物理结构 ， 索引 ， 查询的实现方式

## PG相比于MYSQL

Postgres：
 
    MVCC（多版本并发控制）： PostgreSQL 使用 MVCC 来实现事务隔离，通过为每个事务创建数据快照（版本）来避免读写冲突，默认隔离级别是读已提交，但可轻松配置为可重复读或串行化。

    行级锁：

    死锁检测：


