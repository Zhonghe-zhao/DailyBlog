<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
      
    

      <title> - Reddit提问</title>

      
          
          <link rel="alternate" type="application/rss+xml" title="RSS" href="https://Zhonghe-zhao.github.io/DailyBlog/rss.xml">
          
      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
      

      
          <link rel="stylesheet" href="https://Zhonghe-zhao.github.io/DailyBlog/site.css">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;" class="logo"></a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;tags&#x2F;top&#x2F;">
                            Top
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;issue-34&#x2F;">
                            About
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;issue-35&#x2F;">
                            Things I like
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;"></a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;tags&#x2F;top&#x2F;">
                                    Top
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;issue-34&#x2F;">
                                    About
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;&#x2F;issue-35&#x2F;">
                                    Things I like
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#understanding-csp" class="toc-link">Understanding CSP</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#1-shou-huo-ji-jin-cheng" class="toc-link">1. 售货机进程</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#2-gu-ke-jin-cheng" class="toc-link">2. 顾客进程</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#3-ru-guo-shou-huo-ji-zhi-tong-bu-coin" class="toc-link">3. 如果售货机只同步 coin</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#4-yin-cang-shi-jian" class="toc-link">4. 隐藏事件</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#cao-zuo-xi-tong-wei-shen-me-mei-yong-csp" class="toc-link">操作系统为什么没用 CSP：</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#ipc-jin-cheng-jian-tong-xin" class="toc-link">IPC 进程间通信</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#cspde-you-lie-shi" class="toc-link">CSP的优劣势</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#yi-csp-de-lie-shi-chang-jing-xing-neng-chai" class="toc-link">一、CSP 的劣势场景（性能差）：</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#csp-de-you-shi-chang-jing-xing-neng-hao" class="toc-link">CSP 的优势场景（性能好）：</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#kun-huo" class="toc-link">困惑</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#he-xin-hui-da" class="toc-link">核心回答！</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#guan-jian-shi-feng-zhuang-he-bing-fa-yu-zui-xiao-hua" class="toc-link">关键是“封装” 和 “并发域最小化”：</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#plan-9-from-bell-labs" class="toc-link">Plan 9 from Bell Labs</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#yi-wen" class="toc-link">疑问：</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#mkfifo-is-os-s-channel" class="toc-link">mkfifo is OS&#x27;s channel</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#xian-cheng-chi" class="toc-link">线程池</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#pi-ping-go-yu-yan-zai-cuo-wu-chu-li-he-yi-xie-te-shu-yu-fa-shang-de-bu-yi-zhi-xing" class="toc-link"> 批评 Go 语言在错误处理和一些特殊语法上的不一致性</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#li-jie-yi-chang-he-cuo-wu" class="toc-link">理解异常和错误</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#sync-atomic" class="toc-link">sync&#x2F;atomic</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#yuan-zi-cao-zuo-he-suo-de-qu-bie" class="toc-link">原子操作和锁的区别</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#gong-xiang-nei-cun-he-csp" class="toc-link">共享内存和CSP</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#plan9-go" class="toc-link">Plan9 &amp; Go</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#she-ji-si-xiang-de-guan-lian" class="toc-link">设计思想的关联</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#1-yi-qie-jie-wen-jian-io-reader-io-writer-chou-xiang" class="toc-link">1. 一切皆文件 &#x2F; io.Reader + io.Writer 抽象</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#2-zu-he-you-yu-ji-cheng" class="toc-link">2. 组合优于继承</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#3-csp-bing-fa-mo-xing-goroutine-channel" class="toc-link">3. CSP 并发模型（goroutine + channel）</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#4-zi-yuan-an-ming-ming-kong-jian-chou-xiang-net-conn-chou-xiang" class="toc-link">4. 资源按命名空间抽象（net.Conn 抽象）</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#5-zi-ju-zui-xiao-gong-ju-lian-go-bian-yi-qi-gong-ju-jiu-shi-yong-go-xie-de" class="toc-link">5. 自举 + 最小工具链：Go 编译器&#x2F;工具就是用 Go 写的</a>
                        </li>
                        
                        <li>
                            <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#zong-jie" class="toc-link">总结</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#xi-tong-zi-liao" class="toc-link">系统资料</a>
                    
                </li>
                
                <li>
                    <a href="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/#pipe-he-channel" class="toc-link">pipe 和 channel</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;issue-7&#x2F;">Reddit提问</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2025-05-28</span>
            
                <span class="post__source">
                    <a href="https:&#x2F;&#x2F;github.com&#x2F;Zhonghe-zhao&#x2F;DailyBlog&#x2F;issues&#x2F;7">read the source issue</a>
                </span>
            
            
        </div>
    </header>


    <div class="post-reactions">
        
        
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>

    <div class="post-content">
      <pre><code>hello everyone! Recently, while learning the concurrency model of Go language, I have been very interested in its idea of &quot;Do not communicate by sharing memory&quot; (instant, share memory by communication).The channel mechanism of Go replaces explicit locks with data transfer between goroutines, making concurrent programming safer and simpler. This makes me think: can similar ideas be used in operating system design? For example, replacing traditional IPC mechanisms such as shared memory and semaphore with channels?I would like to discuss the following points with everyone:The inter process&#x2F;thread communication (IPC) of the operating system currently relies on shared memory, message queues, pipelines, and so on. What are the advantages and challenges of using a mechanism similar to Go channel?Will performance become a bottleneck (such as system call overhead)?Realistic case:Have any existing operating systems or research projects attempted this design? (For example, microkernel, Unikernel, or certain academic systems?)? ）Do you think the abstraction of channels is feasible at the OS level?  
大家好！最近，我在学习 Go 语言的并发模型时，对它的 “Do not communicate by sharing memory” （instant， share memory by communication） 的思想非常感兴趣。Go 的通道机制用 goroutine 之间的数据传输取代了显式锁，使并发编程更安全、更简单。这让我思考：类似的思路可以用在作系统设计中吗？例如，用通道替换共享内存和信号量等传统 IPC 机制？我想和大家讨论以下几点：作系统的进程间 &#x2F; 线程通信（IPC）目前依赖于共享内存、消息队列、管道等。使用类似于 Go 频道的机制有哪些优势和挑战？性能会不会成为瓶颈（如系统调用开销）？现实案例：是否有任何现有的作系统或研究项目尝试过这种设计？（例如，微内核、Unikernel 或某些学术系统？）您认为通道的抽象在 OS 级别是否可行？
</code></pre>
<p>这是我第一次重视reddit</p>
<p>这是我的第一次提问在社区中，非常的难忘！社区中的大家是那么的热情，即使你们从未见过面！英文部分是我的想法用ai转换之后得来的，我的英语并不是很好哈哈</p>
<p><a href="https://www.reddit.com/r/golang/comments/1krtd88/could_gos_share_memory_by_communicating/">很开心这么多人回复问题！</a></p>
<h3 id="understanding-csp">Understanding CSP</h3>
<p><strong>CSP（Communicating Sequential Processes）</strong> 是一种并发模型，全称是 <strong>通信顺序进程</strong>，由计算机科学家 <strong>Tony Hoare</strong> 在 1978 年提出。</p>
<blockquote>
<p>CSP 的核心思想是：进程之间不共享内存，而是通过通信（消息传递）来协作</p>
</blockquote>
<p><a href="https://www.cnblogs.com/papering/p/9479496.html">CSP_blog</a></p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func worker(ch chan int) {
    val := &lt;-ch         &#x2F;&#x2F; 接收数据
    fmt.Println(val)
}

func main() {
    ch := make(chan int)
    go worker(ch)
    ch &lt;- 42             &#x2F;&#x2F; 发送数据
}

</code></pre>
<p>这个例子就是标准的 CSP：</p>
<ul>
<li>
<p>两个顺序进程（<code>main</code> 和 <code>worker</code>）</p>
</li>
<li>
<p>通道 <code>ch</code> 是它们的通信桥梁</p>
</li>
<li>
<p>没有共享内存，只靠通道通信</p>
</li>
<li>
<p><strong>CSP</strong> 是一种并发编程理论，强调进程通过**事件（Event）**通信（而非共享内存）。</p>
</li>
<li>
<p><strong>进程（Process）</strong>：代表一个独立的行为实体（如售货机或顾客），通过<strong>事件序列</strong>描述行为。</p>
</li>
<li>
<p><strong>同步（Synchronization）</strong>：多个进程在特定事件上必须“同步执行”（如顾客投币和售货机接收硬币是同一个 <code>coin</code> 事件）。</p>
</li>
</ul>
<h4 id="1-shou-huo-ji-jin-cheng"><strong>1. 售货机进程</strong></h4>
<p><strong>行为</strong>：</p>
<pre><code>1. 等待 `coin` 事件（投币）。
    
2. 执行 `choc` 事件（发放巧克力）。
    
3. 终止（`STOP`）。
</code></pre>
<ul>
<li><strong>意义</strong>：售货机<strong>必须先收钱再给货</strong>。</li>
</ul>
<h4 id="2-gu-ke-jin-cheng"><strong>2. 顾客进程</strong></h4>
<p>Person = (coin \rightarrow STOP) \square (card \rightarrow STOP)</p>
<ul>
<li>
<p><strong>行为</strong>：</p>
<ul>
<li>
<p><code>□</code> 表示<strong>外部选择</strong>（顾客可以选 <code>coin</code> 或 <code>card</code> 事件，但不会同时发生）。</p>
</li>
<li>
<p>选择后终止（<code>STOP</code>）。</p>
</li>
</ul>
</li>
<li>
<p><strong>意义</strong>：顾客有<strong>两种支付方式</strong>（硬币或刷卡），但每次只能选一种。</p>
</li>
</ul>
<h4 id="3-ru-guo-shou-huo-ji-zhi-tong-bu-coin"><strong>3. 如果售货机只同步 <code>coin</code></strong></h4>
<p>VendingMachine ,|, [coin] ,|, Person</p>
<ul>
<li>
<p><strong>结果</strong>：</p>
<p>(coin \rightarrow choc \rightarrow STOP) \square (card \rightarrow STOP)</p>
<ul>
<li>
<p>顾客选 <code>coin</code>：正常走售货机流程。</p>
</li>
<li>
<p>顾客选 <code>card</code>：售货机不响应，顾客直接终止（<code>STOP</code>）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-yin-cang-shi-jian"><strong>4. 隐藏事件</strong></h4>
<p><strong>结果</strong>：外部只能看到 <code>choc</code> 或直接终止，表现为<strong>非确定性选择</strong>（<code>⊓</code>）：</p>
<p>(choc \rightarrow STOP) \sqcap STOP</p>
<ul>
<li>
<p>可能发放巧克力后停止，也可能直接停止（因为看不到顾客的支付选择）</p>
</li>
<li>
<p><em><strong>同步约束：售货机和顾客必须就支付方式达成一致（如只支持现金时，刷卡会失败）。</strong></em></p>
</li>
<li>
<p><em><strong>非确定性：隐藏内部事件后，系统行为对外部观察者变得不可预测（如同实际场景中，路人看不到顾客是否投币，只能看到巧克力是否出来）。</strong></em></p>
</li>
</ul>
<p>CSP 的 <code>coin → choc → STOP</code> 类似 Go 中通过 channel 同步的两个 goroutine：</p>
<ul>
<li><strong>同步失败</strong>：如果 <code>vendingMachine</code> 只监听 <code>coin</code>，<code>card</code> 会阻塞。</li>
</ul>
<h3 id="cao-zuo-xi-tong-wei-shen-me-mei-yong-csp">操作系统为什么没用 CSP：</h3>
<ol>
<li><strong>性能优先：共享内存更快</strong></li>
</ol>
<p>操作系统关注 <strong>高性能调度与资源访问</strong>，**共享内存 + 同步机制（如锁、信号量）**可以做到：</p>
<ul>
<li>
<p>最低延迟（不需要拷贝）</p>
</li>
<li>
<p>高吞吐（直接访问同一块内存）</p>
</li>
</ul>
<p>➡ 相比之下，<strong>CSP 的通信（尤其跨进程）要复制数据、上下文切换，代价更大</strong>。</p>
<hr />
<ol start="2">
<li><strong>OS 中的“进程”不是 CSP 的“轻量进程”</strong></li>
</ol>
<p>CSP 模型适合的是 <strong>轻量并发实体（如 goroutine）</strong>，操作系统的：</p>
<ul>
<li>
<p>线程：重量级，切换成本高</p>
</li>
<li>
<p>进程：拥有独立内存空间，天然隔离</p>
</li>
</ul>
<p>操作系统级别的“进程”之间<strong>不共享内存</strong>，但通信靠 IPC（管道、socket、共享内存）实现——和 CSP 很像，但远不如 goroutine 高效。</p>
<h3 id="ipc-jin-cheng-jian-tong-xin">IPC 进程间通信</h3>
<pre><code>IPC（Inter-Process Communication，进程间通信）是一种机制，允许操作系统中不同进程之间交换数据或信号。由于每个进程拥有独立的内存空间，它们无法直接访问彼此的数据，因此需要通过IPC来实现协作和资源共享。
</code></pre>
<h3 id="cspde-you-lie-shi">CSP的优劣势</h3>
<p>原则： 如果违反 CSP 原则，<strong>通过 Channel 间接共享内存</strong>，仍需要锁：</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">type Data struct{ X int }
func main() {
    ch := make(chan *Data)
    d := &amp;Data{X: 1}
    go func() { ch &lt;- d }() &#x2F;&#x2F; 发送指针
    go func() { d.X++ }()   &#x2F;&#x2F; 竞态！违背 CSP
}
</code></pre>
<p>channel 不是万能保险，传的是引用时就要小心。</p>
<p>社区回答！</p>
<pre><code>There are cases where CSP produces better performance and cases where the performance is worse. On the one hand, for code that does a lot of small multithreaded operations (like incrementing integers etc), converting all operations to happen via channels is going to be much less performant because channels involve more work per operation. On the other hand, the fact that memory isn&#x27;t concurrently shared means that you can write faster single threaded code because you don&#x27;t need to worry about mutexes and barriers etc for objects received from channels.

</code></pre>
<p><a href="https://go-benchmarks.com/synchronization-methods">同步方法测试</a></p>
<p><a href="https://www.jtolio.com/2016/03/go-channels-are-bad-and-you-should-feel-bad/">一篇帖子的说明</a></p>
<p><em>作者的吐槽点</em> ： “- <strong>channel 适合某些场景</strong>（如任务队列、事件通知、流水线模式）。</p>
<ul>
<li>
<p><strong>mutex 适合另一些场景</strong>（如保护共享状态、简单临界区）。</p>
</li>
<li>
<p><strong>"channel of channels" 确实可能增加复杂度</strong>，但 Go 的 select + channel 机制也能提供强大的并发控制能力。”</p>
</li>
</ul>
<p>“作者的观点是 <strong>"不要为了用 channel 而用 channel"</strong>，应该根据实际情况选择最合适的同步机制（mutex 或 channel），而不是盲目遵循 Go 的 "share memory by communicating" 哲学。”</p>
<p><a href="https://songlh.github.io/paper/go-study.pdf">一篇论文</a></p>
<h4 id="yi-csp-de-lie-shi-chang-jing-xing-neng-chai">一、CSP 的劣势场景（性能差）：</h4>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">&#x2F;&#x2F; 用 mutex 的方式做 ++ 操作
mu.Lock()
counter++
mu.Unlock()

&#x2F;&#x2F; 用 channel 的方式做 ++ 操作
counterChan &lt;- 1
</code></pre>
<ul>
<li>
<p><code>chan</code> 本质是有同步开销的（排队、调度、阻塞），一个简单的 <code>++</code> 操作搞成 channel 会变得很重。</p>
</li>
<li>
<p>所以在高频、低开销场景，<strong>channel 性能不如原子操作 / 锁</strong>。</p>
</li>
</ul>
<h4 id="csp-de-you-shi-chang-jing-xing-neng-hao">CSP 的优势场景（性能好）：</h4>
<p>“但另一方面，因为内存不是共享的，单线程处理收到的 channel 数据，不需要加锁，写起来更快、更简单。”</p>
<p><strong>内存不是共享的”表述不严谨</strong>：</p>
<ul>
<li>
<p>channel 的底层本质仍然是共享内存；</p>
</li>
<li>
<p>它只是<strong>封装了共享细节，让你不直接共享</strong>；</p>
</li>
<li>
<p>所以说准确表述应是：“你<strong>不需要直接访问共享内存</strong>”</p>
</li>
</ul>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">&#x2F;&#x2F; 一个 goroutine 独占处理任务队列
go func() {
  for task := range taskChan {
    handle(task) &#x2F;&#x2F; 不需要担心并发访问
  }
}()

</code></pre>
<h4 id="kun-huo">困惑</h4>
<p>channel的内部也就是底层实现 不还是使用的内存共享+锁机制实现的吗，这里面真的会有性能差别吗？</p>
<h4 id="he-xin-hui-da">核心回答！</h4>
<p><code>你用不用锁，和系统/库替你加不加锁，是两回事。</code></p>
<p>Go 的 <code>channel</code> 底层确实是用<strong>共享内存 + 加锁</strong>实现的：</p>
<ul>
<li>
<p><code>chan</code> 的发送和接收涉及锁（<code>mutex</code>）、等待队列（<code>sudog</code>）、调度协程切换等。</p>
</li>
<li>
<p>所以说 channel 本身也有“同步开销”。</p>
</li>
</ul>
<p>那为什么说 “你写的代码没锁” 性能反而更好？</p>
<h4 id="guan-jian-shi-feng-zhuang-he-bing-fa-yu-zui-xiao-hua"><strong>关键是“封装” 和 “并发域最小化”</strong>：</h4>
<blockquote>
<p>channel 把“并发边界”控制在接口级别，而不是让你每个字段自己去加锁。</p>
</blockquote>
<p><strong>你写的处理函数</strong>只处理 <code>&lt;-chan</code> 接收的数据，不访问共享变量：</p>
<ul>
<li>
<p>它是<strong>串行</strong>的，不涉及任何并发操作；</p>
</li>
<li>
<p>所以<strong>你可以不用管加锁、原子操作、同步屏障</strong>；</p>
</li>
<li>
<p>你的代码天然是“线程安全”的，这会<strong>减少脑力负担 + 提高可维护性 + 避免 bug</strong>。</p>
</li>
</ul>
<p><strong>channel 是“通信安全”，不是“零成本”。</strong><br />
真正的性能差异不在“是否用了内存共享”，而是<strong>谁来负责并发同步的复杂性</strong></p>
<p><em>数据被携带着传输”这句，<strong>精准命中了 CSP 的核心思想</strong>，也正是 Go 在并发编程中推荐的思维方式。</em></p>
<blockquote>
<p><em><strong>不要通过共享内存来通信，而应该通过通信来共享内存。</strong>（Go 编程语言官方理念）</em></p>
</blockquote>
<h3 id="plan-9-from-bell-labs"><strong>Plan 9 from Bell Labs</strong></h3>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">The OS itself also avoids sharing memory, and of course there are &quot;channels&quot; for communicating: file descriptors, which can be devices, pipes, network connections, etc. Like in Unix. But it goes beyond what traditional Unix does, because many userspace applications are file servers that provide a file descriptor that can be mounted onto the file system, and provide more such file descriptors, etc. It&#x27;s a very simple but powerful system.
</code></pre>
<p>plan9操作系统避免了共享内存, 那内部是什么样的呢 进程之间如何通信呢</p>
<p>在Go SDK中 runtime包中含又 plan9的身影！</p>
<p>Plan 9 <strong>避免传统的共享内存和多线程同步机制</strong>，鼓励进程之间用“文件通信”（如命名管道、9P 协议）：</p>
<ul>
<li>
<p>类似 Go 的 Channel，但用的是文件协议。</p>
</li>
<li>
<p>所有通信都可序列化，可远程传输。</p>
</li>
</ul>
<blockquote>
<p>难道操作文件就不是操作同一块内存了吗？</p>
</blockquote>
<p>示例：</p>
<p>共享内存</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">int *shared = mmap(...);  &#x2F;&#x2F; 多个进程访问这个地址
*shared = 42;             &#x2F;&#x2F; 谁都能读写这块内存
</code></pre>
<p>文件通信</p>
<pre><code>echo 42 &gt; &#x2F;srv&#x2F;somefile     # 写入
cat &#x2F;srv&#x2F;somefile           # 另一个程序读
</code></pre>
<p>虽然最终数据可能写入页缓存或磁盘（确实会进内存），但你<strong>无法直接访问或共享那块内存</strong>，只能通过：</p>
<ul>
<li>
<p>系统调用（read/write）</p>
</li>
<li>
<p>Channel 抽象（Go）</p>
</li>
<li>
<p>文件协议（Plan 9）</p>
</li>
</ul>
<h4 id="yi-wen">疑问：</h4>
<ol>
<li>那xv6系统的内存的关于 前面所说的CSP理论和共享内存，xv6是偏向与什么？ 或者说linux系统都沿用了文件通信？</li>
</ol>
<blockquote>
<p>xv6 和 Linux 都以“共享内存 + 文件通信”为基础，核心机制是“共享内存 + 加锁”，而不是 CSP 模型。</p>
</blockquote>
<ol start="2">
<li>所以说文件通信和CSP之间的关系是什么？ 有联系吗 为什么前面你跟我说Plan 9 设计就是避免共享内存，强调文件通信 + 用户态协议 那既然文件通信是避免共享内存，那为什么不能说xv6等liunx操作系统不是CSP模型呢</li>
</ol>
<blockquote>
<p>文件通信是一种实现机制，CSP 是一种并发模型。Plan 9 把文件通信机制用于实现类似 CSP 的并发风格；而 Linux 虽然也有文件通信，但仍然基于共享内存 + 锁，不符合 CSP 的并发语义。</p>
</blockquote>
<table><thead><tr><th>特性</th><th>Linux/xv6</th><th>CSP (Plan 9 风格)</th></tr></thead><tbody>
<tr><td>默认通信方式</td><td>共享内存 + 锁</td><td>Channel / 消息</td></tr>
<tr><td>文件通信</td><td>有，但不普遍用作并发通信</td><td>核心机制</td></tr>
<tr><td>并发语义</td><td>多线程共享状态</td><td>顺序过程 + 通信</td></tr>
<tr><td>并发控制</td><td>mutex、atomic、lock</td><td>通信即同步</td></tr>
<tr><td>数据一致性</td><td>程序员手动维护</td><td>通信机制保证</td></tr>
</tbody></table>
<p>Plan 9 并没有在商业或主流社区中广泛流行，但它对<strong>现代操作系统的设计理念影响深远</strong>。许多重要思想被吸收进 Linux、Go 语言、Docker 等系统中。</p>
<h2 id="mkfifo-is-os-s-channel">mkfifo is OS's channel</h2>
<ul>
<li>
<p><code>mkfifo</code> 是一个 Linux 系统调用（命令），用于<strong>创建一个命名管道（FIFO）</strong>。</p>
</li>
<li>
<p>FIFO = First In, First Out，像文件一样存在于磁盘，但其实是一种特殊的**IPC（进程间通信）**手段。</p>
</li>
<li>
<p>创建后，多个进程可以通过读写这个“文件”来通信。</p>
</li>
</ul>
<table><thead><tr><th>Go 的 <code>chan</code></th><th>OS 的 <code>mkfifo</code></th></tr></thead><tbody>
<tr><td>语言级通道，只在 Go 中使用</td><td>系统级别，多个进程/语言可用</td></tr>
<tr><td>内存中的结构，速度快</td><td>磁盘上的文件，效率低，但能跨进程</td></tr>
<tr><td>用于 goroutine 间通信</td><td>用于进程间通信（IPC）</td></tr>
<tr><td>类型安全、阻塞/非阻塞控制强</td><td>只能读字节流，无结构化信</td></tr>
</tbody></table>
<h2 id="xian-cheng-chi">线程池</h2>
<h2 id="pi-ping-go-yu-yan-zai-cuo-wu-chu-li-he-yi-xie-te-shu-yu-fa-shang-de-bu-yi-zhi-xing"> <strong>批评 Go 语言在错误处理和一些特殊语法上的不一致性</strong></h2>
<p><a href="https://bravenewgeek.com/go-is-unapologetically-flawed-heres-why-we-use-it/">另一篇</a></p>
<pre><code>There are other peculiar idiosyncrasies. Error handling is generally done by returning error values. This is fine, and I can certainly see the motivation coming from the abomination of C++ exceptions, but there are cases where Go doesn’t follow its own rule. For example, map lookups return two values: the value itself (or zero-value&#x2F;nil if it doesn’t exist) and a boolean indicating if the key was in the map. Interestingly, we can choose to ignore the boolean value altogether—a syntax reserved for certain blessed types in the standard library. Type assertions and channel receives have equally curious behavior.
</code></pre>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">file, err := os.Open(&quot;foo.txt&quot;)
if err != nil {
    return err
}
</code></pre>
<ul>
<li>这是 Go 的核心设计哲学之一：<strong>强制程序员显式处理错误</strong>，避免像 C++ 异常（exceptions）那样隐式传播。</li>
</ul>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">value, exists := myMap[&quot;key&quot;]  &#x2F;&#x2F; 返回值和布尔值
value = myMap[&quot;key&quot;]           &#x2F;&#x2F; 可以忽略布尔值，直接取值
</code></pre>
<ul>
<li>
<p>但 Go 允许 <strong>直接忽略布尔值</strong>，这种语法是 <strong>标准库的 "特权"</strong>（"blessed types"），普通函数无法实现类似行为。</p>
</li>
<li>
<p>这违背了 Go 的 "显式处理" 原则。</p>
</li>
</ul>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">str, ok := x.(string)  &#x2F;&#x2F; 安全写法，返回 (value, bool)
str = x.(string)       &#x2F;&#x2F; 如果失败，直接 panic（类似异常）
</code></pre>
<ul>
<li>
<p>第一种形式（返回 <code>bool</code>）符合 Go 的错误处理风格。</p>
</li>
<li>
<p>第二种形式（直接 <code>panic</code>）却 <strong>退回到了异常机制</strong>，与 Go 的哲学矛盾。</p>
</li>
</ul>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">val, ok := &lt;-ch  &#x2F;&#x2F; 如果 channel 关闭，ok 为 false
val = &lt;-ch       &#x2F;&#x2F; 如果 channel 关闭，返回零值（无警告）
</code></pre>
<ul>
<li>
<p>第一种形式可以检测 channel 是否关闭。</p>
</li>
<li>
<p>第二种形式 <strong>静默接受零值</strong>，可能导致隐蔽的 bug。</p>
</li>
<li>
<p><em><strong>对开发者的启示：</strong></em></p>
<ul>
<li>
<p><em><strong>需要警惕这些 "语法糖" 可能隐藏的问题。</strong></em></p>
</li>
<li>
<p><em><strong>在关键代码中，始终使用完整形式（如 <code>val, ok := m[key]</code>）以避免 bug。</strong></em></p>
</li>
</ul>
</li>
</ul>
<h2 id="li-jie-yi-chang-he-cuo-wu">理解异常和错误</h2>
<ol>
<li>错误（<code>error</code>）——正常业务流程中的问题</li>
</ol>
<p>本质：</p>
<ul>
<li>
<p>是一种<strong>值</strong>（<code>error</code> 接口类型），代表函数运行时出现的问题。</p>
</li>
<li>
<p><strong>你需要主动检查和处理</strong>。</p>
</li>
</ul>
<ol start="2">
<li>异常（<code>panic</code>）——非正常流程，程序直接崩溃</li>
</ol>
<p>本质：</p>
<ul>
<li>
<p>是 Go 用来表示<strong>程序出现严重问题时</strong>的机制。</p>
</li>
<li>
<p>一旦 <code>panic</code> 被调用，当前函数就会停止执行，<strong>逐层向上退出栈帧</strong>，直到程序崩溃或被 <code>recover</code> 捕获</p>
</li>
</ul>
<p>常用于：</p>
<ul>
<li>
<p>数组越界</p>
</li>
<li>
<p>nil 指针调用</p>
</li>
<li>
<p>程序员写错逻辑时提示开发者修复</p>
</li>
</ul>
<blockquote>
<p><strong>错误（error）是业务可恢复的问题，异常（panic）是不可恢复、必须终止或特殊处理的问题。</strong><br />
在实际开发中，<strong>90% 的问题都用 error 返回，不要滥用 panic</strong></p>
</blockquote>
<p>Go 的理念之一是“通过交流分享记忆;不要通过共享内存来交流。这是标准库似乎经常打破的另一个规则。标准库中大约有 60 个通道，不包括测试。如果您浏览代码，您会发现互斥锁往往是首选，并且通常性能更好 — 稍后将对此进行详细介绍。</p>
<h2 id="sync-atomic">sync/atomic</h2>
<pre><code>We want sync to be clearly documented and used when appropriate. We generally don’t want sync&#x2F;atomic to be used at all…Experience has shown us again and again that very very few people are capable of writing correct code that uses atomic operations…If we had thought of internal packages when we added the sync&#x2F;atomic package, perhaps we would have used that. Now we can’t remove the package because of the Go 1 guarantee.
</code></pre>
<ol>
<li>
<p><strong><code>sync</code> 包的定位</strong>：</p>
<ul>
<li>
<p><code>sync</code> 包（如 <code>sync.Mutex</code>、<code>sync.WaitGroup</code>）是 <strong>官方推荐</strong> 的同步原语，应该被 <strong>清晰地文档化</strong> 并在合适的场景使用。</p>
</li>
<li>
<p>这些高阶同步工具（如互斥锁、条件变量）已经封装了底层复杂性，普通开发者可以安全使用。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>sync/atomic</code> 包的定位</strong>：</p>
<ul>
<li>
<p><code>sync/atomic</code>（提供原子操作，如 <code>atomic.AddInt32</code>）<strong>本应设计为内部包</strong>（<code>internal</code>），因为它的正确使用需要极深的并发编程经验。</p>
</li>
<li>
<p>绝大多数开发者 <strong>无法写出正确的原子操作代码</strong>（即使是有经验的程序员也容易犯错）。</p>
</li>
<li>
<p>但由于历史原因（Go 1 兼容性承诺），现在无法移除或隐藏该包。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><em><strong>Go 团队认为 原子操作是危险的，应该尽量避免使用，除非在极少数底层库（如运行时、标准库内部）中。</strong></em></p>
</li>
<li>
<p><em><strong>普通业务代码应优先使用 <code>sync</code> 包提供的更安全的抽象（如 <code>Mutex</code>），而非直接操作 <code>atomic</code>。</strong></em></p>
</li>
</ul>
<p><em>WHY？？？</em></p>
<ul>
<li>
<p>原子操作的正确性依赖于 <strong>内存模型</strong>（memory model）和 <strong>CPU 指令顺序</strong>（memory ordering）。</p>
</li>
<li>
<p>开发者需要理解 <strong>可见性</strong>（visibility）、<strong>重排序</strong>（reordering）、<strong>ABA 问题</strong> 等复杂概念，否则极易写出有 bug 的代码。</p>
</li>
<li>
<p>基于原子操作的代码通常难以阅读和调试（例如无锁数据结构）。</p>
</li>
<li>
<p>团队协作时，其他成员可能无法理解其背后的并发逻辑。</p>
</li>
</ul>
<pre><code> Go 团队的历史决策反思
1. `internal` 包的缺失：

    - Go 早期没有 `internal` 包机制（限制某些包仅限标准库内部使用）。
        
    - 如果当时有，`sync&#x2F;atomic` 可能会被标记为 `internal`，避免外部开发者误用。
        
2. Go 1 兼容性承诺：
    
    - Go 1 版本承诺不破坏向后兼容性，因此即使现在认识到 `atomic` 的问题，也无法移除或降级该包。
</code></pre>
<pre><code>Clearly, channels are not particularly great for workload throughput, and you’re typically better off using a lock-free ring buffer or even a synchronized queue. Channels as a unit of composition tend to [fall short](https:&#x2F;&#x2F;gist.github.com&#x2F;kachayev&#x2F;21e7fe149bc5ae0bd878) as well. Instead, they are better suited as a coordination pattern, a mechanism for signaling and timing-related code. Ultimately, you must use channels judiciously if you are sensitive to performance.
</code></pre>
<h3 id="yuan-zi-cao-zuo-he-suo-de-qu-bie">原子操作和锁的区别</h3>
<table><thead><tr><th>特性</th><th>原子操作（<code>atomic</code>）</th><th>锁（<code>Mutex</code>）</th></tr></thead><tbody>
<tr><td><strong>底层机制</strong></td><td>直接使用 CPU 原子指令（如 <code>CAS</code>、<code>LL/SC</code>）</td><td>基于操作系统调度（如 <code>futex</code>）</td></tr>
<tr><td><strong>粒度</strong></td><td>单变量级别（如 <code>int32</code>、<code>pointer</code>）</td><td>代码块级别（保护一段逻辑）</td></tr>
<tr><td><strong>是否阻塞</strong></td><td>非阻塞（硬件级原子操作，无上下文切换）</td><td>阻塞（竞争失败时，线程会休眠）</td></tr>
<tr><td><strong>适用场景</strong></td><td>简单变量操作（计数器、标志位）</td><td>复杂逻辑（需保护多个变量或代码段）</td></tr>
<tr><td><strong>性能</strong></td><td>极高（无锁，无线程切换）</td><td>较低（锁竞争时有上下文切换开销）</td></tr>
<tr><td><strong>正确性难度</strong></td><td>高（需理解内存模型，易写出 bug）</td><td>低（直接加锁，逻辑清晰）</td></tr>
</tbody></table>
<h2 id="gong-xiang-nei-cun-he-csp">共享内存和CSP</h2>
<p>共享内存去并发，和csp理论去并发 为什么会有很大的差别，为什么csp貌似是对并发更好的模型</p>
<p><strong>共享内存并发强调“状态共享”，而 CSP 并发强调“消息传递”</strong>。<br />
<strong>CSP 更容易构建正确、安全、可组合的并发程序。</strong></p>
<table><thead><tr><th>方面</th><th>共享内存 (Shared Memory)</th><th>CSP（通信顺序进程）</th></tr></thead><tbody>
<tr><td>本质</td><td>多个线程访问同一内存变量</td><td>多个进程通过通道通信</td></tr>
<tr><td>协作方式</td><td>读写共享变量 + 加锁</td><td>发送消息 + 阻塞等待</td></tr>
<tr><td>错误风险</td><td>数据竞争，死锁，难调试</td><td>更可控，天然同步</td></tr>
<tr><td>例子</td><td>C/C++ 中的线程 + mutex</td><td>Go 中的 goroutine + channel</td></tr>
</tbody></table>
<p><em>共享内存的问题！</em></p>
<ul>
<li>
<p><strong>可见性问题</strong>：一个线程修改变量，另一个线程可能看不到（CPU 缓存、编译器优化等）</p>
</li>
<li>
<p><strong>竞争条件（Race Condition）</strong>：线程读写冲突导致不一致</p>
</li>
<li>
<p><strong>加锁非常脆弱</strong>：容易忘记加锁、锁顺序死锁、性能差、调试困难</p>
</li>
<li>
<p><strong>状态耦合</strong>：多个线程对共享数据的意图难以区分</p>
</li>
</ul>
<p><em>CSP 把“并发的核心问题”转化了：</em></p>
<ul>
<li>
<p><strong>从“如何共享变量”转为“如何传递消息”</strong></p>
</li>
<li>
<p><strong>通道通信是同步的，相当于自带锁机制</strong></p>
</li>
<li>
<p><strong>goroutine 是轻量级的，天然适合大规模并发</strong></p>
</li>
</ul>
<p><strong>CSP 不是性能最强的模型，但</strong>：</p>
<ul>
<li>
<p>对“人类开发者”更友好；</p>
</li>
<li>
<p>对复杂系统的“构建和演化”更稳定；</p>
</li>
<li>
<p>也是构建现代高并发系统时的<strong>主流模型之一</strong>。</p>
</li>
</ul>
<p><em><strong>！！！ 你不是去“抢”变量，而是“请求”那个管理它的 goroutine 来操作它。</strong></em></p>
<h2 id="plan9-go">Plan9 &amp; Go</h2>
<h3 id="she-ji-si-xiang-de-guan-lian">设计思想的关联</h3>
<table><thead><tr><th>Plan 9 的设计思想</th><th>Go 中的体现</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>一切皆文件</strong>（包括网络、图形等）</td><td><code>io.Reader</code> / <code>io.Writer</code> 接口统一抽象</td><td>所有输入输出都被看作流（stream），统一接口风格</td></tr>
<tr><td><strong>简洁统一的接口设计</strong></td><td>接口设计简洁、不需显式实现，强调组合</td><td><code>interface</code> 不需要 <code>implements</code>，鼓励面向抽象编程</td></tr>
<tr><td><strong>资源命名空间 per process</strong></td><td>每个 <code>goroutine</code> 轻量、可独立使用 channel</td><td>更细粒度的资源隔离感，goroutine 独立如 namespace</td></tr>
<tr><td><strong>9P 协议：分布式资源像本地一样访问</strong></td><td>Go 的网络库设计抽象化（如 <code>net.Conn</code>）</td><td>可以轻松写出“远程等于本地”的通信程序</td></tr>
<tr><td><strong>并发不是线程，是消息通信（管道）</strong></td><td><code>goroutine</code> + <code>channel</code> 是核心特性</td><td>正是 CSP 模型（通讯顺序进程），而非线程锁死等待</td></tr>
<tr><td><strong>最小化系统复杂性</strong></td><td>Go 排除继承、多重继承、异常机制</td><td>简单就是力量，避免复杂性带来的维护成本</td></tr>
<tr><td><strong>自举系统（compiler/runtime 用自己写）</strong></td><td>Go 的工具链也是用 Go 写的（包括编译器、fmt 工具等）</td><td>自洽、可控、统一体验</td></tr>
</tbody></table>
<p>从plan9中吸收的内容</p>
<ul>
<li>
<p><strong>组合优于继承</strong>：Plan 9 没有传统面向对象；Go 同样用接口 + 组合结构体替代类继承；</p>
</li>
<li>
<p><strong>消息通信代替共享内存</strong>：Plan 9 提倡“不要共享内存”；Go 鼓励用 channel 通信而非锁；</p>
</li>
<li>
<p><strong>极简内核</strong>：Plan 9 内核极简但灵活；Go 工具链同样追求“一个命令搞定”的体验；</p>
</li>
<li>
<p><strong>统一接口抽象</strong>：Plan 9 的资源访问统一为文件；Go 将几乎所有资源抽象成 <code>io.Reader</code>/<code>Writer</code>。</p>
</li>
</ul>
<p>Plan 9 的几个核心哲学在 Go 中的体现</p>
<hr />
<h3 id="1-yi-qie-jie-wen-jian-io-reader-io-writer-chou-xiang">1. <strong>一切皆文件 / io.Reader + io.Writer 抽象</strong></h3>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	var r io.Reader = strings.NewReader(&quot;Hello Plan 9!&quot;)
	io.Copy(os.Stdout, r) &#x2F;&#x2F; 输出到标准输出：Hello Plan 9!
}
</code></pre>
<blockquote>
<p>无论是文件、字符串、网络连接，只要实现 <code>Reader</code> 接口，就能互换使用。</p>
</blockquote>
<hr />
<h3 id="2-zu-he-you-yu-ji-cheng">2. <strong>组合优于继承</strong></h3>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">type Logger struct{}

func (l Logger) Log(msg string) {
	println(&quot;[LOG]&quot;, msg)
}

type Service struct {
	Logger &#x2F;&#x2F; 嵌入，而非继承
}

func main() {
	s := Service{}
	s.Log(&quot;Service started&quot;) &#x2F;&#x2F; 调用嵌入字段的方法
}
</code></pre>
<blockquote>
<p>Go 不用继承，通过结构体组合来共享行为。</p>
</blockquote>
<h4 id="zu-he-you-yu-ji-cheng-wei-shen-me-zai-go-zhong-shi-zheng-que-de">组合优于继承” 为什么在 Go 中是正确的？</h4>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">type Logger struct{}
func (l Logger) Log(msg string) { fmt.Println(&quot;[LOG]&quot;, msg) }

type Service struct {
	Logger &#x2F;&#x2F; 组合，而不是继承
}
</code></pre>
<p>继承带来耦合，组合带来解耦</p>
<ul>
<li>
<p>灵活：只组合需要的行为</p>
</li>
<li>
<p>解耦：Logger 改变不影响 Service</p>
</li>
<li>
<p>模块化更强，符合现代微服务理念</p>
</li>
</ul>
<hr />
<h3 id="3-csp-bing-fa-mo-xing-goroutine-channel">3. <strong>CSP 并发模型（goroutine + channel）</strong></h3>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">func worker(ch chan string) {
	for msg := range ch {
		println(&quot;received:&quot;, msg)
	}
}

func main() {
	ch := make(chan string)
	go worker(ch)

	ch &lt;- &quot;task 1&quot;
	ch &lt;- &quot;task 2&quot;
	close(ch)
}
</code></pre>
<blockquote>
<p>goroutine 类似 Plan 9 的 lightweight process，channel 是通信通道，避免共享内存。</p>
</blockquote>
<hr />
<h3 id="4-zi-yuan-an-ming-ming-kong-jian-chou-xiang-net-conn-chou-xiang">4. <strong>资源按命名空间抽象（net.Conn 抽象）</strong></h3>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	conn, _ := net.Dial(&quot;tcp&quot;, &quot;example.com:80&quot;)
	fmt.Fprintf(conn, &quot;GET &#x2F; HTTP&#x2F;1.0\r\n\r\n&quot;)
	buf := make([]byte, 4096)
	n, _ := conn.Read(buf)
	fmt.Println(string(buf[:n]))
}
</code></pre>
<blockquote>
<p><code>net.Conn</code> 可以代表 TCP、Unix socket 等，是统一的“文件风格”资源访问。</p>
</blockquote>
<hr />
<h3 id="5-zi-ju-zui-xiao-gong-ju-lian-go-bian-yi-qi-gong-ju-jiu-shi-yong-go-xie-de">5. <strong>自举 + 最小工具链：Go 编译器/工具就是用 Go 写的</strong></h3>
<pre data-lang="bash" class="language-bash "><code class="language-bash" data-lang="bash">go build main.go
go fmt main.go
go run main.go
</code></pre>
<blockquote>
<p>没有 <code>make</code>，不需要配置，直接编译运行，体现极简主义。</p>
</blockquote>
<hr />
<h3 id="zong-jie">总结</h3>
<p>Go 语言很多地方直接体现了 Plan 9 的理念，尤其是：</p>
<ul>
<li>
<p><strong>接口驱动的抽象</strong>：<code>io.Reader</code> / <code>net.Conn</code></p>
</li>
<li>
<p><strong>并发设计</strong>：channel 通信优先于加锁</p>
</li>
<li>
<p><strong>结构体组合</strong>：轻松构造可复用模块</p>
</li>
<li>
<p><strong>极简工具链</strong>：从构建到部署尽可能统一</p>
</li>
</ul>
<h2 id="xi-tong-zi-liao">系统资料</h2>
<p><a href="https://lwn.net/Articles/250967/">Articles</a></p>
<p><a href="https://go-proverbs.github.io/">Go 谚语</a></p>
<p><a href="https://draven.co/golang/">Go语言设计与实现</a></p>
<p><a href="https://luminousmen.com/">技术博客</a></p>
<h2 id="pipe-he-channel">pipe 和 channel</h2>
<p><strong>channel 和管道（pipe）不是一个东西</strong>，虽然它们的用途都是“通信”，但它们<strong>作用范围、实现层级、性能、使用方式都不同</strong>。</p>
<table><thead><tr><th>特性</th><th>Go <code>channel</code></th><th>操作系统 <code>pipe</code>（管道）</th></tr></thead><tbody>
<tr><td>属于哪一层</td><td><strong>用户态</strong>，Go runtime 提供</td><td><strong>内核态</strong>，操作系统提供</td></tr>
<tr><td>通信对象</td><td><strong>Goroutine 之间通信（线程级）</strong></td><td><strong>进程之间通信（进程级）</strong></td></tr>
<tr><td>是否跨语言</td><td>否（Go 专属）</td><td>是（C、Python、Bash 等都能用）</td></tr>
<tr><td>是否跨进程</td><td>否</td><td>是</td></tr>
<tr><td>是否需要内核参与</td><td>否（调度在用户态）</td><td>是（需要系统调用）</td></tr>
<tr><td>通信方式</td><td><code>ch &lt;- val</code>, <code>&lt;- ch</code></td><td><code>write(pipefd[1], ...)</code>, <code>read(...)</code></td></tr>
<tr><td>性能</td><td>高（上下文切换成本低）</td><td>相对低（涉及内核上下文切换）</td></tr>
<tr><td>线程安全</td><td>是（channel 天然并发安全）</td><td>是（由内核控制）</td></tr>
</tbody></table>
<p><strong>pipe 并不使用 CSP（通信顺序进程）思想</strong>。</p>
<p>操作系统中的 <code>pipe</code> 本质上是<strong>两个进程通过共享内核缓冲区来读写数据</strong>：</p>
<ul>
<li>
<p>写进程调用 <code>write()</code> 把数据写入 pipe（内核缓冲区）；</p>
</li>
<li>
<p>读进程调用 <code>read()</code> 从 pipe 中读取数据；</p>
</li>
<li>
<p>管道本质上是<strong>一个 FIFO（先进先出）缓冲区</strong>；</p>
</li>
<li>
<p>多数是<strong>阻塞式</strong>的（读时无数据就阻塞，写时缓冲区满也阻塞）；</p>
</li>
<li>
<p>是一种<strong>共享内存 + 同步机制</strong></p>
</li>
</ul>

    </div>

    

    

    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://Zhonghe-zhao.github.io/DailyBlog/tags/reddit/">#reddit</a>
                    
                        <a href="https://Zhonghe-zhao.github.io/DailyBlog/tags/book/">#Book</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;issue-8&#x2F;">‹  6.s081学习</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;issue-6&#x2F;"> 提问的智慧 ›</a>
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://Zhonghe-zhao.github.io/DailyBlog/even.js" ></script>
      
    </body>

</html>
