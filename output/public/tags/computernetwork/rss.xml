<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title> - ComputerNetwork</title>
      <link>https://Zhonghe-zhao.github.io/DailyBlog/</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://Zhonghe-zhao.github.io/DailyBlog/tags/computernetwork/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Wed, 25 Jun 2025 09:17:17 +0000</lastBuildDate>
      <item>
          <title>Computer_Network</title>
          <pubDate>Wed, 25 Jun 2025 09:17:17 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-28/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-28/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-28/">&lt;h2 id=&quot;osimo-xing&quot;&gt;OSI模型&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;核心： 每一层只负责特定的功能&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;物理层：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;传输原始比特流（0和1）&lt;&#x2F;p&gt;
&lt;p&gt;协议： Ethernet (IEEE 802.3)&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;数据链路层：
(交换机)
将比特流组织成数据帧，通过MAC地址在局域网内寻址&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;错误检测（如CRC）、流量控制（如交换机）。&lt;&#x2F;p&gt;
&lt;p&gt;协议： Ethernet (IEEE 802.3)、Wi-Fi (IEEE 802.11) PPP（点对点协议）、VLAN（虚拟局域网）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;网络层：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑寻址（如IP地址）和路由选择（决定数据包从源到目标的路径）。&lt;&#x2F;p&gt;
&lt;p&gt;关键设备：路由器（Router）、三层交换机。&lt;&#x2F;p&gt;
&lt;p&gt;协议： IP（IPv4&#x2F;IPv6）、ICMP（Ping）、OSPF、BGP（路由协议）、ARP（地址解析）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;传输层（Transport Layer）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;提供端到端（应用程序之间）的可靠或不可靠传输。&lt;&#x2F;p&gt;
&lt;p&gt;分段（将数据分成段）、流量控制、错误恢复（如重传）。&lt;&#x2F;p&gt;
&lt;p&gt;协议： TCP UDP&lt;&#x2F;p&gt;
&lt;p&gt;5.表示层
6.会话层&lt;&#x2F;p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;应用层&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;直接为用户应用程序提供网络服务接口。&lt;&#x2F;p&gt;
&lt;p&gt;协议： HTTP（网页）、FTP（文件传输）、SMTP（邮件）、DNS（域名解析）、SSH（安全登录）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-hua-de-tcp-ipmo-xing&quot;&gt;简化的TCP&#x2F;IP模型&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;li-jie-dui-deng-chuan-shu&quot;&gt;理解对等传输&lt;&#x2F;h2&gt;
&lt;p&gt;每一层的协议在逻辑上认为自己在直接和对端同一层通信，尽管实际数据需要经过下层封装传输。&lt;&#x2F;p&gt;
&lt;p&gt;也就是 协议栈中同一层的虚拟直接对话 数据在设备间经过的物理和逻辑路径。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例：以HTTP请求为例的双重视角&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;1.主机A（192.168.1.2）访问服务器B（203.0.113.5）的网页，经过一个路由器。&lt;&#x2F;p&gt;
&lt;p&gt;主机A的HTTP协议 ↔ 服务器B的HTTP协议&lt;&#x2F;p&gt;
&lt;p&gt;逻辑上认为直接发送GET &#x2F;index.html并接收200 OK响应。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;主机A的TCP ↔ 服务器B的TCP&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上建立端到端连接，维护序列号和确认机制。&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;主机A的IP ↔ 服务器B的IP&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上认为IP包从192.168.1.2直达203.0.113.5。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;主机A的MAC ↔ 路由器R1的MAC ↔ 服务器B的MAC&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上逐跳协商帧传输（每跳MAC地址变化）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-1&quot;&gt;问题1：&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;交换机转发帧时，是否破坏了数据链路层的对等性？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;交换机只短暂参与MAC层转发，最终帧仍由目标主机的数据链路层处理。&lt;&#x2F;p&gt;
&lt;p&gt;交换机对帧的转发依赖物理层完成信号传输&lt;&#x2F;p&gt;
&lt;p&gt;交换机： 它根据 MAC 地址表，接收帧 → 看目标 → 选择接口转发帧，不改帧内容，也不破坏通信逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;所以交换机就是在链路层转发帧的智能中继器，它不参与更上层的逻辑，靠 MAC 地址表做“选择转发”。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-2&quot;&gt;问题2：&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;IP提供全局逻辑寻址，MAC提供局域网物理寻址 具体是什么流程&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ip：&lt;&#x2F;p&gt;
&lt;p&gt;“全局”：IP地址（例如192.168.1.10或公网IP如8.8.8.8）是全球范围内唯一的，就像一个人的家庭地址（国家+城市+街道+门牌号）。无论设备在世界的哪个角落，IP地址都能唯一标识它。&lt;&#x2F;p&gt;
&lt;p&gt;“逻辑”：IP地址不是绑在硬件上的，而是由软件配置的。比如，你换了网卡，IP地址可以保持不变；或者你把电脑带到另一个网络，IP地址可以重新分配。这种灵活性让IP地址像一个“虚拟标签”，不依赖物理设备。&lt;&#x2F;p&gt;
&lt;p&gt;“寻址”：IP地址的作用是告诉数据包“最终要去哪里”。比如，你从上海寄快递到北京，IP地址就像快递单上的收件人地址，路由器会根据它决定把数据包送到哪个网络。&lt;&#x2F;p&gt;
&lt;p&gt;MAC：&lt;&#x2F;p&gt;
&lt;p&gt;“局域网”：MAC地址（例如AA:BB:CC:DD:EE:FF）只在同一个局域网（LAN，比如你家Wi-Fi网络）内有效。出了这个局域网，MAC地址就没用了，就像你家楼栋内的门牌号，只在楼里有效，出了小区就没人知道。&lt;&#x2F;p&gt;
&lt;p&gt;“物理”：MAC地址是网卡的硬件地址，烧录在网卡芯片里，相当于设备的“身份证号”。它直接跟硬件绑定，告诉局域网内的设备“这是谁的网卡”。&lt;&#x2F;p&gt;
&lt;p&gt;“寻址”：在局域网内，数据包（以太网帧）靠MAC地址找到具体的设备。比如，你家有台电脑和打印机，交换机通过MAC地址知道把数据送到电脑还是打印机。&lt;&#x2F;p&gt;
&lt;p&gt;为什么重要？：局域网内的设备通信很快，交换机直接用MAC地址表转发数据，不需要复杂的逻辑判断，效率很高。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-3&quot;&gt;问题3：&lt;&#x2F;h2&gt;
&lt;p&gt;假如用我的思想就是，既然ip是唯一的，那么直接用ip通过路由器找到目标机器，既然交换机不能识别帧我们就去除MAC层？ 难道不行吗 直接对ip包传输到物理层？&lt;&#x2F;p&gt;
&lt;p&gt;IP地址可能重复（不同局域网可能用相同的私有IP）。MAC地址在局域网内由硬件保证唯一，适合本地寻址。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;这可能就是我的思想出了问题！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;IP：负责端到端的全局寻址，确保数据包从源（比如上海的电脑）到目标（比如北京的服务器）能跨网络到达。它像快递的全国调度系统，规划路线但不负责具体投递。&lt;&#x2F;p&gt;
&lt;p&gt;MAC：负责点到点的局域网内传输，确保数据在当前局域网内送到正确设备（比如你家电脑到路由器）。它像小区快递员，只管本地投递，不关心包裹从哪来、去哪。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;httpxie-yi&quot;&gt;HTTP协议&lt;&#x2F;h2&gt;
&lt;p&gt;首先HTTP是一种应用层协议&lt;&#x2F;p&gt;
&lt;p&gt;其次协议约定了双方的_通信规范_ 也就是，&lt;em&gt;客户端和服务端&lt;&#x2F;em&gt; 遵循这套协议 也就称之为 &lt;em&gt;http请求 http响应&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在客户端（如浏览器）和服务器之间，通过交换文本（或二进制）消息来完成资源传输&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP&#x2F;1.x 使用纯文本格式，便于人类阅读和调试&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP2 改为二进制&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;无状态(服务器不会记得之前的请求，每次的请求都是独立的)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;早期 HTTP&#x2F;1.0：每个请求结束后断开 TCP 连接（性能极差）。&lt;&#x2F;p&gt;
&lt;p&gt;HTTP 本身无连接，但实际依赖 TCP 的长连接优化性能。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;请求-响应模型（Request-Response）(主动请求，被动响应)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;服务器无法主动推送数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;如何主动推送呢？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;WebSocket， 轮询（todo）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;httpxiao-xi&quot;&gt;HTTP消息&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;起始行：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;GET &#x2F; index.html HTTP&#x2F;1.1(请求行)&lt;&#x2F;li&gt;
&lt;li&gt;HTTP&#x2F;1.1 200 ok(状态行)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;头部：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;（键值对形式）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Host: example.com&lt;&#x2F;li&gt;
&lt;li&gt;Content-Type: text&#x2F;html&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;正文&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;实际传输的数据&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;所以HTTP向下传递到传输层之前 传输的是文本的二进制？ 那么HTTP2的二进制又是什么意思呢？ 如果按照这样HTTP1.x不也是按照二进制传输的吗&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;无论是 HTTP&#x2F;1.x 还是 HTTP&#x2F;2，最终在网络上传输的都是二进制数据&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;但两者的关键差异在于 协议本身的组织方式，而非是否转为二进制&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;HTTP1.x：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;64d01640-7e8a-400d-baaa-b77086866e61&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;HTTP2：&lt;&#x2F;strong&gt; 以二进制帧（Frame）格式定义协议（所有消息被拆分为二进制结构）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;cf3f3ea3-2076-48de-b4fb-1f2423219b38&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;就是说HTTP1.x 将文本格式转化成ASCII码传输
HTTP2 将文本格式转换成二进制帧！ 更轻量&lt;&#x2F;p&gt;
&lt;h4 id=&quot;an-quan-xing&quot;&gt;安全性&lt;&#x2F;h4&gt;
&lt;p&gt;HTTPS： 在 HTTP 和 TCP 之间加入 TLS&#x2F;SSL 加密层&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;TLS&#x2F;SSL 又是什么？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;content-type-ben-zhi-yu-zuo-yong&quot;&gt;Content-Type：本质与作用&lt;&#x2F;h4&gt;
&lt;p&gt;本质：“这段二进制数据（或文本）应该如何被解析和处理？”&lt;&#x2F;p&gt;
&lt;p&gt;解决数据格式的歧义&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tcpxie-yi&quot;&gt;TCP协议&lt;&#x2F;h2&gt;
&lt;p&gt;位于传输层的 提供 &lt;em&gt;可靠的 面向连接的&lt;&#x2F;em&gt; 数据传输服务&lt;&#x2F;p&gt;
&lt;p&gt;解决如何在_不可靠的IP网络_上实现可靠的数据传输&lt;&#x2F;p&gt;
&lt;p&gt;早期的应用层 直接 对接传输层 导致ip协议无法区分数据应该交付给哪个应用&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duan-kou-hao-de-yin-ru&quot;&gt;端口号的引入&lt;&#x2F;h3&gt;
&lt;p&gt;IP 地址只能定位到主机，无法区分主机上哪个程序&#x2F;服务在通信，如果没有端口号，数据包到达主机后，主机不知道该发给哪个程序 所以在传输层引入了端口号 &lt;em&gt;实现进曾间通信的隔离&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-4&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;怎么理解？&lt;&#x2F;p&gt;
&lt;p&gt;IP 协议处理的是独立的数据包（Packet），而应用层通常需要连续的字节流（如文件传输）&lt;&#x2F;p&gt;
&lt;p&gt;IP 数据包是网络中传输的基本单位&lt;&#x2F;p&gt;
&lt;p&gt;源&#x2F;目的 IP 地址（从哪里来，到哪里去）。&lt;&#x2F;p&gt;
&lt;p&gt;载荷（Payload）：实际要传输的数据片段（如一个文件的一部分）。&lt;&#x2F;p&gt;
&lt;p&gt;头部控制信息（如 TTL、校验和）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;核心冲突：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;IP层的“独立性”和应用层的“连续性”是天然对立的需求：&lt;&#x2F;p&gt;
&lt;p&gt;IP不保证顺序 → 但应用层需要顺序。&lt;&#x2F;p&gt;
&lt;p&gt;IP可能丢包 → 但应用层需要完整。&lt;&#x2F;p&gt;
&lt;p&gt;这种矛盾需要通过传输层（如TCP）解决，而不是让应用层直接处理IP包&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;核心特性：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可靠性：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;流量控制&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;全双工通信&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
      </item>
    </channel>
</rss>
