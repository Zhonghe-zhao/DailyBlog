<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title> - Development</title>
      <link>https://Zhonghe-zhao.github.io/DailyBlog/</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://Zhonghe-zhao.github.io/DailyBlog/tags/development/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 27 Jun 2025 13:41:09 +0000</lastBuildDate>
      <item>
          <title>跨网络通信编程模式</title>
          <pubDate>Fri, 27 Jun 2025 13:41:09 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-33/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-33/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-33/">&lt;h2 id=&quot;restful-api&quot;&gt;RESTFUL API&lt;&#x2F;h2&gt;
&lt;p&gt;虽然HTTP协议已经规范了基础的请求&#x2F;响应格式，但正是因为它太灵活，反而导致了早期Web服务的混乱。&lt;&#x2F;p&gt;
&lt;p&gt;HTTP原生问题：
同一个用户查询功能，不同开发者可能设计出完全不同的接口&lt;&#x2F;p&gt;
&lt;p&gt;所以导致了 RESTFUL API的诞生!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;约定:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;URL 表示资源，如 &#x2F;users&#x2F;1&lt;&#x2F;p&gt;
&lt;p&gt;用标准 HTTP 动词：GET 查，POST 新增，PUT 修改，DELETE 删&lt;&#x2F;p&gt;
&lt;p&gt;数据统一用 JSON（或标准格式）&lt;&#x2F;p&gt;
&lt;p&gt;服务无状态（每次请求都完整表达意图）&lt;&#x2F;p&gt;
&lt;p&gt;规范为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;
HTTP&amp;#x2F;1.1 201 Created
Location: &amp;#x2F;users&amp;#x2F;123
Content-Type: application&amp;#x2F;json

{ &amp;quot;id&amp;quot;: 123, &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot; }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;
&amp;#x2F;&amp;#x2F; 传统混乱的响应
{
  &amp;quot;success&amp;quot;: true,
  &amp;quot;code&amp;quot;: 200,
  &amp;quot;message&amp;quot;: &amp;quot;OK&amp;quot;,
  &amp;quot;data&amp;quot;: { &amp;quot;id&amp;quot;: 123, &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot; }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说:&lt;&#x2F;p&gt;
&lt;p&gt;HTTP 可以发任何东西，RESTful API 让它发得标准、发得规范。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;RESTful API 规范是靠人遵守的工程文化，不是自动生效的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;grpc&quot;&gt;gRPC&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;websocket&quot;&gt;WebSocket&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;xiao-xi-dui-lie&quot;&gt;消息队列&lt;&#x2F;h2&gt;
</description>
      </item>
      <item>
          <title>授权与认证</title>
          <pubDate>Fri, 27 Jun 2025 09:34:29 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-32/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-32/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-32/">&lt;h1 id=&quot;ming-que-gai-nian&quot;&gt;明确概念&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;认证：&lt;&#x2F;strong&gt; 确认你是谁？ 验证你的身份&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;授权：&lt;&#x2F;strong&gt; 确认你能做什么，给_认证的用户_分配权限&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-dan-sheng-cookie-session&quot;&gt;Why 诞生 Cookie Session？&lt;&#x2F;h2&gt;
&lt;p&gt;因为HTTP的无状态性，诞生的问题&lt;&#x2F;p&gt;
&lt;p&gt;“如何在同一用户的多次请求间保持连续状态？”&lt;&#x2F;p&gt;
&lt;p&gt;用户登录后，服务器需要知道后续请求（如购物车操作）来自同一个已认证用户。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;&#x2F;h2&gt;
&lt;p&gt;Cookie 必须通过 HTTP 协议的头字段（Headers）传递&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务器下发 Cookie（响应头）
通过 &lt;em&gt;Set-Cookie&lt;&#x2F;em&gt; 头字段向客户端（如浏览器）写入 Cookie&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;客户端回传 Cookie（请求头）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;有一定安全风险！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;session&quot;&gt;Session&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;解决问题：&lt;&#x2F;strong&gt;  如果直接把用户权限、余额等敏感信息存在客户端（如 Cookie），用户可以轻易篡改&lt;&#x2F;p&gt;
&lt;p&gt;敏感数据存服务端，客户端仅持有无意义的 session_id&lt;&#x2F;p&gt;
&lt;p&gt;在服务器端集中存储用户状态，用户登录时，服务器生成唯一 session_id 并存储相关数据&lt;&#x2F;p&gt;
&lt;p&gt;传递Session_id -&amp;gt; 客户端&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Session的本质：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用户登录 → 浏览网站 → 加购商品 → 退出登录。&lt;&#x2F;p&gt;
&lt;p&gt;这一系列操作属于 同一个会话，数据仅在会话期间需要。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;为什么Session要具备 存储具体数据的能力？&lt;&#x2F;p&gt;
&lt;p&gt;Session 存在于服务端，它的职责是「存储这个人的状态和数据」，比如 user_id、is_login、username 等。&lt;&#x2F;p&gt;
&lt;p&gt;方便服务端快速取用用户数据
Session 已经在内存或持久化存储中存了这些信息，后续请求不需要每次拿 token 去查数据库。&lt;&#x2F;p&gt;
&lt;p&gt;安全性和灵活性
Session 的内容在服务端，客户端完全看不到。这样可以存一些和权限、业务相关的信息（比如角色、登录状态等），防止客户端篡改。&lt;&#x2F;p&gt;
&lt;p&gt;支持更多状态管理
比如除了登录状态，还可以记录购物车、上次访问时间、权限标志等，这些都放在 Session 里方便统一管理。&lt;&#x2F;p&gt;
&lt;p&gt;所以Session：&lt;&#x2F;p&gt;
&lt;p&gt;可以，但那样每次请求都需要拿这个 id 去查数据库或其他存储，浪费性能。&lt;strong&gt;Session 就是为了避免频繁查数据库&lt;&#x2F;strong&gt;，同时把&lt;strong&gt;状态控制在服务端&lt;&#x2F;strong&gt;，提高安全性。&lt;&#x2F;p&gt;
&lt;p&gt;如果想极简方案，也可以只存 user_id，但这会牺牲性能或灵活性。&lt;&#x2F;p&gt;
&lt;p&gt;**减少数据库查询：将高频访问的数据（如权限、购物车）缓存在 Session 中。&lt;&#x2F;p&gt;
&lt;p&gt;实时生效：修改 Session 后立即可见（如用户退出时直接删除 Session）。**&lt;&#x2F;p&gt;
&lt;h2 id=&quot;que-xian&quot;&gt;缺陷&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Cookie 的短板：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;若把所有数据（如 user_role=admin）存在 Cookie 中：&lt;&#x2F;p&gt;
&lt;p&gt;用户可手动修改 role=superadmin 提权（安全隐患）。&lt;&#x2F;p&gt;
&lt;p&gt;数据大小受限（不能存购物车等复杂数据）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;token&quot;&gt;Token&lt;&#x2F;h2&gt;
&lt;p&gt;在客户端存储自包含的加密数据（如 JWT），服务端无需存储会话状态。&lt;&#x2F;p&gt;
&lt;p&gt;如果 Token 是明文（如 user_id=123&amp;amp;role=admin），用户可随意修改（如改 role=superadmin）。&lt;&#x2F;p&gt;
&lt;p&gt;通过签名（如 HMAC、RSA）加密 Token，确保数据不被篡改。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Docker</title>
          <pubDate>Thu, 26 Jun 2025 08:59:00 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-30/">&lt;h1 id=&quot;dockerwei-shen-me-hui-dan-sheng&quot;&gt;Docker为什么会诞生&lt;&#x2F;h1&gt;
&lt;p&gt;为解决传统部署存在的问题！&lt;&#x2F;p&gt;
&lt;p&gt;Docker(容器)：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;确保环境一致性： 将应用打包成镜像， 一次构建到处运行！&lt;&#x2F;li&gt;
&lt;li&gt;**隔离性：**利用Linux内核特性（cgroups&#x2F;namespace）实现进程隔离。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;vs&lt;&#x2F;strong&gt; 虚拟机的隔离方式：&lt;&#x2F;p&gt;
&lt;p&gt;虚拟机：本质跑多个完整的系统，每个虚拟机有自己的 （独立内核 独立文件系统 独立网络 独立资源控制）&lt;&#x2F;p&gt;
&lt;p&gt;Docker： 本质是“在同一个系统中虚拟多个独立空间”，不用虚拟完整 OS，只是隔离进程  共享主机内核&lt;&#x2F;p&gt;
&lt;p&gt;Docker 利用 Namespaces 实现资源“看不见”（不同容器有自己独立的网络、进程表、文件系统），利用 Cgroups 实现资源“用不了太多”（ 限制 CPU 核心数、内存上限，避免资源抢光）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;要做到上述功能 必须需要Docker具有linux的内核，在Windows&#x2F;mac上怎么才能具有linux内核呢？&lt;&#x2F;p&gt;
&lt;p&gt;Windows WSL2（Windows Subsystem for Linux） 轻量级Linux虚拟机（内置Linux内核）
macOS HyperKit（基于Hypervisor.framework） 轻量级Linux虚拟机&lt;&#x2F;p&gt;
&lt;p&gt;用户启动Docker Desktop&lt;&#x2F;p&gt;
&lt;p&gt;自动启动一个隐藏的Linux虚拟机（通过WSL2或Hyper-V）&lt;&#x2F;p&gt;
&lt;p&gt;所有Docker容器实际运行在这个Linux虚拟机内&lt;&#x2F;p&gt;
&lt;p&gt;Docker CLI通过RPC与虚拟机内的Docker引擎通信&lt;&#x2F;p&gt;
&lt;p&gt;事实就是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;Docker容器本质依赖Linux内核的特性（如Namespace&#x2F;Cgroups）。在Windows&#x2F;Mac上，Docker Desktop通过内置的Linux虚拟机（WSL2&#x2F;HyperKit）提供Linux内核支持，容器实际运行在这个虚拟机内，而非直接调用Windows内核。&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;wei-shen-me-docker-yao-yun-xing-zai-linux-shang&quot;&gt;为什么Docker 要运行在 Linux 上？&lt;&#x2F;h2&gt;
&lt;p&gt;容器化技术依赖Linux内核的三大机制：&lt;&#x2F;p&gt;
&lt;p&gt;Namespaces（命名空间） → 提供进程隔离（PID、网络、挂载点等）&lt;&#x2F;p&gt;
&lt;p&gt;Cgroups（控制组） → 限制资源（CPU、内存、IO）&lt;&#x2F;p&gt;
&lt;p&gt;UnionFS（联合文件系统） → 实现镜像分层存储&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wsl2-vs-vm&quot;&gt;WSL2 VS VM&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;WSL2 共享Windows内核的部分功能（如调度器），而传统VM需模拟完整硬件并运行独立OS。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;wen-ti-1&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;“内核”到底是什么？它的角色和操作系统是一致的？&lt;&#x2F;p&gt;
&lt;p&gt;内核四大职责：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;进程管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;创建&#x2F;销毁进程（fork()、exit()）&lt;&#x2F;p&gt;
&lt;p&gt;CPU调度（决定哪个进程运行）
示例：Docker容器本质是内核通过clone()+Namespace创建的隔离进程&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内存管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;分配物理内存（malloc()底层依赖内核）&lt;&#x2F;p&gt;
&lt;p&gt;虚拟内存（分页&#x2F;交换空间）&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;设备驱动&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;文件系统&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;联合文件系统&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;向上：通过系统调用（syscall） 为软件提供服务
向下：直接操作CPU&#x2F;内存&#x2F;设备寄存器&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerbu-shu-de-liu-cheng&quot;&gt;Docker部署的流程&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;编写 Dockerfile&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;定义基础镜像（如 golang:1.20 或更小的 scratch）&lt;&#x2F;p&gt;
&lt;p&gt;拷贝你的代码和依赖&lt;&#x2F;p&gt;
&lt;p&gt;编译生成可执行文件（或直接用编译好的二进制）&lt;&#x2F;p&gt;
&lt;p&gt;设置容器启动命令（比如运行 simplebank 服务）&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构建镜像&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;执行 docker build -t simplebank:latest .&lt;&#x2F;p&gt;
&lt;p&gt;生成一个包含你的程序和运行环境的镜像文件&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;推送镜像（可选）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;把镜像上传到远程仓库，如 Docker Hub 或私有 Harbor&lt;&#x2F;p&gt;
&lt;p&gt;方便其他服务器拉取&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;运行容器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;访问服务
通过服务器的 IP 和端口访问你的 SimpleBank API&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;维护和更新&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;更新代码后，重复构建镜像和部署容器流程&lt;&#x2F;p&gt;
&lt;p&gt;可以通过 Docker Compose 或 Kubernetes 做多容器编排和扩展&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jing-xiang-guan-li&quot;&gt;镜像管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;rong-qi-cao-zuo&quot;&gt;容器操作&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;wang-luo-guan-li&quot;&gt;网络管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;shu-ju-chi-jiu-hua&quot;&gt;数据持久化&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;&#x2F;h2&gt;
&lt;p&gt;构建镜像： 基础环境 依赖安装 文件复制 启动命令&lt;&#x2F;p&gt;
&lt;p&gt;实际的执行流程：&lt;&#x2F;p&gt;
&lt;p&gt;镜像（Image） → 启动后变成 → 容器（Container）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shelljiao-ben&quot;&gt;Shell脚本&lt;&#x2F;h2&gt;
&lt;p&gt;用途： 自动化任务、批量处理、服务管理、部署流程等。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;#!&amp;#x2F;bin&amp;#x2F;sh

set -e

echo &amp;quot;run db migrations&amp;quot;
&amp;#x2F;app&amp;#x2F;migrate -path &amp;#x2F;app&amp;#x2F;migration -database &amp;quot;$DB_SOURCE&amp;quot; -verbose up

echo &amp;quot;start the app&amp;quot;
exec &amp;quot;$@&amp;quot;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;Dockerfiles&quot; class=&quot;language-Dockerfiles &quot;&gt;&lt;code class=&quot;language-Dockerfiles&quot; data-lang=&quot;Dockerfiles&quot;&gt;
EXPOSE 8080 
CMD [ &amp;quot;&amp;#x2F;app&amp;#x2F;main&amp;quot; ]
ENTRYPOINT [ &amp;quot;&amp;#x2F;app&amp;#x2F;start.sh&amp;quot; ]

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;CMD&lt;&#x2F;em&gt;  定义默认参数，会被 &lt;em&gt;ENTRYPOINT&lt;&#x2F;em&gt; 使用，也可被 docker run 的参数覆盖&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;完成_Dockerfiles_文件的编写，构建镜像！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker build -t your-service:1.0 .&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker run -it --rm your-service:1.0 sh&lt;&#x2F;code&gt; 运行！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;docker-compose-yaml&quot;&gt;Docker-compose.yaml&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过一个 YAML 文件定义和编排多容器应用，实现一键启动完整服务栈。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;shen-me-shi-duo-rong-qi-bian-pai&quot;&gt;什么是多容器编排&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;多个容器协同运行，组成一个完整系统，并通过自动化工具统一管理和部署的过程，就叫多容器编排。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;多个容器之间需要保证什么？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动顺序正确&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;网络互通&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;环境一致&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;自动恢复&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;动态扩容&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-li&quot;&gt;实例：&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt;
services:
  postgres:
    image: postgres:12-alpine
    environment:
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=simple_bank
    ports:
      - &amp;quot;5433:5432&amp;quot;
    volumes:
      - data-volume:&amp;#x2F;var&amp;#x2F;lib&amp;#x2F;postgresql&amp;#x2F;data

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动了一个数据库容器 并且配置了一系列环境&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    depends_on:
      - postgres
      - redis
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动顺序&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lian-jie-dockerfiles-he-docker-compose&quot;&gt;连接Dockerfiles 和 docker-compose&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt; api:
  build:
    context: .
    dockerfile: Dockerfile
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;wen-ti-2&quot;&gt;问题&lt;&#x2F;h3&gt;
&lt;p&gt;编写完Dockerfiles文件后 也就是构建完成镜像之后就可以启动镜像为容器了，也就是项目可以正常启动了，为什么还需要docker-compose文件编排多个容器呢？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker-compose up -d  # 一键启动所有服务，自动处理依赖&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerzhong-de-wang-luo-wen-ti&quot;&gt;docker中的网络问题&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;网络模式：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;bridge&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;每个 Bridge 网络形成一个独立的虚拟局域网（VLAN）&lt;&#x2F;p&gt;
&lt;p&gt;同一网络内的容器可通过容器名互相访问（无需IP）&lt;&#x2F;p&gt;
&lt;p&gt;容器访问外网时，IP会被转换为宿主机IP（通过iptables规则）&lt;&#x2F;p&gt;
&lt;p&gt;需手动映射端口（-p 8080:80）才能从宿主机外部访问容器服务&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duan-kou-ying-she&quot;&gt;端口映射&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 将容器内部端口绑定到宿主机端口的机制&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;c1b8951b-0444-4cb4-8341-fad1707d9947&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;# 将容器的80端口映射到宿主机的8080端口 docker run -d -p 8080:80 --name nginx nginx &lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;网卡的作用：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;主机和外部网络的桥梁，完成数据收发和初步封装&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Docker 会创建虚拟网卡（veth pair）：&lt;&#x2F;p&gt;
&lt;p&gt;一端在容器内，另一端接到宿主机的网桥（docker0）。&lt;&#x2F;p&gt;
&lt;p&gt;通过虚拟网卡，容器流量被送到宿主机网络，再被转发出去（如 NAT）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nat&quot;&gt;NAT&lt;&#x2F;h4&gt;
&lt;p&gt;把私有网络的 IP 地址转换成公有网络的 IP 地址，实现内网访问外网或不同网段通信。 主要解决 IP 不够用 + 内网隔离 + 控制流量 的问题。&lt;&#x2F;p&gt;
&lt;p&gt;Docker 默认用 NAT：
容器内的私有 IP（如 172.17.x.x）通过 NAT 转换成宿主机的 IP 对外通信。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tong-xin&quot;&gt;通信&lt;&#x2F;h2&gt;
&lt;p&gt;同网络下的容器可以通信，在自定义的网络中 他们可以通过容器名自动互相访问&lt;&#x2F;p&gt;
&lt;p&gt;创建网络 并加入pg容器&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network connect bank-network postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;检查容器内部配置&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network inspect bank-newtork&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker container inspect postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>工具链</title>
          <pubDate>Fri, 20 Jun 2025 12:28:01 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-24/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-24/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-24/">&lt;h1 id=&quot;shen-me-shi-gong-ju-lian&quot;&gt;什么是工具链&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;从源码出发，支持你完成开发、构建、测试、调试、部署的完整过程&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;**编译构建：**把源码变成可运行的程序（如 cargo build、go build）&lt;&#x2F;p&gt;
&lt;p&gt;**依赖管理：**统一管理三方库版本、下载、更新（如 go mod、Cargo.toml）&lt;&#x2F;p&gt;
&lt;p&gt;**代码质量保证：**自动化测试、格式化、静态检查（如 cargo test、clippy）&lt;&#x2F;p&gt;
&lt;p&gt;**调试和发布支持：**调试运行、打包部署、发布（如 cargo run --release）&lt;&#x2F;p&gt;
&lt;p&gt;##理解指令&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;go build&lt;&#x2F;em&gt; &lt;em&gt;go mod init&lt;&#x2F;em&gt; &lt;em&gt;cargo build&lt;&#x2F;em&gt; 等指令做了什么事情？&lt;&#x2F;p&gt;
&lt;p&gt;_go.mod_是做什么的，如果没有会怎么样？&lt;&#x2F;p&gt;
&lt;p&gt;go.mod 记录了模块名和依赖项&lt;&#x2F;p&gt;
&lt;p&gt;go build
编译当前模块的代码，生成可执行文件。&lt;&#x2F;p&gt;
&lt;p&gt;如果没有 go.mod：&lt;&#x2F;p&gt;
&lt;p&gt;无法使用模块化依赖（Go 1.11+推荐模块模式）&lt;&#x2F;p&gt;
&lt;p&gt;Go 会尝试用 GOPATH 模式构建（已逐渐废弃）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mo-kuai-hua-yi-lai&quot;&gt;模块化依赖&lt;&#x2F;h2&gt;
&lt;p&gt;每个模块只关心自己需要的依赖和版本，互不干扰。&lt;&#x2F;p&gt;
&lt;p&gt;例子：
项目 A 用的是 viper v1.9.0，项目 B 用的是 viper v1.8.1，互不冲突。
不像老的 GOPATH 模式下，全局只有一份依赖，项目之间可能“踩版本”。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Go By Mistakes</title>
          <pubDate>Fri, 30 May 2025 08:19:16 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-11/">&lt;h1 id=&quot;inithan-shu-de-shi-yong&quot;&gt;init函数的使用&lt;&#x2F;h1&gt;
&lt;p&gt;在&lt;code&gt;init()&lt;&#x2F;code&gt;函数中，不能返回错误，因为init函数的作用是 完成初始化 或者直接使用&lt;code&gt;panic()&lt;&#x2F;code&gt;终止程序 ！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-shi&quot;&gt;测试&lt;&#x2F;h2&gt;
&lt;p&gt;在测试之前&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Go总会加载相关包&lt;&#x2F;li&gt;
&lt;li&gt;自动调用包中的所有&lt;code&gt;init()&lt;&#x2F;code&gt;函数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;执行顺序&lt;&#x2F;strong&gt;： 测试加载顺序：包级变量初始化 → init() 执行 → TestMain()（如果存在）→ TestXxx() 执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-yi&quot;&gt;&lt;strong&gt;注意：&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;init() 是全局性的，一旦定义就会在所有测试前执行
所以如果你在某个文件中写了一个 init()，它无法按需控制是否执行，这会给某些不需要它的测试带来副作用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;p&gt;如果你在一个文件中定义了&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; utils.go
func HashPassword(pw string) string {
    &amp;#x2F;&amp;#x2F; 哈希逻辑
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func init() {
    &amp;#x2F;&amp;#x2F; 建立数据库连接
    db, _ = sql.Open(&amp;quot;postgres&amp;quot;, &amp;quot;...&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你只想测试 HashPassword()，跟数据库没关系，但：&lt;&#x2F;p&gt;
&lt;p&gt;Go 会强制执行 init() → 建立数据库连接&lt;&#x2F;p&gt;
&lt;p&gt;如果数据库挂了、网络断了，测试失败&lt;&#x2F;p&gt;
&lt;p&gt;即使测试内容跟数据库一毛钱关系都没有&lt;&#x2F;p&gt;
&lt;p&gt;init() 是文件级别、不可控制的初始化逻辑，一旦存在，它就会对这个包的所有使用者和测试者产生影响。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;做法：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;尽量避免在 init() 中建立全局连接或启动重逻辑 不要用 init() 连数据库&lt;&#x2F;p&gt;
&lt;p&gt;把数据库连接从 init() 拆出去，改成显式初始化函数，这样测试更灵活、代码更可控、依赖更清晰&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;var DB *sql.DB

func InitDB(dsn string) error {
	var err error
	DB, err = sql.Open(&amp;quot;postgres&amp;quot;, dsn)
	return err
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;quan-ju-bian-liang&quot;&gt;全局变量&lt;&#x2F;h2&gt;
&lt;p&gt;如果把数据库连接对象赋值给全局变量（如 var db *sql.DB），为什么这会让单元测试变复杂、变得“不隔离”？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li-1&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
package user

import &amp;quot;yourproject&amp;#x2F;db&amp;quot;

func GetUserByID(id int) (*User, error) {
	return db.DB.Query(...) &amp;#x2F;&amp;#x2F; 用的是全局变量 db.DB
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;它依赖的是全局变量 db.DB，你没法注入 mock 数据库(全局变量在代码里写死了，函数内部直接引用它，测试时你没法“替换”这个变量指向别的对象)，也无法用内存数据库替代。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-jue&quot;&gt;解决：&lt;&#x2F;h3&gt;
&lt;p&gt;将 DB 作为参数而不是全局变量&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
type UserRepo struct {
	DB *sql.DB
}

func (r *UserRepo) GetUserByID(id int) (*User, error) {
	return r.DB.Query(...)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;main.go&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;db, _ := sql.Open(...)
repo := user.UserRepo{DB: db}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;测试中&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;fakeDB := NewFakeDB() &amp;#x2F;&amp;#x2F; 或用 sqlite、mock
repo := user.UserRepo{DB: fakeDB}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; db_test.go
package db

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;
)

func Test_Global_DB(t *testing.T) {
	DB = &amp;quot;RealDB&amp;quot;
	got := GetUserGlobal(1)
	fmt.Println(got)

	DB = &amp;quot;MockDB&amp;quot; &amp;#x2F;&amp;#x2F; ← 修改全局变量

	got2 := GetUserGlobal(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 问题：前后结果不一致，测试间共享状态
}

func Test_DI_DB(t *testing.T) {
	real := &amp;amp;DBClient{DB: &amp;quot;RealDB&amp;quot;}
	mock := &amp;amp;DBClient{DB: &amp;quot;MockDB&amp;quot;}

	got := real.GetUserDI(1)
	fmt.Println(got)

	got2 := mock.GetUserDI(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 优点：各自隔离，不会互相影响
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
