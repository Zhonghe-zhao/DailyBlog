<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title> - Go</title>
      <link>https://Zhonghe-zhao.github.io/DailyBlog/</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://Zhonghe-zhao.github.io/DailyBlog/tags/go/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Thu, 26 Jun 2025 08:59:00 +0000</lastBuildDate>
      <item>
          <title>Docker</title>
          <pubDate>Thu, 26 Jun 2025 08:59:00 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-30/">&lt;h1 id=&quot;dockerwei-shen-me-hui-dan-sheng&quot;&gt;Docker为什么会诞生&lt;&#x2F;h1&gt;
&lt;p&gt;为解决传统部署存在的问题！&lt;&#x2F;p&gt;
&lt;p&gt;Docker(容器)：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;确保环境一致性： 将应用打包成镜像， 一次构建到处运行！&lt;&#x2F;li&gt;
&lt;li&gt;**隔离性：**利用Linux内核特性（cgroups&#x2F;namespace）实现进程隔离。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;vs&lt;&#x2F;strong&gt; 虚拟机的隔离方式：&lt;&#x2F;p&gt;
&lt;p&gt;虚拟机：本质跑多个完整的系统，每个虚拟机有自己的 （独立内核 独立文件系统 独立网络 独立资源控制）&lt;&#x2F;p&gt;
&lt;p&gt;Docker： 本质是“在同一个系统中虚拟多个独立空间”，不用虚拟完整 OS，只是隔离进程  共享主机内核&lt;&#x2F;p&gt;
&lt;p&gt;Docker 利用 Namespaces 实现资源“看不见”（不同容器有自己独立的网络、进程表、文件系统），利用 Cgroups 实现资源“用不了太多”（ 限制 CPU 核心数、内存上限，避免资源抢光）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;要做到上述功能 必须需要Docker具有linux的内核，在Windows&#x2F;mac上怎么才能具有linux内核呢？&lt;&#x2F;p&gt;
&lt;p&gt;Windows WSL2（Windows Subsystem for Linux） 轻量级Linux虚拟机（内置Linux内核）
macOS HyperKit（基于Hypervisor.framework） 轻量级Linux虚拟机&lt;&#x2F;p&gt;
&lt;p&gt;用户启动Docker Desktop&lt;&#x2F;p&gt;
&lt;p&gt;自动启动一个隐藏的Linux虚拟机（通过WSL2或Hyper-V）&lt;&#x2F;p&gt;
&lt;p&gt;所有Docker容器实际运行在这个Linux虚拟机内&lt;&#x2F;p&gt;
&lt;p&gt;Docker CLI通过RPC与虚拟机内的Docker引擎通信&lt;&#x2F;p&gt;
&lt;p&gt;事实就是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;Docker容器本质依赖Linux内核的特性（如Namespace&#x2F;Cgroups）。在Windows&#x2F;Mac上，Docker Desktop通过内置的Linux虚拟机（WSL2&#x2F;HyperKit）提供Linux内核支持，容器实际运行在这个虚拟机内，而非直接调用Windows内核。&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;wei-shen-me-docker-yao-yun-xing-zai-linux-shang&quot;&gt;为什么Docker 要运行在 Linux 上？&lt;&#x2F;h2&gt;
&lt;p&gt;容器化技术依赖Linux内核的三大机制：&lt;&#x2F;p&gt;
&lt;p&gt;Namespaces（命名空间） → 提供进程隔离（PID、网络、挂载点等）&lt;&#x2F;p&gt;
&lt;p&gt;Cgroups（控制组） → 限制资源（CPU、内存、IO）&lt;&#x2F;p&gt;
&lt;p&gt;UnionFS（联合文件系统） → 实现镜像分层存储&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wsl2-vs-vm&quot;&gt;WSL2 VS VM&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;WSL2 共享Windows内核的部分功能（如调度器），而传统VM需模拟完整硬件并运行独立OS。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;wen-ti-1&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;“内核”到底是什么？它的角色和操作系统是一致的？&lt;&#x2F;p&gt;
&lt;p&gt;内核四大职责：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;进程管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;创建&#x2F;销毁进程（fork()、exit()）&lt;&#x2F;p&gt;
&lt;p&gt;CPU调度（决定哪个进程运行）
示例：Docker容器本质是内核通过clone()+Namespace创建的隔离进程&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内存管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;分配物理内存（malloc()底层依赖内核）&lt;&#x2F;p&gt;
&lt;p&gt;虚拟内存（分页&#x2F;交换空间）&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;设备驱动&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;文件系统&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;联合文件系统&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;向上：通过系统调用（syscall） 为软件提供服务
向下：直接操作CPU&#x2F;内存&#x2F;设备寄存器&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerbu-shu-de-liu-cheng&quot;&gt;Docker部署的流程&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;编写 Dockerfile&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;定义基础镜像（如 golang:1.20 或更小的 scratch）&lt;&#x2F;p&gt;
&lt;p&gt;拷贝你的代码和依赖&lt;&#x2F;p&gt;
&lt;p&gt;编译生成可执行文件（或直接用编译好的二进制）&lt;&#x2F;p&gt;
&lt;p&gt;设置容器启动命令（比如运行 simplebank 服务）&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构建镜像&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;执行 docker build -t simplebank:latest .&lt;&#x2F;p&gt;
&lt;p&gt;生成一个包含你的程序和运行环境的镜像文件&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;推送镜像（可选）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;把镜像上传到远程仓库，如 Docker Hub 或私有 Harbor&lt;&#x2F;p&gt;
&lt;p&gt;方便其他服务器拉取&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;运行容器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;访问服务
通过服务器的 IP 和端口访问你的 SimpleBank API&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;维护和更新&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;更新代码后，重复构建镜像和部署容器流程&lt;&#x2F;p&gt;
&lt;p&gt;可以通过 Docker Compose 或 Kubernetes 做多容器编排和扩展&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jing-xiang-guan-li&quot;&gt;镜像管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;rong-qi-cao-zuo&quot;&gt;容器操作&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;wang-luo-guan-li&quot;&gt;网络管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;shu-ju-chi-jiu-hua&quot;&gt;数据持久化&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;&#x2F;h2&gt;
&lt;p&gt;构建镜像： 基础环境 依赖安装 文件复制 启动命令&lt;&#x2F;p&gt;
&lt;p&gt;实际的执行流程：&lt;&#x2F;p&gt;
&lt;p&gt;镜像（Image） → 启动后变成 → 容器（Container）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shelljiao-ben&quot;&gt;Shell脚本&lt;&#x2F;h2&gt;
&lt;p&gt;用途： 自动化任务、批量处理、服务管理、部署流程等。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;#!&amp;#x2F;bin&amp;#x2F;sh

set -e

echo &amp;quot;run db migrations&amp;quot;
&amp;#x2F;app&amp;#x2F;migrate -path &amp;#x2F;app&amp;#x2F;migration -database &amp;quot;$DB_SOURCE&amp;quot; -verbose up

echo &amp;quot;start the app&amp;quot;
exec &amp;quot;$@&amp;quot;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;Dockerfiles&quot; class=&quot;language-Dockerfiles &quot;&gt;&lt;code class=&quot;language-Dockerfiles&quot; data-lang=&quot;Dockerfiles&quot;&gt;
EXPOSE 8080 
CMD [ &amp;quot;&amp;#x2F;app&amp;#x2F;main&amp;quot; ]
ENTRYPOINT [ &amp;quot;&amp;#x2F;app&amp;#x2F;start.sh&amp;quot; ]

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;CMD&lt;&#x2F;em&gt;  定义默认参数，会被 &lt;em&gt;ENTRYPOINT&lt;&#x2F;em&gt; 使用，也可被 docker run 的参数覆盖&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;完成_Dockerfiles_文件的编写，构建镜像！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker build -t your-service:1.0 .&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker run -it --rm your-service:1.0 sh&lt;&#x2F;code&gt; 运行！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;docker-compose-yaml&quot;&gt;Docker-compose.yaml&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过一个 YAML 文件定义和编排多容器应用，实现一键启动完整服务栈。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;shen-me-shi-duo-rong-qi-bian-pai&quot;&gt;什么是多容器编排&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;多个容器协同运行，组成一个完整系统，并通过自动化工具统一管理和部署的过程，就叫多容器编排。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;多个容器之间需要保证什么？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动顺序正确&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;网络互通&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;环境一致&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;自动恢复&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;动态扩容&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-li&quot;&gt;实例：&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt;
services:
  postgres:
    image: postgres:12-alpine
    environment:
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=simple_bank
    ports:
      - &amp;quot;5433:5432&amp;quot;
    volumes:
      - data-volume:&amp;#x2F;var&amp;#x2F;lib&amp;#x2F;postgresql&amp;#x2F;data

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动了一个数据库容器 并且配置了一系列环境&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    depends_on:
      - postgres
      - redis
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动顺序&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lian-jie-dockerfiles-he-docker-compose&quot;&gt;连接Dockerfiles 和 docker-compose&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt; api:
  build:
    context: .
    dockerfile: Dockerfile
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;wen-ti-2&quot;&gt;问题&lt;&#x2F;h3&gt;
&lt;p&gt;编写完Dockerfiles文件后 也就是构建完成镜像之后就可以启动镜像为容器了，也就是项目可以正常启动了，为什么还需要docker-compose文件编排多个容器呢？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker-compose up -d  # 一键启动所有服务，自动处理依赖&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerzhong-de-wang-luo-wen-ti&quot;&gt;docker中的网络问题&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;网络模式：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;bridge&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;每个 Bridge 网络形成一个独立的虚拟局域网（VLAN）&lt;&#x2F;p&gt;
&lt;p&gt;同一网络内的容器可通过容器名互相访问（无需IP）&lt;&#x2F;p&gt;
&lt;p&gt;容器访问外网时，IP会被转换为宿主机IP（通过iptables规则）&lt;&#x2F;p&gt;
&lt;p&gt;需手动映射端口（-p 8080:80）才能从宿主机外部访问容器服务&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duan-kou-ying-she&quot;&gt;端口映射&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 将容器内部端口绑定到宿主机端口的机制&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;c1b8951b-0444-4cb4-8341-fad1707d9947&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;# 将容器的80端口映射到宿主机的8080端口 docker run -d -p 8080:80 --name nginx nginx &lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;网卡的作用：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;主机和外部网络的桥梁，完成数据收发和初步封装&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Docker 会创建虚拟网卡（veth pair）：&lt;&#x2F;p&gt;
&lt;p&gt;一端在容器内，另一端接到宿主机的网桥（docker0）。&lt;&#x2F;p&gt;
&lt;p&gt;通过虚拟网卡，容器流量被送到宿主机网络，再被转发出去（如 NAT）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nat&quot;&gt;NAT&lt;&#x2F;h4&gt;
&lt;p&gt;把私有网络的 IP 地址转换成公有网络的 IP 地址，实现内网访问外网或不同网段通信。 主要解决 IP 不够用 + 内网隔离 + 控制流量 的问题。&lt;&#x2F;p&gt;
&lt;p&gt;Docker 默认用 NAT：
容器内的私有 IP（如 172.17.x.x）通过 NAT 转换成宿主机的 IP 对外通信。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tong-xin&quot;&gt;通信&lt;&#x2F;h2&gt;
&lt;p&gt;同网络下的容器可以通信，在自定义的网络中 他们可以通过容器名自动互相访问&lt;&#x2F;p&gt;
&lt;p&gt;创建网络 并加入pg容器&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network connect bank-network postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;检查容器内部配置&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network inspect bank-newtork&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker container inspect postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>go-redis使用</title>
          <pubDate>Sun, 15 Jun 2025 12:57:28 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-22/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-22/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-22/">&lt;h1 id=&quot;redis&quot;&gt;Redis&lt;&#x2F;h1&gt;
&lt;p&gt;高性能内存数据库：&lt;&#x2F;p&gt;
&lt;p&gt;为解决传统数据库在高并发和低延迟场景下的性能瓶颈&lt;&#x2F;p&gt;
&lt;p&gt;传统数据库 I&#x2F;O 慢，不适合做高频缓存&lt;&#x2F;p&gt;
&lt;p&gt;Memcached 只支持简单的 key-value，不能表达复杂业务&lt;&#x2F;p&gt;
&lt;p&gt;项目中很多需求本质上是“操作数据结构”：列表、集合、计数器等&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-yao-cao-zuo-shu-ju-jie-gou&quot;&gt;为什么要操作数据结构？&lt;&#x2F;h2&gt;
&lt;p&gt;展示出最近的10条评论&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;SELECT * FROM comments WHERE post_id = ? ORDER BY created_at DESC LIMIT 10 OFFSET x&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;redisnei-zhi-shu-ju-jie-gou&quot;&gt;Redis内置数据结构：&lt;&#x2F;h2&gt;
&lt;p&gt;（String、Hash、List、Set、Sorted Set 等）&lt;&#x2F;p&gt;
&lt;p&gt;根据情况 &lt;strong&gt;选择合适的数据结构&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;字符串&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;缓存用户姓名：SET user:1:name &quot;Alice&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;页面访问计数：INCR page:views.&lt;&#x2F;p&gt;
&lt;p&gt;数据量小，操作简单（读写、增减）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Hash（哈希）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;存储用户信息：HSET user:1 name &quot;Alice&quot; age 25.&lt;&#x2F;p&gt;
&lt;p&gt;更新年龄：HSET user:1 age 26.&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;List（列表）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;任务队列：LPUSH tasks &quot;send_email&quot;，RPOP tasks.&lt;&#x2F;p&gt;
&lt;p&gt;最近浏览记录：LPUSH user:1:history &quot;item1&quot;, LTRIM user:1:history 0 9（保留最近 10 条）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Set（集合）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;用户标签：SADD user:1:tags &quot;tech&quot; &quot;sports&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;共同好友：SINTER user:1:friends user:2:friends.&lt;&#x2F;p&gt;
&lt;p&gt;用 Set 实现推荐系统（比如推荐共同兴趣的用户）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Sorted Set（有序集合）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;游戏排行榜：ZADD leaderboard 100 &quot;Alice&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;获取前 3 名：ZREVRANGE leaderboard 0 2.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h2&gt;
&lt;p&gt;“如何用 Redis 做缓存？”（String&#x2F;Hash）&lt;&#x2F;p&gt;
&lt;p&gt;“如何实现消息队列？”（List）&lt;&#x2F;p&gt;
&lt;p&gt;“如何设计排行榜？”（Sorted Set）&lt;&#x2F;p&gt;
&lt;p&gt;为什么选这个数据结构？ 它的优点！&lt;&#x2F;p&gt;
&lt;p&gt;##问题&lt;&#x2F;p&gt;
&lt;p&gt;为什么redis可以操作列表等数据结构呢？ 它的底层就是一个哈希表吗？&lt;&#x2F;p&gt;
&lt;p&gt;Redis 的全局键值存储是基于哈希表（Dict）&lt;&#x2F;p&gt;
&lt;p&gt;全局哈希表只存储「键」和「值的指针」&lt;&#x2F;p&gt;
&lt;p&gt;对于Redis 不同数据类型有不同的底层实现&lt;&#x2F;p&gt;
&lt;p&gt;实际上：&lt;&#x2F;p&gt;
&lt;p&gt;以 &lt;em&gt;LPUSH mylist A&lt;&#x2F;em&gt; 为例：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查找 Key：先在全局哈希表中查找 &quot;mylist&quot;：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果不存在，创建一个新的 List（底层可能是 QuickList）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果存在，拿到指向 List 的指针。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;操作数据结构：调用 QuickList 的插入逻辑，在头部插入 &quot;A&quot;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
      </item>
      <item>
          <title>Golang In Deep</title>
          <pubDate>Wed, 11 Jun 2025 12:49:51 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-19/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-19/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-19/">&lt;h1 id=&quot;gmpmo-xing&quot;&gt;GMP模型&lt;&#x2F;h1&gt;
&lt;p&gt;首先思考 GMP调度模型是什么？ 为了解决什么问题？&lt;&#x2F;p&gt;
&lt;p&gt;引出下文：&lt;&#x2F;p&gt;
&lt;p&gt;GMP是 Go runtime的一个调度模型， 调度模型是什么？ Go runtime是什么？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Go runtime：&lt;&#x2F;strong&gt; Go runtime 是 Go 语言自带的一套 运行时系统。&lt;&#x2F;p&gt;
&lt;p&gt;他自己有一套功能：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;GMP调度器&lt;&#x2F;li&gt;
&lt;li&gt;垃圾回收GC&lt;&#x2F;li&gt;
&lt;li&gt;系统调用封装 等&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;因为GO需要自己管理这些情况 所以需要内置 runtime&lt;&#x2F;p&gt;
&lt;p&gt;**调度模型： **系统如何决定“哪个任务（线程、协程）由哪个 CPU 在什么时候执行”的策略和机制。&lt;&#x2F;p&gt;
&lt;p&gt;Go 调度器运行在用户态，负责调度 goroutine 到 Go 自己维护的 M（线程） 上。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-goroutineqie-huan-bi-xian-cheng-qing-liang&quot;&gt;为什么goroutine切换比线程轻量？&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;线程就是操作系统里执行代码的最小单位。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;首先清楚： &lt;em&gt;上下文越大，切换开销越大（保存&#x2F;恢复更多信息）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xian-cheng-shi-bing-fa-bian-cheng-de-ji-chu&quot;&gt;线程是并发编程的基础&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;线程内代码按顺序执行。多个线程通过 CPU 多核或调度实现任务并行或并发，提高效率。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;回到最初！因为os线程的并发下 开销大！ 所以Go设计了用户级goruntine 目前的问题就是 如何&lt;strong&gt;把成千上万的goroutine 高效的调度到有限的os上&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用户级别的协程确实在开销上非常小 目前的问题就是 如何将协程和线程连接起来 从而让真正的CPU去工作&lt;&#x2F;p&gt;
&lt;p&gt;Goroutine的执行条件是什么？&lt;&#x2F;p&gt;
&lt;p&gt;CPU状态 任务队列 本地缓存 调度信息&lt;&#x2F;p&gt;
&lt;p&gt;这些环境谁来提供？&lt;&#x2F;p&gt;
&lt;p&gt;p！&lt;&#x2F;p&gt;
&lt;p&gt;p 管理能运行多少个G 协调 本地队列 与 全局队列&lt;&#x2F;p&gt;
&lt;p&gt;谁来维护p？&lt;&#x2F;p&gt;
&lt;p&gt;CPU核数 限制了 p的数量&lt;&#x2F;p&gt;
&lt;p&gt;M 是操作系统的线程，是实际能被 CPU 调度执行的实体 M必须绑定p 才能执行G&lt;&#x2F;p&gt;
&lt;p&gt;P调度G M执行G&lt;&#x2F;p&gt;
&lt;p&gt;为什么 只有绑定P才能执行G 早期没有P是如何运行的？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mru-he-zhi-jie-diao-du-g&quot;&gt;M如何直接调度G&lt;&#x2F;h2&gt;
&lt;p&gt;有哪些缺点?&lt;&#x2F;p&gt;
&lt;p&gt;M 同时负责调度和执行，导致调度逻辑复杂且不够高效。 容易出现资源竞争和瓶颈。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fa-sheng-zu-sai-zen-me-ban&quot;&gt;发生阻塞怎么办&lt;&#x2F;h2&gt;
&lt;p&gt;什么会发生阻塞？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I&#x2F;O阻塞：&lt;&#x2F;strong&gt; 程序必须完成某个程序的输入输出 才能执行后续的代码&lt;&#x2F;p&gt;
&lt;p&gt;M属于内核级别 M发生系统调用 M会被操作系统挂起，进入阻塞状态&lt;&#x2F;p&gt;
&lt;p&gt;Go检测到阻塞就会就会让M释放P 创建或唤醒另一个M去绑定这个P然后执行G，被挂起的 M 等调用完成后再尝试回收利用。&lt;&#x2F;p&gt;
&lt;p&gt;Go的runtime做法， 发现这个G是阻塞的 就从当前M中剥离这个G 然后G标记waiting 把p解绑 交给别的M&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xi-tong-diao-yong-wei-shen-me-hui-zu-sai&quot;&gt;系统调用为什么会阻塞&lt;&#x2F;h3&gt;
&lt;p&gt;运行在用户态 去请求 系统内核的某些权限!(文件读写， 网络通信，进程管理)&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取磁盘文件可能需要等待磁盘控制器返回数据&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;网络 I&#x2F;O：接收网络数据（如 net.Conn.Read）需要等待客户端发送数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;进程同步：如 waitpid 等待子进程退出。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;yi-huo&quot;&gt;疑惑：&lt;&#x2F;h3&gt;
&lt;p&gt;所以说 系统调用 为什么会阻塞？ 如果当系统调用需要从磁盘读取数据的时候 线程去执行其它资源，然后等数据返回再去执行，这样不就大大提高了利用率吗？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hui-da&quot;&gt;回答:&lt;&#x2F;h3&gt;
&lt;p&gt;这个问题就是&lt;strong&gt;同步阻塞I&#x2F;O模型&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;让线程去做别的事情就是 &lt;strong&gt;异步非阻塞模型:&lt;&#x2F;strong&gt; 这样一个线程可以管理成千上万个 I&#x2F;O 连接，提高吞吐量。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Go By Mistakes</title>
          <pubDate>Fri, 30 May 2025 08:19:16 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-11/">&lt;h1 id=&quot;inithan-shu-de-shi-yong&quot;&gt;init函数的使用&lt;&#x2F;h1&gt;
&lt;p&gt;在&lt;code&gt;init()&lt;&#x2F;code&gt;函数中，不能返回错误，因为init函数的作用是 完成初始化 或者直接使用&lt;code&gt;panic()&lt;&#x2F;code&gt;终止程序 ！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-shi&quot;&gt;测试&lt;&#x2F;h2&gt;
&lt;p&gt;在测试之前&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Go总会加载相关包&lt;&#x2F;li&gt;
&lt;li&gt;自动调用包中的所有&lt;code&gt;init()&lt;&#x2F;code&gt;函数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;执行顺序&lt;&#x2F;strong&gt;： 测试加载顺序：包级变量初始化 → init() 执行 → TestMain()（如果存在）→ TestXxx() 执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-yi&quot;&gt;&lt;strong&gt;注意：&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;init() 是全局性的，一旦定义就会在所有测试前执行
所以如果你在某个文件中写了一个 init()，它无法按需控制是否执行，这会给某些不需要它的测试带来副作用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;p&gt;如果你在一个文件中定义了&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; utils.go
func HashPassword(pw string) string {
    &amp;#x2F;&amp;#x2F; 哈希逻辑
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func init() {
    &amp;#x2F;&amp;#x2F; 建立数据库连接
    db, _ = sql.Open(&amp;quot;postgres&amp;quot;, &amp;quot;...&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你只想测试 HashPassword()，跟数据库没关系，但：&lt;&#x2F;p&gt;
&lt;p&gt;Go 会强制执行 init() → 建立数据库连接&lt;&#x2F;p&gt;
&lt;p&gt;如果数据库挂了、网络断了，测试失败&lt;&#x2F;p&gt;
&lt;p&gt;即使测试内容跟数据库一毛钱关系都没有&lt;&#x2F;p&gt;
&lt;p&gt;init() 是文件级别、不可控制的初始化逻辑，一旦存在，它就会对这个包的所有使用者和测试者产生影响。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;做法：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;尽量避免在 init() 中建立全局连接或启动重逻辑 不要用 init() 连数据库&lt;&#x2F;p&gt;
&lt;p&gt;把数据库连接从 init() 拆出去，改成显式初始化函数，这样测试更灵活、代码更可控、依赖更清晰&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;var DB *sql.DB

func InitDB(dsn string) error {
	var err error
	DB, err = sql.Open(&amp;quot;postgres&amp;quot;, dsn)
	return err
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;quan-ju-bian-liang&quot;&gt;全局变量&lt;&#x2F;h2&gt;
&lt;p&gt;如果把数据库连接对象赋值给全局变量（如 var db *sql.DB），为什么这会让单元测试变复杂、变得“不隔离”？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li-1&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
package user

import &amp;quot;yourproject&amp;#x2F;db&amp;quot;

func GetUserByID(id int) (*User, error) {
	return db.DB.Query(...) &amp;#x2F;&amp;#x2F; 用的是全局变量 db.DB
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;它依赖的是全局变量 db.DB，你没法注入 mock 数据库(全局变量在代码里写死了，函数内部直接引用它，测试时你没法“替换”这个变量指向别的对象)，也无法用内存数据库替代。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-jue&quot;&gt;解决：&lt;&#x2F;h3&gt;
&lt;p&gt;将 DB 作为参数而不是全局变量&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
type UserRepo struct {
	DB *sql.DB
}

func (r *UserRepo) GetUserByID(id int) (*User, error) {
	return r.DB.Query(...)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;main.go&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;db, _ := sql.Open(...)
repo := user.UserRepo{DB: db}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;测试中&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;fakeDB := NewFakeDB() &amp;#x2F;&amp;#x2F; 或用 sqlite、mock
repo := user.UserRepo{DB: fakeDB}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; db_test.go
package db

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;
)

func Test_Global_DB(t *testing.T) {
	DB = &amp;quot;RealDB&amp;quot;
	got := GetUserGlobal(1)
	fmt.Println(got)

	DB = &amp;quot;MockDB&amp;quot; &amp;#x2F;&amp;#x2F; ← 修改全局变量

	got2 := GetUserGlobal(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 问题：前后结果不一致，测试间共享状态
}

func Test_DI_DB(t *testing.T) {
	real := &amp;amp;DBClient{DB: &amp;quot;RealDB&amp;quot;}
	mock := &amp;amp;DBClient{DB: &amp;quot;MockDB&amp;quot;}

	got := real.GetUserDI(1)
	fmt.Println(got)

	got2 := mock.GetUserDI(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 优点：各自隔离，不会互相影响
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
