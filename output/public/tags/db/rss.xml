<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title> - DB</title>
      <link>https://Zhonghe-zhao.github.io/DailyBlog/</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://Zhonghe-zhao.github.io/DailyBlog/tags/db/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 13 Jun 2025 13:21:31 +0000</lastBuildDate>
      <item>
          <title>数据库</title>
          <pubDate>Fri, 13 Jun 2025 13:21:31 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-21/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-21/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-21/">&lt;h1 id=&quot;shu-ju-ku-zhi-shi-shu-li&quot;&gt;数据库知识梳理&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shen-me-shi-shu-ju-ku&quot;&gt;什么是数据库？&lt;&#x2F;h2&gt;
&lt;p&gt;数据的仓库 高效的保存和查询数据&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-yao-bao-cun-he-cha-xun-shu-ju-ru-he-bao-zheng-shu-ju-bei-zheng-chang-cun-chu-he-ru-he-cha-xun-shu-ju&quot;&gt;为什么要 保存和查询数据  如何保证数据被正常存储 和 如何查询数据？&lt;&#x2F;h2&gt;
&lt;p&gt;保存数据：系统能长期使用和分析这些数据，&lt;&#x2F;p&gt;
&lt;p&gt;查询数据： 用户能根据条件快速找出需要的信息&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;如何保证数据正确被保存和正确的查询数据？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;数据库事务&lt;&#x2F;li&gt;
&lt;li&gt;约束&lt;&#x2F;li&gt;
&lt;li&gt;日志&lt;&#x2F;li&gt;
&lt;li&gt;数据备份&lt;&#x2F;li&gt;
&lt;li&gt;DBMS&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shen-me-shi-shu-ju-ku-shi-wu&quot;&gt;什么是数据库事务&lt;&#x2F;h2&gt;
&lt;p&gt;保证一组操作要么全部成功、要么全部失败的机制，核心用于&lt;strong&gt;保证数据一致性。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;事务的四大特性：&lt;&#x2F;p&gt;
&lt;p&gt;ACID&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;为什么事务可以避免并发冲突？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;隔离机制： 数据库的隔离级别 + 锁机制&lt;&#x2F;p&gt;
&lt;p&gt;事务的隔离级别：&lt;&#x2F;p&gt;
&lt;p&gt;自上向下 性能由高到低&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交：虽然级别最低 但也有它的作用。实时监控数据的变化， 对数据一致性要求不严格，允许读到脏数据但能换取速度。&lt;&#x2F;li&gt;
&lt;li&gt;读已提交 ： 事务只能读导已经提交的数据（避免脏读）&lt;&#x2F;li&gt;
&lt;li&gt;可重复读 ：在事务内对同一行多次读取是一样的（其他事务不能修改）&lt;&#x2F;li&gt;
&lt;li&gt;可串行化： 对读的范围加 锁 拒绝其它插入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;dui-yu-ke-zhong-fu-du&quot;&gt;对于可重复读&lt;&#x2F;h2&gt;
&lt;p&gt;在 可重复读隔离级别下，一个事务在开始后所读取的数据会基于快照，一直一致，同一条记录无论读多少次，看到的都是事务开始时的版本，即使其他事务已经修改并提交了这条记录。每个事务会生成一个快照版本号，之后所有查询都基于这个版本读取；不会加锁，但能保证多次读取一致（除非手动加锁，无法防幻读）；&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;对于可串行化：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在某些数据库（如 MySQL）用强锁机制实现。&lt;&#x2F;p&gt;
&lt;p&gt;在 PostgreSQL 中通过MVCC + 并发冲突检测（SSI）实现，更智能但也有事务被中止的风险。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dui-yu-huan-du-qing-kuang&quot;&gt;对于幻读情况&lt;&#x2F;h2&gt;
&lt;p&gt;出现了**“幻影数据”** → 第二次出现了之前“范围里没有”的新行 → 这就是幻读。为什么可重复读 不能 避免幻读？ MVCC快照机制 只保证读过的记录内容不变，没读过的新行还是可以看到！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;所以可以使用 锁！避免Serializable隔离级别带来的严重性能差&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;所以对于锁的使用时机，如何正确的使用锁，死锁？ 等一些情况 需要对锁有一定的了解和调试！&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;所以&lt;strong&gt;Serializable&lt;&#x2F;strong&gt;的问题 时性能问题！ 只需要开发者修改一下隔离级别，就行轻松避免 脏读等问题！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;并发事务产生的问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;脏读&lt;&#x2F;em&gt;： 读到未提交的数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;不可重复读&lt;&#x2F;em&gt;： 同一次查询 两次读的结果不同&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;序列化异常&lt;&#x2F;em&gt;： 成功提交一组事务的结果与一次运行这些事务的所有可能顺序不一致。&lt;&#x2F;p&gt;
&lt;p&gt;疑惑： 不可重复读 怎么了？ A读100 b修改为50 再次读取不应该就是50吗 难道还要让他读到100？&lt;&#x2F;p&gt;
&lt;p&gt;解答： 在事务A未提交时，事务B提交了修改，导致事务A中同一数据多次读取结果不一致，破坏了事务的隔离性，可能导致逻辑错误或数据不稳定。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;幻读&lt;&#x2F;em&gt;： 查询范围内数据被别人新增&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h2&gt;
&lt;p&gt;假设账户初始余额是 100，有两个事务并发执行：&lt;&#x2F;p&gt;
&lt;p&gt;事务 A：读余额 → 如果 ≥100，则扣 100&lt;&#x2F;p&gt;
&lt;p&gt;事务 B：读余额 → 如果 ≥100，则扣 100&lt;&#x2F;p&gt;
&lt;p&gt;如果没有串行控制，两者几乎同时读到 100，都满足条件，各自扣 100，最终余额变成 -100！&lt;&#x2F;p&gt;
&lt;p&gt;Serializable的隔离级别可以让数据库检测到并发冲突，强制回滚其中一个事务，性能会大大折扣&lt;&#x2F;p&gt;
&lt;p&gt;Serializable的工作原理：&lt;&#x2F;p&gt;
&lt;p&gt;事务之间如果有“不可串行化的依赖”，就会强制让一个事务回滚；&lt;&#x2F;p&gt;
&lt;p&gt;PostgreSQL 的 Serializable 是通过 检测事务冲突图 实现的（SSI），不是加锁；&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-ju-ku-suo-ji-zhi&quot;&gt;数据库锁机制&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;cun-chu-yin-qing&quot;&gt;存储引擎&lt;&#x2F;h2&gt;
&lt;p&gt;负责存储、处理和检索数据的核心组件&lt;&#x2F;p&gt;
&lt;p&gt;应对不同的场景 ， 不同的场景会用到不同的存储引擎&lt;&#x2F;p&gt;
&lt;p&gt;数据的物理结构 ， 索引 ， 查询的实现方式&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pgxiang-bi-yu-mysql&quot;&gt;PG相比于MYSQL&lt;&#x2F;h2&gt;
&lt;p&gt;Postgres：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;MVCC（多版本并发控制）： PostgreSQL 使用 MVCC 来实现事务隔离，通过为每个事务创建数据快照（版本）来避免读写冲突，默认隔离级别是读已提交，但可轻松配置为可重复读或串行化。

行级锁：

死锁检测：
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
