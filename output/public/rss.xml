<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title></title>
      <link>https://Zhonghe-zhao.github.io/DailyBlog/</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://Zhonghe-zhao.github.io/DailyBlog/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sat, 28 Jun 2025 06:05:50 +0000</lastBuildDate>
      <item>
          <title>Things I like</title>
          <pubDate>Sat, 28 Jun 2025 06:05:50 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-35/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-35/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-35/">&lt;h2 id=&quot;yun-dong&quot;&gt;运动&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;足球&lt;&#x2F;li&gt;
&lt;li&gt;跑步&lt;&#x2F;li&gt;
&lt;li&gt;篮球&lt;&#x2F;li&gt;
&lt;li&gt;羽毛球&lt;&#x2F;li&gt;
&lt;li&gt;乒乓球&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;shu-ji&quot;&gt;书籍&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;file.cz123.top&#x2F;7Literature&#x2F;CHINESE_LITERATURE&#x2F;%E6%B4%BB%E7%9D%80%20%28%E4%BD%99%E5%8D%8E%29%20.pdf&quot;&gt;《活着》&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.feiku6.com&#x2F;read&#x2F;s3-wencheng&#x2F;18348550.html&quot;&gt;《文成》&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;fanqienovel.com&#x2F;reader&#x2F;6925022762981395470?enter_from=reader&quot;&gt;《病隙碎笔》&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ge-qu&quot;&gt;歌曲&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_J-o8FpJ-XY&amp;amp;list=RD_J-o8FpJ-XY&amp;amp;start_radio=1&quot;&gt;最佳损友&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;chang-jing&quot;&gt;场景&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;冬天&lt;&#x2F;li&gt;
&lt;li&gt;雨天&lt;&#x2F;li&gt;
&lt;li&gt;自然&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;And 家&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>About me</title>
          <pubDate>Sat, 28 Jun 2025 05:50:17 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-34/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-34/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-34/">&lt;p&gt;简单介绍一下我自己，也算是看看对自己的了解能写出什么哈哈哈&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;啊我的性格还是很好的，能和大家快速的融入到一起，很癫哈哈哈，有点直，略有些感性，有时莫名的急躁哈&lt;&#x2F;li&gt;
&lt;li&gt;喜欢记录自己的生活，喜欢回忆往事&lt;&#x2F;li&gt;
&lt;li&gt;喜欢下象棋，踢足球，游戏方面也几乎都涉猎过，长大了玩的也少了&lt;&#x2F;li&gt;
&lt;li&gt;总是喜欢思考一些哲学问题哈哈，看似一些简单问题的背后会有很奇妙的东西&lt;&#x2F;li&gt;
&lt;li&gt;不喜欢束缚自己的任何事物，那让我很不自在，我想做我喜欢的事情，即使有时候会错失什么&lt;&#x2F;li&gt;
&lt;li&gt;喜欢海贼王！&lt;&#x2F;li&gt;
&lt;li&gt;书籍方面就是，余华老师的一些作品&lt;&#x2F;li&gt;
&lt;li&gt;虽然接触的编程时间很少，但是这个大家庭真的让我走不开了！&lt;&#x2F;li&gt;
&lt;li&gt;大学之后真的成长了很多&lt;&#x2F;li&gt;
&lt;li&gt;感谢一路上遇见的大家&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;此记录时间： 2025&#x2F;06&#x2F;28&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>跨网络通信编程模式</title>
          <pubDate>Fri, 27 Jun 2025 13:41:09 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-33/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-33/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-33/">&lt;h2 id=&quot;restful-api&quot;&gt;RESTFUL API&lt;&#x2F;h2&gt;
&lt;p&gt;虽然HTTP协议已经规范了基础的请求&#x2F;响应格式，但正是因为它太灵活，反而导致了早期Web服务的混乱。&lt;&#x2F;p&gt;
&lt;p&gt;HTTP原生问题：
同一个用户查询功能，不同开发者可能设计出完全不同的接口&lt;&#x2F;p&gt;
&lt;p&gt;所以导致了 RESTFUL API的诞生!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;约定:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;URL 表示资源，如 &#x2F;users&#x2F;1&lt;&#x2F;p&gt;
&lt;p&gt;用标准 HTTP 动词：GET 查，POST 新增，PUT 修改，DELETE 删&lt;&#x2F;p&gt;
&lt;p&gt;数据统一用 JSON（或标准格式）&lt;&#x2F;p&gt;
&lt;p&gt;服务无状态（每次请求都完整表达意图）&lt;&#x2F;p&gt;
&lt;p&gt;规范为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;http&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;
HTTP&amp;#x2F;1.1 201 Created
Location: &amp;#x2F;users&amp;#x2F;123
Content-Type: application&amp;#x2F;json

{ &amp;quot;id&amp;quot;: 123, &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot; }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;
&amp;#x2F;&amp;#x2F; 传统混乱的响应
{
  &amp;quot;success&amp;quot;: true,
  &amp;quot;code&amp;quot;: 200,
  &amp;quot;message&amp;quot;: &amp;quot;OK&amp;quot;,
  &amp;quot;data&amp;quot;: { &amp;quot;id&amp;quot;: 123, &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot; }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说:&lt;&#x2F;p&gt;
&lt;p&gt;HTTP 可以发任何东西，RESTful API 让它发得标准、发得规范。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;RESTful API 规范是靠人遵守的工程文化，不是自动生效的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;grpc&quot;&gt;gRPC&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;websocket&quot;&gt;WebSocket&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;xiao-xi-dui-lie&quot;&gt;消息队列&lt;&#x2F;h2&gt;
</description>
      </item>
      <item>
          <title>授权与认证</title>
          <pubDate>Fri, 27 Jun 2025 09:34:29 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-32/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-32/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-32/">&lt;h1 id=&quot;ming-que-gai-nian&quot;&gt;明确概念&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;认证：&lt;&#x2F;strong&gt; 确认你是谁？ 验证你的身份&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;授权：&lt;&#x2F;strong&gt; 确认你能做什么，给_认证的用户_分配权限&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-dan-sheng-cookie-session&quot;&gt;Why 诞生 Cookie Session？&lt;&#x2F;h2&gt;
&lt;p&gt;因为HTTP的无状态性，诞生的问题&lt;&#x2F;p&gt;
&lt;p&gt;“如何在同一用户的多次请求间保持连续状态？”&lt;&#x2F;p&gt;
&lt;p&gt;用户登录后，服务器需要知道后续请求（如购物车操作）来自同一个已认证用户。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;&#x2F;h2&gt;
&lt;p&gt;Cookie 必须通过 HTTP 协议的头字段（Headers）传递&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务器下发 Cookie（响应头）
通过 &lt;em&gt;Set-Cookie&lt;&#x2F;em&gt; 头字段向客户端（如浏览器）写入 Cookie&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;客户端回传 Cookie（请求头）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;有一定安全风险！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;session&quot;&gt;Session&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;解决问题：&lt;&#x2F;strong&gt;  如果直接把用户权限、余额等敏感信息存在客户端（如 Cookie），用户可以轻易篡改&lt;&#x2F;p&gt;
&lt;p&gt;敏感数据存服务端，客户端仅持有无意义的 session_id&lt;&#x2F;p&gt;
&lt;p&gt;在服务器端集中存储用户状态，用户登录时，服务器生成唯一 session_id 并存储相关数据&lt;&#x2F;p&gt;
&lt;p&gt;传递Session_id -&amp;gt; 客户端&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Session的本质：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用户登录 → 浏览网站 → 加购商品 → 退出登录。&lt;&#x2F;p&gt;
&lt;p&gt;这一系列操作属于 同一个会话，数据仅在会话期间需要。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;为什么Session要具备 存储具体数据的能力？&lt;&#x2F;p&gt;
&lt;p&gt;Session 存在于服务端，它的职责是「存储这个人的状态和数据」，比如 user_id、is_login、username 等。&lt;&#x2F;p&gt;
&lt;p&gt;方便服务端快速取用用户数据
Session 已经在内存或持久化存储中存了这些信息，后续请求不需要每次拿 token 去查数据库。&lt;&#x2F;p&gt;
&lt;p&gt;安全性和灵活性
Session 的内容在服务端，客户端完全看不到。这样可以存一些和权限、业务相关的信息（比如角色、登录状态等），防止客户端篡改。&lt;&#x2F;p&gt;
&lt;p&gt;支持更多状态管理
比如除了登录状态，还可以记录购物车、上次访问时间、权限标志等，这些都放在 Session 里方便统一管理。&lt;&#x2F;p&gt;
&lt;p&gt;所以Session：&lt;&#x2F;p&gt;
&lt;p&gt;可以，但那样每次请求都需要拿这个 id 去查数据库或其他存储，浪费性能。&lt;strong&gt;Session 就是为了避免频繁查数据库&lt;&#x2F;strong&gt;，同时把&lt;strong&gt;状态控制在服务端&lt;&#x2F;strong&gt;，提高安全性。&lt;&#x2F;p&gt;
&lt;p&gt;如果想极简方案，也可以只存 user_id，但这会牺牲性能或灵活性。&lt;&#x2F;p&gt;
&lt;p&gt;**减少数据库查询：将高频访问的数据（如权限、购物车）缓存在 Session 中。&lt;&#x2F;p&gt;
&lt;p&gt;实时生效：修改 Session 后立即可见（如用户退出时直接删除 Session）。**&lt;&#x2F;p&gt;
&lt;h2 id=&quot;que-xian&quot;&gt;缺陷&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Cookie 的短板：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;若把所有数据（如 user_role=admin）存在 Cookie 中：&lt;&#x2F;p&gt;
&lt;p&gt;用户可手动修改 role=superadmin 提权（安全隐患）。&lt;&#x2F;p&gt;
&lt;p&gt;数据大小受限（不能存购物车等复杂数据）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;token&quot;&gt;Token&lt;&#x2F;h2&gt;
&lt;p&gt;在客户端存储自包含的加密数据（如 JWT），服务端无需存储会话状态。&lt;&#x2F;p&gt;
&lt;p&gt;如果 Token 是明文（如 user_id=123&amp;amp;role=admin），用户可随意修改（如改 role=superadmin）。&lt;&#x2F;p&gt;
&lt;p&gt;通过签名（如 HMAC、RSA）加密 Token，确保数据不被篡改。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Kevin Kelly</title>
          <pubDate>Fri, 27 Jun 2025 04:09:14 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-31/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-31/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-31/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kk.org&#x2F;thetechnium&#x2F;99-additional-bits-of-unsolicited-advice&#x2F;&quot;&gt;kk.org&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一些很好的建议！&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;“It’s not an apology if it comes with an excuse. It is not a compliment if it comes with a request. ”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;如果道歉夹带理由或借口，本质上是在为自己开脱，而不是承担责任。真正的道歉应当是直面错误，不推卸、不辩解。&lt;&#x2F;p&gt;
&lt;p&gt;如果夸奖后立刻提要求，这夸奖就成了手段，不是发自内心的赞赏。真诚的赞美不图回报，只是表达认可。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;Learn how to learn from those you disagree with, or even offend you. See if you can find the truth in what they believe. &quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;放下成见，善于从不同或对立的观点中吸取智慧，这能拓宽你的认知边界。&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;Always demand a deadline. A deadline weeds out the extraneous and the ordinary. It prevents you from trying to make it perfect, so you have to make it different. Different is better.&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;时间压力能激发创新，不要浪费时间在琐碎细节上。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Docker</title>
          <pubDate>Thu, 26 Jun 2025 08:59:00 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-30/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-30/">&lt;h1 id=&quot;dockerwei-shen-me-hui-dan-sheng&quot;&gt;Docker为什么会诞生&lt;&#x2F;h1&gt;
&lt;p&gt;为解决传统部署存在的问题！&lt;&#x2F;p&gt;
&lt;p&gt;Docker(容器)：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;确保环境一致性： 将应用打包成镜像， 一次构建到处运行！&lt;&#x2F;li&gt;
&lt;li&gt;**隔离性：**利用Linux内核特性（cgroups&#x2F;namespace）实现进程隔离。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;vs&lt;&#x2F;strong&gt; 虚拟机的隔离方式：&lt;&#x2F;p&gt;
&lt;p&gt;虚拟机：本质跑多个完整的系统，每个虚拟机有自己的 （独立内核 独立文件系统 独立网络 独立资源控制）&lt;&#x2F;p&gt;
&lt;p&gt;Docker： 本质是“在同一个系统中虚拟多个独立空间”，不用虚拟完整 OS，只是隔离进程  共享主机内核&lt;&#x2F;p&gt;
&lt;p&gt;Docker 利用 Namespaces 实现资源“看不见”（不同容器有自己独立的网络、进程表、文件系统），利用 Cgroups 实现资源“用不了太多”（ 限制 CPU 核心数、内存上限，避免资源抢光）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;要做到上述功能 必须需要Docker具有linux的内核，在Windows&#x2F;mac上怎么才能具有linux内核呢？&lt;&#x2F;p&gt;
&lt;p&gt;Windows WSL2（Windows Subsystem for Linux） 轻量级Linux虚拟机（内置Linux内核）
macOS HyperKit（基于Hypervisor.framework） 轻量级Linux虚拟机&lt;&#x2F;p&gt;
&lt;p&gt;用户启动Docker Desktop&lt;&#x2F;p&gt;
&lt;p&gt;自动启动一个隐藏的Linux虚拟机（通过WSL2或Hyper-V）&lt;&#x2F;p&gt;
&lt;p&gt;所有Docker容器实际运行在这个Linux虚拟机内&lt;&#x2F;p&gt;
&lt;p&gt;Docker CLI通过RPC与虚拟机内的Docker引擎通信&lt;&#x2F;p&gt;
&lt;p&gt;事实就是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;Docker容器本质依赖Linux内核的特性（如Namespace&#x2F;Cgroups）。在Windows&#x2F;Mac上，Docker Desktop通过内置的Linux虚拟机（WSL2&#x2F;HyperKit）提供Linux内核支持，容器实际运行在这个虚拟机内，而非直接调用Windows内核。&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;wei-shen-me-docker-yao-yun-xing-zai-linux-shang&quot;&gt;为什么Docker 要运行在 Linux 上？&lt;&#x2F;h2&gt;
&lt;p&gt;容器化技术依赖Linux内核的三大机制：&lt;&#x2F;p&gt;
&lt;p&gt;Namespaces（命名空间） → 提供进程隔离（PID、网络、挂载点等）&lt;&#x2F;p&gt;
&lt;p&gt;Cgroups（控制组） → 限制资源（CPU、内存、IO）&lt;&#x2F;p&gt;
&lt;p&gt;UnionFS（联合文件系统） → 实现镜像分层存储&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wsl2-vs-vm&quot;&gt;WSL2 VS VM&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;WSL2 共享Windows内核的部分功能（如调度器），而传统VM需模拟完整硬件并运行独立OS。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;wen-ti-1&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;“内核”到底是什么？它的角色和操作系统是一致的？&lt;&#x2F;p&gt;
&lt;p&gt;内核四大职责：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;进程管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;创建&#x2F;销毁进程（fork()、exit()）&lt;&#x2F;p&gt;
&lt;p&gt;CPU调度（决定哪个进程运行）
示例：Docker容器本质是内核通过clone()+Namespace创建的隔离进程&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;内存管理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;分配物理内存（malloc()底层依赖内核）&lt;&#x2F;p&gt;
&lt;p&gt;虚拟内存（分页&#x2F;交换空间）&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;设备驱动&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;文件系统&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;[todo]&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;联合文件系统&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;向上：通过系统调用（syscall） 为软件提供服务
向下：直接操作CPU&#x2F;内存&#x2F;设备寄存器&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerbu-shu-de-liu-cheng&quot;&gt;Docker部署的流程&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;编写 Dockerfile&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;定义基础镜像（如 golang:1.20 或更小的 scratch）&lt;&#x2F;p&gt;
&lt;p&gt;拷贝你的代码和依赖&lt;&#x2F;p&gt;
&lt;p&gt;编译生成可执行文件（或直接用编译好的二进制）&lt;&#x2F;p&gt;
&lt;p&gt;设置容器启动命令（比如运行 simplebank 服务）&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构建镜像&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;执行 docker build -t simplebank:latest .&lt;&#x2F;p&gt;
&lt;p&gt;生成一个包含你的程序和运行环境的镜像文件&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;推送镜像（可选）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;把镜像上传到远程仓库，如 Docker Hub 或私有 Harbor&lt;&#x2F;p&gt;
&lt;p&gt;方便其他服务器拉取&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;运行容器&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;访问服务
通过服务器的 IP 和端口访问你的 SimpleBank API&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;维护和更新&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;更新代码后，重复构建镜像和部署容器流程&lt;&#x2F;p&gt;
&lt;p&gt;可以通过 Docker Compose 或 Kubernetes 做多容器编排和扩展&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jing-xiang-guan-li&quot;&gt;镜像管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;rong-qi-cao-zuo&quot;&gt;容器操作&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;wang-luo-guan-li&quot;&gt;网络管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;shu-ju-chi-jiu-hua&quot;&gt;数据持久化&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;&#x2F;h2&gt;
&lt;p&gt;构建镜像： 基础环境 依赖安装 文件复制 启动命令&lt;&#x2F;p&gt;
&lt;p&gt;实际的执行流程：&lt;&#x2F;p&gt;
&lt;p&gt;镜像（Image） → 启动后变成 → 容器（Container）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shelljiao-ben&quot;&gt;Shell脚本&lt;&#x2F;h2&gt;
&lt;p&gt;用途： 自动化任务、批量处理、服务管理、部署流程等。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;#!&amp;#x2F;bin&amp;#x2F;sh

set -e

echo &amp;quot;run db migrations&amp;quot;
&amp;#x2F;app&amp;#x2F;migrate -path &amp;#x2F;app&amp;#x2F;migration -database &amp;quot;$DB_SOURCE&amp;quot; -verbose up

echo &amp;quot;start the app&amp;quot;
exec &amp;quot;$@&amp;quot;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;Dockerfiles&quot; class=&quot;language-Dockerfiles &quot;&gt;&lt;code class=&quot;language-Dockerfiles&quot; data-lang=&quot;Dockerfiles&quot;&gt;
EXPOSE 8080 
CMD [ &amp;quot;&amp;#x2F;app&amp;#x2F;main&amp;quot; ]
ENTRYPOINT [ &amp;quot;&amp;#x2F;app&amp;#x2F;start.sh&amp;quot; ]

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;CMD&lt;&#x2F;em&gt;  定义默认参数，会被 &lt;em&gt;ENTRYPOINT&lt;&#x2F;em&gt; 使用，也可被 docker run 的参数覆盖&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;完成_Dockerfiles_文件的编写，构建镜像！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker build -t your-service:1.0 .&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker run -it --rm your-service:1.0 sh&lt;&#x2F;code&gt; 运行！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;docker-compose-yaml&quot;&gt;Docker-compose.yaml&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过一个 YAML 文件定义和编排多容器应用，实现一键启动完整服务栈。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;shen-me-shi-duo-rong-qi-bian-pai&quot;&gt;什么是多容器编排&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;多个容器协同运行，组成一个完整系统，并通过自动化工具统一管理和部署的过程，就叫多容器编排。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;多个容器之间需要保证什么？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动顺序正确&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;网络互通&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;环境一致&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;自动恢复&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;动态扩容&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-li&quot;&gt;实例：&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt;
services:
  postgres:
    image: postgres:12-alpine
    environment:
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=simple_bank
    ports:
      - &amp;quot;5433:5432&amp;quot;
    volumes:
      - data-volume:&amp;#x2F;var&amp;#x2F;lib&amp;#x2F;postgresql&amp;#x2F;data

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动了一个数据库容器 并且配置了一系列环境&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    depends_on:
      - postgres
      - redis
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;启动顺序&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lian-jie-dockerfiles-he-docker-compose&quot;&gt;连接Dockerfiles 和 docker-compose&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;yml&quot; class=&quot;language-yml &quot;&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt; api:
  build:
    context: .
    dockerfile: Dockerfile
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;wen-ti-2&quot;&gt;问题&lt;&#x2F;h3&gt;
&lt;p&gt;编写完Dockerfiles文件后 也就是构建完成镜像之后就可以启动镜像为容器了，也就是项目可以正常启动了，为什么还需要docker-compose文件编排多个容器呢？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker-compose up -d  # 一键启动所有服务，自动处理依赖&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dockerzhong-de-wang-luo-wen-ti&quot;&gt;docker中的网络问题&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;网络模式：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;bridge&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;每个 Bridge 网络形成一个独立的虚拟局域网（VLAN）&lt;&#x2F;p&gt;
&lt;p&gt;同一网络内的容器可通过容器名互相访问（无需IP）&lt;&#x2F;p&gt;
&lt;p&gt;容器访问外网时，IP会被转换为宿主机IP（通过iptables规则）&lt;&#x2F;p&gt;
&lt;p&gt;需手动映射端口（-p 8080:80）才能从宿主机外部访问容器服务&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duan-kou-ying-she&quot;&gt;端口映射&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker 将容器内部端口绑定到宿主机端口的机制&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;c1b8951b-0444-4cb4-8341-fad1707d9947&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;# 将容器的80端口映射到宿主机的8080端口 docker run -d -p 8080:80 --name nginx nginx &lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;网卡的作用：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;主机和外部网络的桥梁，完成数据收发和初步封装&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Docker 会创建虚拟网卡（veth pair）：&lt;&#x2F;p&gt;
&lt;p&gt;一端在容器内，另一端接到宿主机的网桥（docker0）。&lt;&#x2F;p&gt;
&lt;p&gt;通过虚拟网卡，容器流量被送到宿主机网络，再被转发出去（如 NAT）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nat&quot;&gt;NAT&lt;&#x2F;h4&gt;
&lt;p&gt;把私有网络的 IP 地址转换成公有网络的 IP 地址，实现内网访问外网或不同网段通信。 主要解决 IP 不够用 + 内网隔离 + 控制流量 的问题。&lt;&#x2F;p&gt;
&lt;p&gt;Docker 默认用 NAT：
容器内的私有 IP（如 172.17.x.x）通过 NAT 转换成宿主机的 IP 对外通信。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tong-xin&quot;&gt;通信&lt;&#x2F;h2&gt;
&lt;p&gt;同网络下的容器可以通信，在自定义的网络中 他们可以通过容器名自动互相访问&lt;&#x2F;p&gt;
&lt;p&gt;创建网络 并加入pg容器&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network connect bank-network postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;检查容器内部配置&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker network inspect bank-newtork&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;docker container inspect postgres12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>软件工程中的一些重要思想</title>
          <pubDate>Wed, 25 Jun 2025 13:29:50 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-29/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-29/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-29/"></description>
      </item>
      <item>
          <title>Computer_Network</title>
          <pubDate>Wed, 25 Jun 2025 09:17:17 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-28/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-28/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-28/">&lt;h2 id=&quot;osimo-xing&quot;&gt;OSI模型&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;核心： 每一层只负责特定的功能&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;物理层：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;传输原始比特流（0和1）&lt;&#x2F;p&gt;
&lt;p&gt;协议： Ethernet (IEEE 802.3)&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;数据链路层：
(交换机)
将比特流组织成数据帧，通过MAC地址在局域网内寻址&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;错误检测（如CRC）、流量控制（如交换机）。&lt;&#x2F;p&gt;
&lt;p&gt;协议： Ethernet (IEEE 802.3)、Wi-Fi (IEEE 802.11) PPP（点对点协议）、VLAN（虚拟局域网）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;网络层：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑寻址（如IP地址）和路由选择（决定数据包从源到目标的路径）。&lt;&#x2F;p&gt;
&lt;p&gt;关键设备：路由器（Router）、三层交换机。&lt;&#x2F;p&gt;
&lt;p&gt;协议： IP（IPv4&#x2F;IPv6）、ICMP（Ping）、OSPF、BGP（路由协议）、ARP（地址解析）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;传输层（Transport Layer）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;提供端到端（应用程序之间）的可靠或不可靠传输。&lt;&#x2F;p&gt;
&lt;p&gt;分段（将数据分成段）、流量控制、错误恢复（如重传）。&lt;&#x2F;p&gt;
&lt;p&gt;协议： TCP UDP&lt;&#x2F;p&gt;
&lt;p&gt;5.表示层
6.会话层&lt;&#x2F;p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;应用层&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;直接为用户应用程序提供网络服务接口。&lt;&#x2F;p&gt;
&lt;p&gt;协议： HTTP（网页）、FTP（文件传输）、SMTP（邮件）、DNS（域名解析）、SSH（安全登录）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-hua-de-tcp-ipmo-xing&quot;&gt;简化的TCP&#x2F;IP模型&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;li-jie-dui-deng-chuan-shu&quot;&gt;理解对等传输&lt;&#x2F;h2&gt;
&lt;p&gt;每一层的协议在逻辑上认为自己在直接和对端同一层通信，尽管实际数据需要经过下层封装传输。&lt;&#x2F;p&gt;
&lt;p&gt;也就是 协议栈中同一层的虚拟直接对话 数据在设备间经过的物理和逻辑路径。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例：以HTTP请求为例的双重视角&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;1.主机A（192.168.1.2）访问服务器B（203.0.113.5）的网页，经过一个路由器。&lt;&#x2F;p&gt;
&lt;p&gt;主机A的HTTP协议 ↔ 服务器B的HTTP协议&lt;&#x2F;p&gt;
&lt;p&gt;逻辑上认为直接发送GET &#x2F;index.html并接收200 OK响应。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;主机A的TCP ↔ 服务器B的TCP&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上建立端到端连接，维护序列号和确认机制。&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;主机A的IP ↔ 服务器B的IP&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上认为IP包从192.168.1.2直达203.0.113.5。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;主机A的MAC ↔ 路由器R1的MAC ↔ 服务器B的MAC&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;逻辑上逐跳协商帧传输（每跳MAC地址变化）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-1&quot;&gt;问题1：&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;交换机转发帧时，是否破坏了数据链路层的对等性？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;交换机只短暂参与MAC层转发，最终帧仍由目标主机的数据链路层处理。&lt;&#x2F;p&gt;
&lt;p&gt;交换机对帧的转发依赖物理层完成信号传输&lt;&#x2F;p&gt;
&lt;p&gt;交换机： 它根据 MAC 地址表，接收帧 → 看目标 → 选择接口转发帧，不改帧内容，也不破坏通信逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;所以交换机就是在链路层转发帧的智能中继器，它不参与更上层的逻辑，靠 MAC 地址表做“选择转发”。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-2&quot;&gt;问题2：&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;IP提供全局逻辑寻址，MAC提供局域网物理寻址 具体是什么流程&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ip：&lt;&#x2F;p&gt;
&lt;p&gt;“全局”：IP地址（例如192.168.1.10或公网IP如8.8.8.8）是全球范围内唯一的，就像一个人的家庭地址（国家+城市+街道+门牌号）。无论设备在世界的哪个角落，IP地址都能唯一标识它。&lt;&#x2F;p&gt;
&lt;p&gt;“逻辑”：IP地址不是绑在硬件上的，而是由软件配置的。比如，你换了网卡，IP地址可以保持不变；或者你把电脑带到另一个网络，IP地址可以重新分配。这种灵活性让IP地址像一个“虚拟标签”，不依赖物理设备。&lt;&#x2F;p&gt;
&lt;p&gt;“寻址”：IP地址的作用是告诉数据包“最终要去哪里”。比如，你从上海寄快递到北京，IP地址就像快递单上的收件人地址，路由器会根据它决定把数据包送到哪个网络。&lt;&#x2F;p&gt;
&lt;p&gt;MAC：&lt;&#x2F;p&gt;
&lt;p&gt;“局域网”：MAC地址（例如AA:BB:CC:DD:EE:FF）只在同一个局域网（LAN，比如你家Wi-Fi网络）内有效。出了这个局域网，MAC地址就没用了，就像你家楼栋内的门牌号，只在楼里有效，出了小区就没人知道。&lt;&#x2F;p&gt;
&lt;p&gt;“物理”：MAC地址是网卡的硬件地址，烧录在网卡芯片里，相当于设备的“身份证号”。它直接跟硬件绑定，告诉局域网内的设备“这是谁的网卡”。&lt;&#x2F;p&gt;
&lt;p&gt;“寻址”：在局域网内，数据包（以太网帧）靠MAC地址找到具体的设备。比如，你家有台电脑和打印机，交换机通过MAC地址知道把数据送到电脑还是打印机。&lt;&#x2F;p&gt;
&lt;p&gt;为什么重要？：局域网内的设备通信很快，交换机直接用MAC地址表转发数据，不需要复杂的逻辑判断，效率很高。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-3&quot;&gt;问题3：&lt;&#x2F;h2&gt;
&lt;p&gt;假如用我的思想就是，既然ip是唯一的，那么直接用ip通过路由器找到目标机器，既然交换机不能识别帧我们就去除MAC层？ 难道不行吗 直接对ip包传输到物理层？&lt;&#x2F;p&gt;
&lt;p&gt;IP地址可能重复（不同局域网可能用相同的私有IP）。MAC地址在局域网内由硬件保证唯一，适合本地寻址。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;这可能就是我的思想出了问题！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;IP：负责端到端的全局寻址，确保数据包从源（比如上海的电脑）到目标（比如北京的服务器）能跨网络到达。它像快递的全国调度系统，规划路线但不负责具体投递。&lt;&#x2F;p&gt;
&lt;p&gt;MAC：负责点到点的局域网内传输，确保数据在当前局域网内送到正确设备（比如你家电脑到路由器）。它像小区快递员，只管本地投递，不关心包裹从哪来、去哪。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;httpxie-yi&quot;&gt;HTTP协议&lt;&#x2F;h2&gt;
&lt;p&gt;首先HTTP是一种应用层协议&lt;&#x2F;p&gt;
&lt;p&gt;其次协议约定了双方的_通信规范_ 也就是，&lt;em&gt;客户端和服务端&lt;&#x2F;em&gt; 遵循这套协议 也就称之为 &lt;em&gt;http请求 http响应&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在客户端（如浏览器）和服务器之间，通过交换文本（或二进制）消息来完成资源传输&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP&#x2F;1.x 使用纯文本格式，便于人类阅读和调试&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP2 改为二进制&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;无状态(服务器不会记得之前的请求，每次的请求都是独立的)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;早期 HTTP&#x2F;1.0：每个请求结束后断开 TCP 连接（性能极差）。&lt;&#x2F;p&gt;
&lt;p&gt;HTTP 本身无连接，但实际依赖 TCP 的长连接优化性能。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;请求-响应模型（Request-Response）(主动请求，被动响应)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;服务器无法主动推送数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;如何主动推送呢？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;WebSocket， 轮询（todo）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;httpxiao-xi&quot;&gt;HTTP消息&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;起始行：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;GET &#x2F; index.html HTTP&#x2F;1.1(请求行)&lt;&#x2F;li&gt;
&lt;li&gt;HTTP&#x2F;1.1 200 ok(状态行)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;头部：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;（键值对形式）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Host: example.com&lt;&#x2F;li&gt;
&lt;li&gt;Content-Type: text&#x2F;html&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;正文&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;实际传输的数据&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;所以HTTP向下传递到传输层之前 传输的是文本的二进制？ 那么HTTP2的二进制又是什么意思呢？ 如果按照这样HTTP1.x不也是按照二进制传输的吗&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;无论是 HTTP&#x2F;1.x 还是 HTTP&#x2F;2，最终在网络上传输的都是二进制数据&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;但两者的关键差异在于 协议本身的组织方式，而非是否转为二进制&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;HTTP1.x：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;64d01640-7e8a-400d-baaa-b77086866e61&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;HTTP2：&lt;&#x2F;strong&gt; 以二进制帧（Frame）格式定义协议（所有消息被拆分为二进制结构）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;cf3f3ea3-2076-48de-b4fb-1f2423219b38&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;就是说HTTP1.x 将文本格式转化成ASCII码传输
HTTP2 将文本格式转换成二进制帧！ 更轻量&lt;&#x2F;p&gt;
&lt;h4 id=&quot;an-quan-xing&quot;&gt;安全性&lt;&#x2F;h4&gt;
&lt;p&gt;HTTPS： 在 HTTP 和 TCP 之间加入 TLS&#x2F;SSL 加密层&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;TLS&#x2F;SSL 又是什么？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;content-type-ben-zhi-yu-zuo-yong&quot;&gt;Content-Type：本质与作用&lt;&#x2F;h4&gt;
&lt;p&gt;本质：“这段二进制数据（或文本）应该如何被解析和处理？”&lt;&#x2F;p&gt;
&lt;p&gt;解决数据格式的歧义&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tcpxie-yi&quot;&gt;TCP协议&lt;&#x2F;h2&gt;
&lt;p&gt;位于传输层的 提供 &lt;em&gt;可靠的 面向连接的&lt;&#x2F;em&gt; 数据传输服务&lt;&#x2F;p&gt;
&lt;p&gt;解决如何在_不可靠的IP网络_上实现可靠的数据传输&lt;&#x2F;p&gt;
&lt;p&gt;早期的应用层 直接 对接传输层 导致ip协议无法区分数据应该交付给哪个应用&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duan-kou-hao-de-yin-ru&quot;&gt;端口号的引入&lt;&#x2F;h3&gt;
&lt;p&gt;IP 地址只能定位到主机，无法区分主机上哪个程序&#x2F;服务在通信，如果没有端口号，数据包到达主机后，主机不知道该发给哪个程序 所以在传输层引入了端口号 &lt;em&gt;实现进曾间通信的隔离&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti-4&quot;&gt;问题：&lt;&#x2F;h3&gt;
&lt;p&gt;怎么理解？&lt;&#x2F;p&gt;
&lt;p&gt;IP 协议处理的是独立的数据包（Packet），而应用层通常需要连续的字节流（如文件传输）&lt;&#x2F;p&gt;
&lt;p&gt;IP 数据包是网络中传输的基本单位&lt;&#x2F;p&gt;
&lt;p&gt;源&#x2F;目的 IP 地址（从哪里来，到哪里去）。&lt;&#x2F;p&gt;
&lt;p&gt;载荷（Payload）：实际要传输的数据片段（如一个文件的一部分）。&lt;&#x2F;p&gt;
&lt;p&gt;头部控制信息（如 TTL、校验和）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;核心冲突：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;IP层的“独立性”和应用层的“连续性”是天然对立的需求：&lt;&#x2F;p&gt;
&lt;p&gt;IP不保证顺序 → 但应用层需要顺序。&lt;&#x2F;p&gt;
&lt;p&gt;IP可能丢包 → 但应用层需要完整。&lt;&#x2F;p&gt;
&lt;p&gt;这种矛盾需要通过传输层（如TCP）解决，而不是让应用层直接处理IP包&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;核心特性：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可靠性：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;流量控制&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;全双工通信&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
      </item>
      <item>
          <title>记忆不是复读机</title>
          <pubDate>Mon, 23 Jun 2025 09:14:47 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-27/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-27/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-27/">&lt;h1 id=&quot;li-jie-lei-bi&quot;&gt;理解类比&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;9909e7a1-4867-4ad1-b087-b1b432509271&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lei-bi-si-xiang&quot;&gt;类比思想：&lt;&#x2F;h2&gt;
&lt;p&gt;类比思想是： &lt;em&gt;利用已知事物的特点理解新事物&lt;&#x2F;em&gt;，减少学习成本&lt;&#x2F;p&gt;
&lt;p&gt;学习新知识时：&lt;&#x2F;p&gt;
&lt;p&gt;可以这么去想，联系已知的概念，大体可以这么运用：&lt;&#x2F;p&gt;
&lt;p&gt;学习电路时，将电流比作水流，电压比作水压&lt;&#x2F;p&gt;
&lt;p&gt;理解原子结构时，用太阳系行星绕太阳运行来类比电子绕原子核运动&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h2&gt;
&lt;p&gt;怎么知道自己的类比是否正确？ 或者得体？ 如果不恰当的类比并且有可能错误的类比会造成误会吧！&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yuan-shi-gai-nian-yuan-ze&quot;&gt;原始概念原则&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;b73092cf-030e-4c40-8f07-d6c7333197f0&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;所有逻辑推导都建立在无需证明的&quot;公理&quot;（或原始概念）之上，就像盖房子需要地基。 越底层的概念越需要直接记忆并形成直觉反应（如看到&quot;+&quot;立刻想到&quot;相加&quot;）。高层定义（如极限）由底层符号（如∀、∃）组合而成，类似编程语言的&quot;从机器码到高级语法&quot;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;思考方向：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;遇到新概念时追问：&quot;这个定义依赖哪些更基础的概念？&quot;
（例如&quot;导数&quot;依赖&quot;极限&quot;，&quot;极限&quot;依赖&quot;∀∃&quot;）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;但不应该：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;试图把&quot;点&quot;再分解为&quot;更小的点&quot;（违反不可再分性），&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;总结为：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;原始概念是思维的地基。理解任何领域时，先识别其最底层的&quot;逻辑字母表&quot;，通过刻意练习将其内化为直觉，才能高效构建知识大厦。这正是数学家希尔伯特所说的：&quot;数学的基础不是水泥，而是透明的晶体。&quot;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ji-yi-de-yuan-shi-gai-nian&quot;&gt;记忆的原始概念&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;070d780c-b5c8-4514-8fd2-9f72d8526d84&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;构成人类逻辑思维基础的、最底层的记忆单位&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-yi-yuan-yu-de-fen-lei-he-te-zheng&quot;&gt;记忆源于的分类和特征&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;对象记忆：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;可独立识别的逻辑个体&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;数学中的&quot;变量x&quot;&lt;&#x2F;p&gt;
&lt;p&gt;语言中的&quot;单词apple&quot;&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;关系记忆&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对象间的逻辑关联&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;数学中的&quot;x &amp;gt; y&quot;&lt;&#x2F;p&gt;
&lt;p&gt;语言中的&quot;主语-谓语&quot;结构&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;约束规则&quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;_强制性：_只要前提A→B和A为真，B必须为真，否则逻辑系统自相矛盾。&lt;&#x2F;p&gt;
&lt;p&gt;_不可违反性：_这是逻辑推理的基石，类似数学中的&quot;1+1=2&quot;。&lt;&#x2F;p&gt;
&lt;p&gt;_传递性：_通过A→B和B→C，可进一步推出A→C（假言三段论）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;给抽象概念赋予具体属性：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如将逻辑命题P想象成一个&quot;可开关的灯泡&quot;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;但不应该：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;试图用高层概念（如&quot;定理&quot;）解释原始对象（如&quot;变量&quot;），只背单词不练句法，导致无法实际应用&lt;&#x2F;p&gt;
&lt;h1 id=&quot;li-jie-ji-yi-fa&quot;&gt;理解记忆法：&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;1664152e-7089-44b7-83c2-16412f3f399e&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;若直接记忆极限的保序性定理（如公式所示），而不理解其底层逻辑（极限定义、量词含义等），会导致：&lt;&#x2F;p&gt;
&lt;p&gt;记忆负担重（像背随机字符串）&lt;&#x2F;p&gt;
&lt;p&gt;缺乏应用直觉（无法灵活推导）&lt;&#x2F;p&gt;
&lt;p&gt;产生认知焦虑（总担心遗漏条件）&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;如果对极限的理解全来源于定理而非源头含义，会陷入‘考虑不周全’的担忧。&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;jie-jue&quot;&gt;解决：&lt;&#x2F;h2&gt;
&lt;p&gt;分层拆解与逻辑构建&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;实际使用：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;遇到新定理时，列出其中所有符号和关系：
&quot;这个‘∃’是什么意思？‘→’如何作用？&quot;&lt;&#x2F;p&gt;
&lt;p&gt;若发现未掌握的底层概念（如不懂极限定义），优先补足。&lt;&#x2F;p&gt;
&lt;p&gt;尝试用底层逻辑重新推导定理，而非直接背诵。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;注意避免：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以为“看懂了”就是“会用了”（需通过推导练习检验）&lt;&#x2F;p&gt;
&lt;p&gt;试图将公理再分解（如追问“为什么1+1=2”）&lt;&#x2F;p&gt;
&lt;p&gt;理解记忆法是通过知识网络化取代信息点状化&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;总结为：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;理解记忆法是通过知识网络化取代信息点状化。如同建造金字塔——底层石块（原始概念）越稳固，上层结构（高阶定理）越容易搭建。这正是数学家庞加莱所言：“逻辑是证明的工具，直觉是发明的工具。”而理解记忆，正是二者的桥梁&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“记忆不是复读机，而是创造性的重构。”真正的学习，是让知识在你的大脑中活起来。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</description>
      </item>
      <item>
          <title>理解char **argv</title>
          <pubDate>Sat, 21 Jun 2025 13:37:03 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-26/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-26/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-26/">&lt;p&gt;首先的困惑就像下述链接描述的一样：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.quora.com&#x2F;What-is-the-difference-between-char-*-argv-and-char-argv&quot;&gt;char *argv[] &amp;amp;&amp;amp; char **argv&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;char *argv[]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这是指向 char 的指针数组 。数组中的每个元素都是一个指针，它指向一个字符串（一个字符序列）。&lt;&#x2F;p&gt;
&lt;p&gt;常用于 main 函数的上下文中 ，以处理命令行参数。它通常定义为 &lt;em&gt;int main(int argc, char *argv[])&lt;&#x2F;em&gt; 或 &lt;em&gt;int main(int argc, char **argv)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;char *argv[]&lt;&#x2F;em&gt; 用于表示多个字符串（命令行参数），而 char argv[] 表示单个字符串（字符数组）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;printf(&amp;quot;%s\n&amp;quot;, argv[0]);  sh 正确：打印整个字符串
printf(&amp;quot;%c\n&amp;quot;, argv[0]);  未定义行为（可能乱码&amp;#x2F;崩溃） | 错误：%c 需要 char，但 argv[0] 是 char*
printf(&amp;quot;%c\n&amp;quot;, argv[0][0]);  正确：打印字符串的第一个字符
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;text&quot; class=&quot;language-text &quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;地址 0x1000: &amp;#x27;s&amp;#x27;
地址 0x1001: &amp;#x27;h&amp;#x27;
地址 0x1002: &amp;#x27;\0&amp;#x27; (字符串结束符)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;printf 的 %s 格式化符号的工作原理：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;它期望一个 char&lt;&#x2F;em&gt; 类型的参数&lt;&#x2F;em&gt;*（即字符串的起始地址）。&lt;&#x2F;p&gt;
&lt;p&gt;从该地址开始，逐个字符打印，直到遇到 \0（NULL 终止符）。&lt;&#x2F;p&gt;
&lt;p&gt;它 自动解引用指针，并持续向后读取内存，直到 \0。&lt;&#x2F;p&gt;
&lt;p&gt;等价&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;char *ptr = argv[0];  &amp;#x2F;&amp;#x2F; ptr 指向 &amp;quot;sh&amp;quot; 的首地址
while (*ptr != &amp;#x27;\0&amp;#x27;) {
    putchar(*ptr);    &amp;#x2F;&amp;#x2F; 打印当前字符
    ptr++;           &amp;#x2F;&amp;#x2F; 移动到下一个字符
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
      <item>
          <title>good_first_issue</title>
          <pubDate>Sat, 21 Jun 2025 08:39:28 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-25/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-25/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-25/">&lt;h1 id=&quot;chang-shi-jie-jue-ren-sheng-de-di-yi-ge-issue&quot;&gt;尝试解决人生的第一个issue&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-clippy&#x2F;issues&#x2F;3219&quot;&gt;rust-clippy&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这个issue的由来大概是StackOverFlow中的一个人的疑惑&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;48361537&#x2F;why-do-underscore-prefixed-variables-exist&#x2F;48370313#48370313&quot;&gt;Stackoverflow&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;大概内容是：&lt;&#x2F;p&gt;
&lt;p&gt;&quot;rust 现在变量名称的开头添加下划线将使编译器在未使用时不会发出警告， 未使用的变量可能是不受欢迎的！&quot;&lt;&#x2F;p&gt;
&lt;p&gt;要解决的问题： 添加一个lint&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
  used_underscore_but_unused(42);
}

&amp;#x2F;&amp;#x2F; ⚠️ `_param` 没用，但以 `_` 开头（我们想让它被 lint 出来）
fn used_underscore_but_unused(_param: i32) {
  println!(&amp;quot;just doing nothing with param&amp;quot;);
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当前输出：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;PS E:\rust-demo\src&amp;gt; cargo clippy -- -W unused_variables -W clippy::used_underscore_binding -D warnings
    Checking rust-demo v0.1.0 (E:\rust-demo)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s  
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;问题可能比想象的要复杂：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;acb302e2-221e-4746-a3b2-470de5808c01&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这是社区的回复，我可能要先释放这个issue了&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>工具链</title>
          <pubDate>Fri, 20 Jun 2025 12:28:01 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-24/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-24/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-24/">&lt;h1 id=&quot;shen-me-shi-gong-ju-lian&quot;&gt;什么是工具链&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;从源码出发，支持你完成开发、构建、测试、调试、部署的完整过程&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;**编译构建：**把源码变成可运行的程序（如 cargo build、go build）&lt;&#x2F;p&gt;
&lt;p&gt;**依赖管理：**统一管理三方库版本、下载、更新（如 go mod、Cargo.toml）&lt;&#x2F;p&gt;
&lt;p&gt;**代码质量保证：**自动化测试、格式化、静态检查（如 cargo test、clippy）&lt;&#x2F;p&gt;
&lt;p&gt;**调试和发布支持：**调试运行、打包部署、发布（如 cargo run --release）&lt;&#x2F;p&gt;
&lt;p&gt;##理解指令&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;go build&lt;&#x2F;em&gt; &lt;em&gt;go mod init&lt;&#x2F;em&gt; &lt;em&gt;cargo build&lt;&#x2F;em&gt; 等指令做了什么事情？&lt;&#x2F;p&gt;
&lt;p&gt;_go.mod_是做什么的，如果没有会怎么样？&lt;&#x2F;p&gt;
&lt;p&gt;go.mod 记录了模块名和依赖项&lt;&#x2F;p&gt;
&lt;p&gt;go build
编译当前模块的代码，生成可执行文件。&lt;&#x2F;p&gt;
&lt;p&gt;如果没有 go.mod：&lt;&#x2F;p&gt;
&lt;p&gt;无法使用模块化依赖（Go 1.11+推荐模块模式）&lt;&#x2F;p&gt;
&lt;p&gt;Go 会尝试用 GOPATH 模式构建（已逐渐废弃）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mo-kuai-hua-yi-lai&quot;&gt;模块化依赖&lt;&#x2F;h2&gt;
&lt;p&gt;每个模块只关心自己需要的依赖和版本，互不干扰。&lt;&#x2F;p&gt;
&lt;p&gt;例子：
项目 A 用的是 viper v1.9.0，项目 B 用的是 viper v1.8.1，互不冲突。
不像老的 GOPATH 模式下，全局只有一份依赖，项目之间可能“踩版本”。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>地址和字节的关系</title>
          <pubDate>Thu, 19 Jun 2025 09:00:13 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-23/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-23/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-23/">&lt;p&gt;&lt;strong&gt;问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;理解一下2的32次方的含义是什么？ 我的理解是 2的32次方代表着 它可以表示2的32次方个数据？ 我不理解他跟B有什么关系！&lt;&#x2F;p&gt;
&lt;p&gt;如果一个地址对应 1 个字节（Byte），那总共能表示 2的32次方个字节！&lt;&#x2F;p&gt;
&lt;p&gt;现在虚拟内存地址：地址范围的个数 = 可访问的字节数&lt;&#x2F;p&gt;
&lt;p&gt;所以2的32次方 = 4GB内存空间&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;所以就是：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;每个地址指向1字节， 如果我有一个int型的变量a 他现在存储8 它的字节数是4字节是吧？ 我打印a变量的地址最终会输出一个类似于 0x0192730098这样的一个地址，所以说 这一个地址代表一个B？&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;是的，这个地址代表的是“a变量所占内存的第1个字节”的地址。 所以 &amp;amp;a 返回的是 a 的“起始字节地址”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;int 占 4 字节 ⇒ 实际用了连续的 4 个地址&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dan-ji-ye-biao&quot;&gt;单级页表&lt;&#x2F;h2&gt;
&lt;p&gt;32位内存：&lt;&#x2F;p&gt;
&lt;p&gt;2的32次方 = 4GB 虚拟内存&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;理解虚拟内存 和 主存的概念：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;32位系统的虚拟地址空间最大只能访问 4GB 的内存（也就是每个进程最多可以用4GB），但你的物理内存（主存）可以比这大，比如16GB；只是你用不满而已。&lt;&#x2F;p&gt;
&lt;p&gt;页大小4KB： 总空间&#x2F;页大小 = 页个数（2的20次方） 每个页必须都能被找到 就需要_2的20次方个PTE（PTE大小为4字节（32位））_去定位物理地址 总大小就变成了 4MB&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ru-he-kan-dai-duo-ji-ye-biao&quot;&gt;如何看待多级页表&lt;&#x2F;h2&gt;
</description>
      </item>
      <item>
          <title>go-redis使用</title>
          <pubDate>Sun, 15 Jun 2025 12:57:28 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-22/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-22/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-22/">&lt;h1 id=&quot;redis&quot;&gt;Redis&lt;&#x2F;h1&gt;
&lt;p&gt;高性能内存数据库：&lt;&#x2F;p&gt;
&lt;p&gt;为解决传统数据库在高并发和低延迟场景下的性能瓶颈&lt;&#x2F;p&gt;
&lt;p&gt;传统数据库 I&#x2F;O 慢，不适合做高频缓存&lt;&#x2F;p&gt;
&lt;p&gt;Memcached 只支持简单的 key-value，不能表达复杂业务&lt;&#x2F;p&gt;
&lt;p&gt;项目中很多需求本质上是“操作数据结构”：列表、集合、计数器等&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-yao-cao-zuo-shu-ju-jie-gou&quot;&gt;为什么要操作数据结构？&lt;&#x2F;h2&gt;
&lt;p&gt;展示出最近的10条评论&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;SELECT * FROM comments WHERE post_id = ? ORDER BY created_at DESC LIMIT 10 OFFSET x&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;redisnei-zhi-shu-ju-jie-gou&quot;&gt;Redis内置数据结构：&lt;&#x2F;h2&gt;
&lt;p&gt;（String、Hash、List、Set、Sorted Set 等）&lt;&#x2F;p&gt;
&lt;p&gt;根据情况 &lt;strong&gt;选择合适的数据结构&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;字符串&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;缓存用户姓名：SET user:1:name &quot;Alice&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;页面访问计数：INCR page:views.&lt;&#x2F;p&gt;
&lt;p&gt;数据量小，操作简单（读写、增减）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Hash（哈希）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;存储用户信息：HSET user:1 name &quot;Alice&quot; age 25.&lt;&#x2F;p&gt;
&lt;p&gt;更新年龄：HSET user:1 age 26.&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;List（列表）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;任务队列：LPUSH tasks &quot;send_email&quot;，RPOP tasks.&lt;&#x2F;p&gt;
&lt;p&gt;最近浏览记录：LPUSH user:1:history &quot;item1&quot;, LTRIM user:1:history 0 9（保留最近 10 条）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Set（集合）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;用户标签：SADD user:1:tags &quot;tech&quot; &quot;sports&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;共同好友：SINTER user:1:friends user:2:friends.&lt;&#x2F;p&gt;
&lt;p&gt;用 Set 实现推荐系统（比如推荐共同兴趣的用户）。&lt;&#x2F;p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Sorted Set（有序集合）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;游戏排行榜：ZADD leaderboard 100 &quot;Alice&quot;.&lt;&#x2F;p&gt;
&lt;p&gt;获取前 3 名：ZREVRANGE leaderboard 0 2.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h2&gt;
&lt;p&gt;“如何用 Redis 做缓存？”（String&#x2F;Hash）&lt;&#x2F;p&gt;
&lt;p&gt;“如何实现消息队列？”（List）&lt;&#x2F;p&gt;
&lt;p&gt;“如何设计排行榜？”（Sorted Set）&lt;&#x2F;p&gt;
&lt;p&gt;为什么选这个数据结构？ 它的优点！&lt;&#x2F;p&gt;
&lt;p&gt;##问题&lt;&#x2F;p&gt;
&lt;p&gt;为什么redis可以操作列表等数据结构呢？ 它的底层就是一个哈希表吗？&lt;&#x2F;p&gt;
&lt;p&gt;Redis 的全局键值存储是基于哈希表（Dict）&lt;&#x2F;p&gt;
&lt;p&gt;全局哈希表只存储「键」和「值的指针」&lt;&#x2F;p&gt;
&lt;p&gt;对于Redis 不同数据类型有不同的底层实现&lt;&#x2F;p&gt;
&lt;p&gt;实际上：&lt;&#x2F;p&gt;
&lt;p&gt;以 &lt;em&gt;LPUSH mylist A&lt;&#x2F;em&gt; 为例：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查找 Key：先在全局哈希表中查找 &quot;mylist&quot;：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果不存在，创建一个新的 List（底层可能是 QuickList）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果存在，拿到指向 List 的指针。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;操作数据结构：调用 QuickList 的插入逻辑，在头部插入 &quot;A&quot;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
      </item>
      <item>
          <title>数据库</title>
          <pubDate>Fri, 13 Jun 2025 13:21:31 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-21/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-21/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-21/">&lt;h1 id=&quot;shu-ju-ku-zhi-shi-shu-li&quot;&gt;数据库知识梳理&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shen-me-shi-shu-ju-ku&quot;&gt;什么是数据库？&lt;&#x2F;h2&gt;
&lt;p&gt;数据的仓库 高效的保存和查询数据&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-yao-bao-cun-he-cha-xun-shu-ju-ru-he-bao-zheng-shu-ju-bei-zheng-chang-cun-chu-he-ru-he-cha-xun-shu-ju&quot;&gt;为什么要 保存和查询数据  如何保证数据被正常存储 和 如何查询数据？&lt;&#x2F;h2&gt;
&lt;p&gt;保存数据：系统能长期使用和分析这些数据，&lt;&#x2F;p&gt;
&lt;p&gt;查询数据： 用户能根据条件快速找出需要的信息&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;如何保证数据正确被保存和正确的查询数据？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;数据库事务&lt;&#x2F;li&gt;
&lt;li&gt;约束&lt;&#x2F;li&gt;
&lt;li&gt;日志&lt;&#x2F;li&gt;
&lt;li&gt;数据备份&lt;&#x2F;li&gt;
&lt;li&gt;DBMS&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shen-me-shi-shu-ju-ku-shi-wu&quot;&gt;什么是数据库事务&lt;&#x2F;h2&gt;
&lt;p&gt;保证一组操作要么全部成功、要么全部失败的机制，核心用于&lt;strong&gt;保证数据一致性。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;事务的四大特性：&lt;&#x2F;p&gt;
&lt;p&gt;ACID&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;为什么事务可以避免并发冲突？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;隔离机制： 数据库的隔离级别 + 锁机制&lt;&#x2F;p&gt;
&lt;p&gt;事务的隔离级别：&lt;&#x2F;p&gt;
&lt;p&gt;自上向下 性能由高到低&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交：虽然级别最低 但也有它的作用。实时监控数据的变化， 对数据一致性要求不严格，允许读到脏数据但能换取速度。&lt;&#x2F;li&gt;
&lt;li&gt;读已提交 ： 事务只能读导已经提交的数据（避免脏读）&lt;&#x2F;li&gt;
&lt;li&gt;可重复读 ：在事务内对同一行多次读取是一样的（其他事务不能修改）&lt;&#x2F;li&gt;
&lt;li&gt;可串行化： 对读的范围加 锁 拒绝其它插入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;dui-yu-ke-zhong-fu-du&quot;&gt;对于可重复读&lt;&#x2F;h2&gt;
&lt;p&gt;在 可重复读隔离级别下，一个事务在开始后所读取的数据会基于快照，一直一致，同一条记录无论读多少次，看到的都是事务开始时的版本，即使其他事务已经修改并提交了这条记录。每个事务会生成一个快照版本号，之后所有查询都基于这个版本读取；不会加锁，但能保证多次读取一致（除非手动加锁，无法防幻读）；&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;对于可串行化：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在某些数据库（如 MySQL）用强锁机制实现。&lt;&#x2F;p&gt;
&lt;p&gt;在 PostgreSQL 中通过MVCC + 并发冲突检测（SSI）实现，更智能但也有事务被中止的风险。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dui-yu-huan-du-qing-kuang&quot;&gt;对于幻读情况&lt;&#x2F;h2&gt;
&lt;p&gt;出现了**“幻影数据”** → 第二次出现了之前“范围里没有”的新行 → 这就是幻读。为什么可重复读 不能 避免幻读？ MVCC快照机制 只保证读过的记录内容不变，没读过的新行还是可以看到！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;所以可以使用 锁！避免Serializable隔离级别带来的严重性能差&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;所以对于锁的使用时机，如何正确的使用锁，死锁？ 等一些情况 需要对锁有一定的了解和调试！&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;所以&lt;strong&gt;Serializable&lt;&#x2F;strong&gt;的问题 时性能问题！ 只需要开发者修改一下隔离级别，就行轻松避免 脏读等问题！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;并发事务产生的问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;脏读&lt;&#x2F;em&gt;： 读到未提交的数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;不可重复读&lt;&#x2F;em&gt;： 同一次查询 两次读的结果不同&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;序列化异常&lt;&#x2F;em&gt;： 成功提交一组事务的结果与一次运行这些事务的所有可能顺序不一致。&lt;&#x2F;p&gt;
&lt;p&gt;疑惑： 不可重复读 怎么了？ A读100 b修改为50 再次读取不应该就是50吗 难道还要让他读到100？&lt;&#x2F;p&gt;
&lt;p&gt;解答： 在事务A未提交时，事务B提交了修改，导致事务A中同一数据多次读取结果不一致，破坏了事务的隔离性，可能导致逻辑错误或数据不稳定。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;幻读&lt;&#x2F;em&gt;： 查询范围内数据被别人新增&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h2&gt;
&lt;p&gt;假设账户初始余额是 100，有两个事务并发执行：&lt;&#x2F;p&gt;
&lt;p&gt;事务 A：读余额 → 如果 ≥100，则扣 100&lt;&#x2F;p&gt;
&lt;p&gt;事务 B：读余额 → 如果 ≥100，则扣 100&lt;&#x2F;p&gt;
&lt;p&gt;如果没有串行控制，两者几乎同时读到 100，都满足条件，各自扣 100，最终余额变成 -100！&lt;&#x2F;p&gt;
&lt;p&gt;Serializable的隔离级别可以让数据库检测到并发冲突，强制回滚其中一个事务，性能会大大折扣&lt;&#x2F;p&gt;
&lt;p&gt;Serializable的工作原理：&lt;&#x2F;p&gt;
&lt;p&gt;事务之间如果有“不可串行化的依赖”，就会强制让一个事务回滚；&lt;&#x2F;p&gt;
&lt;p&gt;PostgreSQL 的 Serializable 是通过 检测事务冲突图 实现的（SSI），不是加锁；&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-ju-ku-suo-ji-zhi&quot;&gt;数据库锁机制&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;cun-chu-yin-qing&quot;&gt;存储引擎&lt;&#x2F;h2&gt;
&lt;p&gt;负责存储、处理和检索数据的核心组件&lt;&#x2F;p&gt;
&lt;p&gt;应对不同的场景 ， 不同的场景会用到不同的存储引擎&lt;&#x2F;p&gt;
&lt;p&gt;数据的物理结构 ， 索引 ， 查询的实现方式&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pgxiang-bi-yu-mysql&quot;&gt;PG相比于MYSQL&lt;&#x2F;h2&gt;
&lt;p&gt;Postgres：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;MVCC（多版本并发控制）： PostgreSQL 使用 MVCC 来实现事务隔离，通过为每个事务创建数据快照（版本）来避免读写冲突，默认隔离级别是读已提交，但可轻松配置为可重复读或串行化。

行级锁：

死锁检测：
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
      <item>
          <title>一些前沿资料获取</title>
          <pubDate>Thu, 12 Jun 2025 07:13:07 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-20/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-20/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-20/">&lt;p&gt;获取前沿资料&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;&quot;&gt;ACM&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.nature.com&#x2F;&quot;&gt;Nature&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.sigplan.org&#x2F;&quot;&gt;SIGPLAN编程语言博客&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;scholar.google.de&#x2F;&quot;&gt;Google学术搜索&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;list&#x2F;cs.PL&#x2F;recent&quot;&gt;arXiv编程语言文论&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dev.golang.org&#x2F;&quot;&gt;Go官方文档&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&quot;&gt;Go语言Github&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go-review.googlesource.com&quot;&gt;Go代码审查&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;x.com&#x2F;&quot;&gt;Twitter&#x2F;X平台&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;reddit&#x2F;r&#x2F;golang&quot;&gt;Reddit Go社区&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&quot;&gt;Go技术讨论组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev&quot;&gt;Go开发组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-tools&quot;&gt;Go工具组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>Golang In Deep</title>
          <pubDate>Wed, 11 Jun 2025 12:49:51 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-19/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-19/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-19/">&lt;h1 id=&quot;gmpmo-xing&quot;&gt;GMP模型&lt;&#x2F;h1&gt;
&lt;p&gt;首先思考 GMP调度模型是什么？ 为了解决什么问题？&lt;&#x2F;p&gt;
&lt;p&gt;引出下文：&lt;&#x2F;p&gt;
&lt;p&gt;GMP是 Go runtime的一个调度模型， 调度模型是什么？ Go runtime是什么？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Go runtime：&lt;&#x2F;strong&gt; Go runtime 是 Go 语言自带的一套 运行时系统。&lt;&#x2F;p&gt;
&lt;p&gt;他自己有一套功能：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;GMP调度器&lt;&#x2F;li&gt;
&lt;li&gt;垃圾回收GC&lt;&#x2F;li&gt;
&lt;li&gt;系统调用封装 等&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;因为GO需要自己管理这些情况 所以需要内置 runtime&lt;&#x2F;p&gt;
&lt;p&gt;**调度模型： **系统如何决定“哪个任务（线程、协程）由哪个 CPU 在什么时候执行”的策略和机制。&lt;&#x2F;p&gt;
&lt;p&gt;Go 调度器运行在用户态，负责调度 goroutine 到 Go 自己维护的 M（线程） 上。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-shen-me-goroutineqie-huan-bi-xian-cheng-qing-liang&quot;&gt;为什么goroutine切换比线程轻量？&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;线程就是操作系统里执行代码的最小单位。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;首先清楚： &lt;em&gt;上下文越大，切换开销越大（保存&#x2F;恢复更多信息）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xian-cheng-shi-bing-fa-bian-cheng-de-ji-chu&quot;&gt;线程是并发编程的基础&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;线程内代码按顺序执行。多个线程通过 CPU 多核或调度实现任务并行或并发，提高效率。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;回到最初！因为os线程的并发下 开销大！ 所以Go设计了用户级goruntine 目前的问题就是 如何&lt;strong&gt;把成千上万的goroutine 高效的调度到有限的os上&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;用户级别的协程确实在开销上非常小 目前的问题就是 如何将协程和线程连接起来 从而让真正的CPU去工作&lt;&#x2F;p&gt;
&lt;p&gt;Goroutine的执行条件是什么？&lt;&#x2F;p&gt;
&lt;p&gt;CPU状态 任务队列 本地缓存 调度信息&lt;&#x2F;p&gt;
&lt;p&gt;这些环境谁来提供？&lt;&#x2F;p&gt;
&lt;p&gt;p！&lt;&#x2F;p&gt;
&lt;p&gt;p 管理能运行多少个G 协调 本地队列 与 全局队列&lt;&#x2F;p&gt;
&lt;p&gt;谁来维护p？&lt;&#x2F;p&gt;
&lt;p&gt;CPU核数 限制了 p的数量&lt;&#x2F;p&gt;
&lt;p&gt;M 是操作系统的线程，是实际能被 CPU 调度执行的实体 M必须绑定p 才能执行G&lt;&#x2F;p&gt;
&lt;p&gt;P调度G M执行G&lt;&#x2F;p&gt;
&lt;p&gt;为什么 只有绑定P才能执行G 早期没有P是如何运行的？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mru-he-zhi-jie-diao-du-g&quot;&gt;M如何直接调度G&lt;&#x2F;h2&gt;
&lt;p&gt;有哪些缺点?&lt;&#x2F;p&gt;
&lt;p&gt;M 同时负责调度和执行，导致调度逻辑复杂且不够高效。 容易出现资源竞争和瓶颈。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fa-sheng-zu-sai-zen-me-ban&quot;&gt;发生阻塞怎么办&lt;&#x2F;h2&gt;
&lt;p&gt;什么会发生阻塞？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;I&#x2F;O阻塞：&lt;&#x2F;strong&gt; 程序必须完成某个程序的输入输出 才能执行后续的代码&lt;&#x2F;p&gt;
&lt;p&gt;M属于内核级别 M发生系统调用 M会被操作系统挂起，进入阻塞状态&lt;&#x2F;p&gt;
&lt;p&gt;Go检测到阻塞就会就会让M释放P 创建或唤醒另一个M去绑定这个P然后执行G，被挂起的 M 等调用完成后再尝试回收利用。&lt;&#x2F;p&gt;
&lt;p&gt;Go的runtime做法， 发现这个G是阻塞的 就从当前M中剥离这个G 然后G标记waiting 把p解绑 交给别的M&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xi-tong-diao-yong-wei-shen-me-hui-zu-sai&quot;&gt;系统调用为什么会阻塞&lt;&#x2F;h3&gt;
&lt;p&gt;运行在用户态 去请求 系统内核的某些权限!(文件读写， 网络通信，进程管理)&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取磁盘文件可能需要等待磁盘控制器返回数据&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;网络 I&#x2F;O：接收网络数据（如 net.Conn.Read）需要等待客户端发送数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;进程同步：如 waitpid 等待子进程退出。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;yi-huo&quot;&gt;疑惑：&lt;&#x2F;h3&gt;
&lt;p&gt;所以说 系统调用 为什么会阻塞？ 如果当系统调用需要从磁盘读取数据的时候 线程去执行其它资源，然后等数据返回再去执行，这样不就大大提高了利用率吗？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hui-da&quot;&gt;回答:&lt;&#x2F;h3&gt;
&lt;p&gt;这个问题就是&lt;strong&gt;同步阻塞I&#x2F;O模型&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;让线程去做别的事情就是 &lt;strong&gt;异步非阻塞模型:&lt;&#x2F;strong&gt; 这样一个线程可以管理成千上万个 I&#x2F;O 连接，提高吞吐量。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>与北邮老哥的交谈</title>
          <pubDate>Tue, 10 Jun 2025 11:26:59 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-18/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-18/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-18/">&lt;h1 id=&quot;mo-ni-mian-shi&quot;&gt;模拟面试&lt;&#x2F;h1&gt;
&lt;p&gt;2025-06-10日 老哥给我来了一个模拟面试，看到了自己的不足和欠缺&lt;&#x2F;p&gt;
&lt;p&gt;没有面试过真的不知道，面试官主要问的是什么，怎么问！&lt;&#x2F;p&gt;
&lt;p&gt;其实 &lt;strong&gt;简历是自己与面试官沟通的一个桥梁&lt;&#x2F;strong&gt; 根据简历，让面试官快速了解你，通过简历，能够知道问你什么知识！&lt;&#x2F;p&gt;
&lt;p&gt;对于项目的整体架构，流程，模块，功能是怎么了解的！技术选型是为什么？ 你所回答的每一个问题，都会成为面试官下一步的追问点，对于每一步
你应该有所准备有所了解！代码的编写能力，不能落下！&lt;&#x2F;p&gt;
&lt;p&gt;修改简历，为你真正能够回答的你所涉及的知识，而不是为了好看而去写上，但问你你却答不出来，反而成了减分项！&lt;&#x2F;p&gt;
&lt;p&gt;基础不行（数据结构和算法 操作系统 计算机网络） 对于下一步如何正确的学习，老哥给了我一些方法和建议，我认为非常有帮助！&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;pre&gt;&lt;code&gt;
我说一个学习的方式：提问-&amp;gt;解答-&amp;gt;再提问的方式：
首先提出一个问题，比如TCP是什么？

TCP是传输层的一种可靠传输协议

得到这个答案后，我自然想问：

传输层是什么？可靠传输协议又是什么?

传输层是OSI网络模型中，负责提供抽象通道的一层协议集
可靠传输协议能够保证该抽象通道的数据能够从通道A端完整可靠地到达B端

得到上面的解答后，我又能够提问：
OSI网络模型是什么？可靠传输协议有哪些？可靠传输怎么实现的？

OSI是一种将承担不同责任的基础设施分层，并按照不同层将各自的通信协议分类的模型
可靠传输协议最常见的是TCP，其他的我暂时不关心
可靠传输主要通过重传实现，也就是说如果数据没有发到，再发一次

怎么知道数据有没有发到？

如果B端接收到了A端的数据，会发送一个ack，表示收到

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如何&lt;strong&gt;判断&lt;&#x2F;strong&gt;对某个知识你是否真的&lt;strong&gt;理解了&lt;&#x2F;strong&gt;？&lt;&#x2F;p&gt;
&lt;p&gt;这真的很重要！&lt;&#x2F;p&gt;
&lt;p&gt;我自己的感受就是很多知识学习了，会忘，那种感觉很难受，反反复复的看，总是记不住，时间花出去了但是没有收获到什么！ 在被问道的时候什么也回答不上来！&lt;&#x2F;p&gt;
&lt;p&gt;也就是 &lt;strong&gt;有些东西你看懂了表面的行为，但是实际上并不理解本质&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cong-biao-ceng-kai-shi-si-kao&quot;&gt;从表层开始思考&lt;&#x2F;h2&gt;
&lt;p&gt;比如鉴权系统需要知道用户信息，否则就无法执行后续逻辑，那就是流程上存在数据依赖，如果是两台服务器提供并发服务，那么就是全局上要求两者的数据一致，但是&lt;strong&gt;只看通信&lt;&#x2F;strong&gt;就很好理解：数据从A到B，所以理解了一个简单易懂的机制后，学会追问为什么要这么做&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;说到底，没有记住的东西，一般是缺乏思考了&lt;&#x2F;strong&gt; &lt;em&gt;多问问自己，为了达到目的，我应该做什么？&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hua-ti-zhan-kai&quot;&gt;话题展开&lt;&#x2F;h2&gt;
&lt;p&gt;老哥说了关于粒度 和 维度 这词语在IT届 公司中很常用的词语，但是我确实不太理解是什么意思&lt;&#x2F;p&gt;
&lt;p&gt;什么是 &quot;切分数据“? 这是我从没有涉猎过的一个词语&lt;&#x2F;p&gt;
&lt;p&gt;_事物本质往往更抽象&lt;&#x2F;p&gt;
&lt;p&gt;具体的东西很好理解和学习，适合入门_&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;例如搜索：MVCC&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;你并不理解MVCC是什么！ 但是在网上搜索会有很多相关的文章， 实现大多是基于InnoDB，虽然你不知道是什么，但是&lt;strong&gt;文章中总是会将某个概念绑定到某个具体的实现&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;但实际上MVCC是一个抽象的概念它的作用是 ：要求多版本共存，事务隔离（引发思考：MVCC是什么？ 要达到什么要求？）为了实现这个要求，谁谁谁具体做了什么？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;对于TCP：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;传输是个抽象的概念，可靠的传输是个抽象的概念，落到TCP上就有了具体实现, 但是可靠传输不依赖TCP,所以写代码一般会先写接口&lt;&#x2F;p&gt;
&lt;p&gt;先约定接口，然后实现，这是一种思考方式!（&lt;strong&gt;实现能力，代码能力&lt;&#x2F;strong&gt;）&lt;&#x2F;p&gt;
&lt;p&gt;然后反过来，我们看到一个设计，反过来想为什么要这么设计，目的是什么(&lt;strong&gt;抽象能力&lt;&#x2F;strong&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;如果不懂某个概念应该去弄明白它的概念 ， 然后从AI给你的一堆：SQL中的切分、数学中的切分、数据工程中的切分等等中，找到具体事物的共性&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;看了一段话，想一下为什么是这样，如果不是这样呢？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;meml&quot;&gt;go从抽象的层面探讨并发编程的本质&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;慢慢啃，然后理解为什么会有锁、条件变量、channel各种并发原语，能不能用一种唯一的机制实现他们，为什么不用唯一的机制实现它们，等等&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;结合一点能激活大脑兴奋的事情&lt;&#x2F;strong&gt; ，看书陷入困惑是容易放弃思考&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;需要的时候选合适的章节过一遍 把疑惑点选出来 再通过各种能激发思考途径解决&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;改正自己从头读到尾的看一本书 ，知识学不完的&lt;&#x2F;p&gt;
&lt;p&gt;让自己的思维喜欢上思考！慢慢来&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>图片和视频的时空对话</title>
          <pubDate>Sun, 08 Jun 2025 07:20:43 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-16/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-16/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-16/">&lt;h1 id=&quot;you-gan-er-fa&quot;&gt;有感而发&lt;&#x2F;h1&gt;
&lt;p&gt;最近总是翻看相册中的图片和视频，引发了一些对过往记录的思考。&lt;&#x2F;p&gt;
&lt;p&gt;我相信，当你按下快门的那一刻，你是开心的。你想记录这一瞬间，想永远拥有这个时刻——于是你按下快门。大家都不例外，毕竟，谁也不会把不喜欢的照片存放在手机里。&lt;&#x2F;p&gt;
&lt;p&gt;但此刻，当我回看这些美好的影像，心里却五味杂陈。它们让我感慨时间的流逝，甚至渴望永远停留在某个瞬间——那种“再也回不去”的感觉愈发强烈。&lt;&#x2F;p&gt;
&lt;p&gt;图片和视频的冲击力是极强的。即使时隔多年，再次观看时，它们仍能瞬间唤醒记忆，那些美好仿佛就在眼前……可奇怪的是，我总会感到一丝失落。因为我发现，自己很难完全回到当时的心境，重现彼时的思绪。这感觉就像——你明明看得见，却永远无法真正重返那个时刻。它们能保存视觉，却无法封存其他因素：比如当时“雪的温度，风的刺骨，暖阳的照射，或是那一刻心跳的节奏。&lt;&#x2F;p&gt;
&lt;p&gt;影像既是记忆的钥匙，又是时间的证据——这种既亲近又疏离的张力，实在奇妙。&lt;&#x2F;p&gt;
&lt;p&gt;—— 2025.06.08&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>开源年会</title>
          <pubDate>Sat, 07 Jun 2025 12:56:15 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-15/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-15/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-15/">&lt;h1 id=&quot;yi-ci-shuo-zou-jiu-zou-de-lv-xing&quot;&gt;一次说走就走的旅行&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;kai-yuan-she&quot;&gt;开源社&lt;&#x2F;h2&gt;
&lt;p&gt;在偶然一次发现中 开源社举办了第九届中国开源年会，我很是激动，心中迅速萌发了去北京参加的冲动并和小伙伴赵冰
决定这周五来一次说走就走的旅行~~~ 时间也是非常紧迫 只有两天，从辽宁到北京！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;77ce0e61-2787-4368-ad5c-6f8cfa35cbd1&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dao-da-bei-jing&quot;&gt;到达北京&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;13ce7fba-3abd-4694-abf7-9bc63516f000&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在周六的早上到达会场 扫了入场的码 领到了活动给的一些礼品 7点多我俩就到达了会场，刚开始觉得平平无奇，后来直到大会开始，陆陆续续的大家都来到了会场，开源社的老哥，老姐们开始了自己的演讲，我发现这真的不是一个普通大会，很多人报着开源的理念 一直维持着开源社，让开源社越来越大&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;a61b6743-c8be-44cc-9cf2-726328d94074&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;4cc41519-2abb-4844-a75b-4cdf91cb271b&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;9a5f9ece-dab6-4614-9988-540bf3554641&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;57e8dcb5-89c8-45f3-953d-6c857a7437a6&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;1558d9c3-3b63-456d-bf30-eb75e4f1ba0a&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;虽然是第一次参加，但是我对于这种氛围是非常的喜欢，各位有着自己想法的人都在开源社散发光辉，有为抗癌人士专门发布app的
小胰宝等其他的产品，这令我深受触动，把科技真真正正的融合到了生活当中，使人们都能享受科技带来的便捷！大会中的每一个人的演讲都令我感到激动！但是对我印象的最深刻的就是&lt;strong&gt;yihong0618&lt;&#x2F;strong&gt;这个id，伊洪老师的演讲令我眼前一亮心里一跳哈哈哈哈
简直太爽啦！！！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yihong0618&quot;&gt;yihong0618&lt;&#x2F;h2&gt;
&lt;p&gt;请大家自己去看伊洪老师的github，你真的能从中学到很多，在火车上我一直再看伊洪老师的github
每一件事是写的那么的真诚，有很多我也感同身受，生活的迷茫原来真的不是自己才有，面临各种压力，各种抉择！做好自己。&lt;&#x2F;p&gt;
&lt;p&gt;[github] https:&#x2F;&#x2F;github.com&#x2F;yihong0618&lt;&#x2F;p&gt;
&lt;p&gt;在伊洪老师的演讲中，令我觉得钦佩的是，每一天的记录自己，我太喜欢这种感觉了，发布到github上，我也便想向这么做
在4日赶回来我便从网上学习搭建博客，坚持记录每一天&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-yu&quot;&gt;结语&lt;&#x2F;h2&gt;
&lt;p&gt;这次旅程，说走就走，哈哈哈，这才是大学生嘛，遇见了开源社的大家，我希望从今的每一天，慢慢的融入到开源社这个大家庭&lt;&#x2F;p&gt;
&lt;p&gt;-感谢冰哥陪我这次旅行&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;                                                                    2024年11.4日
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
      <item>
          <title>编程的一些观念</title>
          <pubDate>Fri, 06 Jun 2025 04:05:21 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-14/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-14/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-14/">&lt;h1 id=&quot;bian-cheng-xue-xi-de-7ge-zhong-yao-guan-nian&quot;&gt;编程学习的7个重要观念&lt;&#x2F;h1&gt;
&lt;p&gt;观看了一个视频，视频中的要点，很多是我有过的困惑，希望大家能避免，不要追求完美！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1W87qzuEzX?vd_source=4f3d528d84e2e77c1b7ceb97ba4ecab1&quot;&gt;bilibili&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;1-ni-bu-xu-yao-shen-me-du-zhi-dao&quot;&gt;1. 你不需要什么都知道&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：编程不是记忆语言，而是理解模式和查找答案。资深开发者也常用 Google 搜索。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：消除“必须全知”的误解，减轻初学者压力，专注学习过程。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：使用 MDN、Stack Overflow 查资料，记录常用代码片段。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：搜索 &lt;code&gt;JavaScript get last array element&lt;&#x2F;code&gt; 得：&lt;code&gt;array[array.length - 1]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-xue-xi-ru-he-xue-xi&quot;&gt;2. 学习如何学习&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：看教程不等于学会，动手实践是关键。建议 1 小时教程配 4 小时独立 coding。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：实践巩固知识，过度依赖教程会导致“虚假进步”。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：做小项目（如待办事项列表），卡住时分解问题、搜索答案。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：写函数过滤数组偶数，搜索 &lt;code&gt;JavaScript filter&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-wan-mei-shi-yi-ge-xian-jing&quot;&gt;3. 完美是一个陷阱&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：追求完美代码会拖慢进度，完成的“丑陋”代码更有价值。资深开发者也写 bug。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：避免因不完美而拖延，迭代才是提升代码质量的关键。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：先实现 MVP，用 Git 跟踪改进。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：别花 3 小时纠结变量名，用 &lt;code&gt;data&lt;&#x2F;code&gt; 继续写功能&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-ni-yong-yuan-bu-hui-gan-dao-zhun-bei-jiu-xu&quot;&gt;4. 你永远不会感到准备就绪&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：自信来自行动，而非等待“准备好”。接受失败是成长的一部分。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：拖延会错失机会，边做边学是正道。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：从克隆简单网页开始，勇敢申请工作或项目。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：彼得首个自由职业项目靠 Google 完成&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-zhen-zheng-de-ji-neng-shi-jie-jue-wen-ti&quot;&gt;5. 真正的技能是解决问题&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：编程核心是分解问题和调试，而非记语法。开发者像侦探，追踪线索。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：调试是工作常态，培养逻辑思维比记代码更重要。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：将任务拆成小步，用 &lt;code&gt;console.log&lt;&#x2F;code&gt; 或调试器检查。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：页面不显示数据，查 API、数据格式或渲染逻辑&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-mei-ren-zai-hu-ni-de-dai-ma-ta-men-guan-xin-ta-neng-zuo-shen-me&quot;&gt;6. 没人在乎你的代码，他们关心它能做什么&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：用户&#x2F;客户只关心功能（如按钮能否工作），不在乎代码优雅。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：避免沉迷代码美学，优先交付实用产品。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：先确保功能实现，再优化代码。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：客户只想按钮变蓝色，不在乎你用没用 React Hook&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-juan-dai-shi-zhen-shi-cun-zai-de-bao-hu-ni-de-neng-liang&quot;&gt;7. 倦怠是真实存在的，保护你的能量&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要点&lt;&#x2F;strong&gt;：编程是马拉松，过度消耗会导致倦怠。休息和边界感确保可持续性。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;&#x2F;strong&gt;：倦怠让人怀疑能力，健康习惯提升效率。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;建议&lt;&#x2F;strong&gt;：使用番茄工作法（25 分钟工作 + 5 分钟休息），保证睡眠，散步放松。&lt;br &#x2F;&gt;
&lt;strong&gt;例子&lt;&#x2F;strong&gt;：彼得熬夜修 bug 得不偿失&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
</description>
      </item>
      <item>
          <title>儿童节</title>
          <pubDate>Sun, 01 Jun 2025 14:46:50 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-13/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-13/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-13/">&lt;hr &#x2F;&gt;
&lt;p&gt;Date: 2025-06-01&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;啊一转眼都已经20了，对于儿童节已经跟自己无关了，但是还有老姐给我过儿童节哈哈，好开心，第二年咯&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;8746b372-e565-4bfb-81a8-1552955c2d0d&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;2674e8dc-b48f-47a0-8719-cdf1d3e24547&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一年前的今天&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;2efff1aa-106e-4022-86bd-058b38b02137&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;71c458c3-574c-46f5-b1d2-72f89d1968af&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;好开心！&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Grokking Concurrency</title>
          <pubDate>Sun, 01 Jun 2025 07:47:47 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-12/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-12/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-12/">&lt;hr &#x2F;&gt;
&lt;p&gt;Date: 2025-06-01&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;bing-xing-de-xian-zhi&quot;&gt;并行的限制&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;程序中无法并行的部分，决定了整体性能的上限。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Amdahl 定律&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;8424dc92-6a55-4270-ac97-b1d229244343&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一个程序中，假设其中 Lock &#x2F; Unlock 是串行（不可并行），只占 30% 时间；&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你把其余的 70% 并行了，最多也只能加速约 1 &#x2F; (0.3 + 0.7&#x2F;N)；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;即使 N=100，也不是 100 倍加速，可能只有 3 倍左右。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任务中无法并行的部分就是瓶颈&lt;&#x2F;strong&gt;，再多线程、再多 CPU 也没用；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可并行度越小，增加资源的收益越差&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;虽然Amdahl 定律 展现了一个令人失望的结果！ 但我们仍然需要乐观&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;le-guan-shi-jiao&quot;&gt;乐观视角&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Gustafson 定律&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Amdahl 假设任务总量是固定的，这在现实中不常见，反过来看：既然加速比有瓶颈，那我们不如做更多的任务！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;核心思想：&lt;&#x2F;strong&gt; 并行不是为了加速固定的任务，而是为了让我们能处理更大的问题规模、更复杂的数据量。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;223d1c36-fdde-47e2-97fe-b83e4443ec56&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;你银行系统如果每天只能处理 1 万笔转账（串行），用了并发系统之后，不是把 1 万笔处理更快 —— 而是你能处理 100 万笔！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bing-fa-he-bing-xing&quot;&gt;并发和并行&lt;&#x2F;h2&gt;
&lt;p&gt;Rob Pike说过的一句经典的话&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;并发： 你能同时接收很多个转账请求，每个请求你都安排好流程、排队、处理顺序；&lt;&#x2F;p&gt;
&lt;p&gt;并行： 你有多个处理器，多个请求可以真的在同一时刻一起处理（比如一个核心处理用户 A 的转账，另一个处理用户 B 的转账）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;并发是编程模型，Go 语言提供了 goroutine + channel，容易表达并发逻辑；是否能并行，是操作系统 + CPU 的事。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-cheng-he-xian-cheng&quot;&gt;进程和线程&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;为什么说没有线程的进程是不存在的？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;现代操作系统的进程实现方式。从技术角度看，进程至少包含一个执行线程（即主线程）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;进程类比为： 拥有者资源
线程类比为： 执行资源的人&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;线程(工人) 进程（建筑）&lt;&#x2F;p&gt;
&lt;p&gt;所以说 即使你拥有资源但是无法执行 也就相当于没有拥有！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;谁又去管理 线程和进程呢？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;也就是操作系统，操作系统_使用PCB和TCB_去管理&lt;&#x2F;p&gt;
&lt;p&gt;操作系统用PCB记录进程的资源（内存、文件等）。&lt;&#x2F;p&gt;
&lt;p&gt;用TCB记录线程的执行状态（寄存器、栈等）。&lt;&#x2F;p&gt;
&lt;p&gt;PCB必须关联至少一个TCB，否则进程无法被调度执行。&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Go By Mistakes</title>
          <pubDate>Fri, 30 May 2025 08:19:16 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-11/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-11/">&lt;h1 id=&quot;inithan-shu-de-shi-yong&quot;&gt;init函数的使用&lt;&#x2F;h1&gt;
&lt;p&gt;在&lt;code&gt;init()&lt;&#x2F;code&gt;函数中，不能返回错误，因为init函数的作用是 完成初始化 或者直接使用&lt;code&gt;panic()&lt;&#x2F;code&gt;终止程序 ！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-shi&quot;&gt;测试&lt;&#x2F;h2&gt;
&lt;p&gt;在测试之前&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Go总会加载相关包&lt;&#x2F;li&gt;
&lt;li&gt;自动调用包中的所有&lt;code&gt;init()&lt;&#x2F;code&gt;函数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;执行顺序&lt;&#x2F;strong&gt;： 测试加载顺序：包级变量初始化 → init() 执行 → TestMain()（如果存在）→ TestXxx() 执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-yi&quot;&gt;&lt;strong&gt;注意：&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;init() 是全局性的，一旦定义就会在所有测试前执行
所以如果你在某个文件中写了一个 init()，它无法按需控制是否执行，这会给某些不需要它的测试带来副作用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;p&gt;如果你在一个文件中定义了&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; utils.go
func HashPassword(pw string) string {
    &amp;#x2F;&amp;#x2F; 哈希逻辑
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func init() {
    &amp;#x2F;&amp;#x2F; 建立数据库连接
    db, _ = sql.Open(&amp;quot;postgres&amp;quot;, &amp;quot;...&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你只想测试 HashPassword()，跟数据库没关系，但：&lt;&#x2F;p&gt;
&lt;p&gt;Go 会强制执行 init() → 建立数据库连接&lt;&#x2F;p&gt;
&lt;p&gt;如果数据库挂了、网络断了，测试失败&lt;&#x2F;p&gt;
&lt;p&gt;即使测试内容跟数据库一毛钱关系都没有&lt;&#x2F;p&gt;
&lt;p&gt;init() 是文件级别、不可控制的初始化逻辑，一旦存在，它就会对这个包的所有使用者和测试者产生影响。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;做法：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;尽量避免在 init() 中建立全局连接或启动重逻辑 不要用 init() 连数据库&lt;&#x2F;p&gt;
&lt;p&gt;把数据库连接从 init() 拆出去，改成显式初始化函数，这样测试更灵活、代码更可控、依赖更清晰&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;var DB *sql.DB

func InitDB(dsn string) error {
	var err error
	DB, err = sql.Open(&amp;quot;postgres&amp;quot;, dsn)
	return err
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;quan-ju-bian-liang&quot;&gt;全局变量&lt;&#x2F;h2&gt;
&lt;p&gt;如果把数据库连接对象赋值给全局变量（如 var db *sql.DB），为什么这会让单元测试变复杂、变得“不隔离”？&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-li-1&quot;&gt;示例：&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
package user

import &amp;quot;yourproject&amp;#x2F;db&amp;quot;

func GetUserByID(id int) (*User, error) {
	return db.DB.Query(...) &amp;#x2F;&amp;#x2F; 用的是全局变量 db.DB
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;它依赖的是全局变量 db.DB，你没法注入 mock 数据库(全局变量在代码里写死了，函数内部直接引用它，测试时你没法“替换”这个变量指向别的对象)，也无法用内存数据库替代。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-jue&quot;&gt;解决：&lt;&#x2F;h3&gt;
&lt;p&gt;将 DB 作为参数而不是全局变量&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; user.go
type UserRepo struct {
	DB *sql.DB
}

func (r *UserRepo) GetUserByID(id int) (*User, error) {
	return r.DB.Query(...)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;main.go&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;db, _ := sql.Open(...)
repo := user.UserRepo{DB: db}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;测试中&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;fakeDB := NewFakeDB() &amp;#x2F;&amp;#x2F; 或用 sqlite、mock
repo := user.UserRepo{DB: fakeDB}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; db_test.go
package db

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;
)

func Test_Global_DB(t *testing.T) {
	DB = &amp;quot;RealDB&amp;quot;
	got := GetUserGlobal(1)
	fmt.Println(got)

	DB = &amp;quot;MockDB&amp;quot; &amp;#x2F;&amp;#x2F; ← 修改全局变量

	got2 := GetUserGlobal(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 问题：前后结果不一致，测试间共享状态
}

func Test_DI_DB(t *testing.T) {
	real := &amp;amp;DBClient{DB: &amp;quot;RealDB&amp;quot;}
	mock := &amp;amp;DBClient{DB: &amp;quot;MockDB&amp;quot;}

	got := real.GetUserDI(1)
	fmt.Println(got)

	got2 := mock.GetUserDI(1)
	fmt.Println(got2)
	&amp;#x2F;&amp;#x2F; 优点：各自隔离，不会互相影响
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
      <item>
          <title>Copy-On-Write</title>
          <pubDate>Thu, 29 May 2025 12:59:51 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-10/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-10/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-10/">&lt;h1 id=&quot;cmu15445&quot;&gt;cmu15445&lt;&#x2F;h1&gt;
&lt;p&gt;在推进cmu15445的时候被一个项目就难住了，写时复制树，啊啊有点崩溃了，搞了好长时间，还是无法推进，这里面的c++语法看着太复杂了！&lt;&#x2F;p&gt;
&lt;p&gt;关于写时复制的一些概念和使用：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.lenovo.com&#x2F;us&#x2F;en&#x2F;glossary&#x2F;what-is-cow&#x2F;?orgRef=https%253A%252F%252Fwww.google.com.hk%252F&quot;&gt;写实复制&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>博文推荐</title>
          <pubDate>Wed, 28 May 2025 13:07:22 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-9/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-9/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-9/">&lt;h1 id=&quot;you-zhi-bo-wen-jing-xuan-ji&quot;&gt;优质博文精选集&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个持续更新的高质量技术&#x2F;设计&#x2F;思维类博文索引库&lt;br &#x2F;&gt;
「我们站在巨人的肩膀上，但需要知道肩膀在哪」&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2025-06-12ri-tui-jian&quot;&gt;2025-06-12日推荐&lt;&#x2F;h2&gt;
&lt;p&gt;获取前沿资料&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;&quot;&gt;ACM&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.nature.com&#x2F;&quot;&gt;Nature&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.sigplan.org&#x2F;&quot;&gt;SIGPLAN编程语言博客&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;scholar.google.de&#x2F;&quot;&gt;Google学术搜索&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;list&#x2F;cs.PL&#x2F;recent&quot;&gt;arXiv编程语言文论&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dev.golang.org&#x2F;&quot;&gt;Go官方文档&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&quot;&gt;Go语言Github&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go-review.googlesource.com&quot;&gt;Go代码审查&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;x.com&#x2F;&quot;&gt;Twitter&#x2F;X平台&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;reddit&#x2F;r&#x2F;golang&quot;&gt;Reddit Go社区&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-nuts&quot;&gt;Go技术讨论组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev&quot;&gt;Go开发组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-tools&quot;&gt;Go工具组&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;2025-06-06ri-tui-jian&quot;&gt;2025-06-06日推荐&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;terriblesoftware.org&#x2F;2025&#x2F;04&#x2F;23&#x2F;the-hidden-cost-of-ai-coding&#x2F;&quot;&gt;关于AI编码思考&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&quot;我们生命中最美好的时刻不是被动、接受、放松的时光......最好的时刻通常发生在一个人的身体或思想自愿努力完成困难和有价值的事情时。— 米哈利·西克森特米哈伊&quot;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2025-05-11ri-tui-jian&quot;&gt;2025-05-11日推荐&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;cn.nytimes.com&#x2F;obits&#x2F;20210524&#x2F;yuan-longping-dead&#x2F;&quot;&gt;讣告-袁隆平&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;“这不是什么秘密，我的经历可以用四个词来概括：知识、汗水、灵感和机会，”袁隆平去年在一段鼓励中国年轻人投身科学的视频中说。他还在英语引用了科学家路易斯·巴斯德(Louis Pasteur)的话：“机会青睐有准备的头脑。”&lt;&#x2F;p&gt;
&lt;p&gt;---袁隆平&lt;&#x2F;p&gt;
&lt;p&gt;[低期望，多尝试]&lt;&#x2F;p&gt;
&lt;p&gt;“我们应该做一个积极行动的悲观主义者，对未来低期望，但只要是值得的，就坚定去做。当一个有前途的新项目出现在你面前时，不妨认定它很难成功，但是如果你相信这个项目，即便赚不到钱你也想做，那么无论如此，你要去试一下。”&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2025-04-16tui-jian&quot;&gt;2025-04-16推荐&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.dutchosintguy.com&#x2F;post&#x2F;the-slow-collapse-of-critical-thinking-in-osint-due-to-ai&quot;&gt;AI导致批判性思维逐渐崩溃&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
</description>
      </item>
      <item>
          <title> 6.s081学习</title>
          <pubDate>Wed, 28 May 2025 12:51:30 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-8/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-8/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-8/">&lt;h1 id=&quot;6-s081&quot;&gt;6.s081&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;csdiy.wiki&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&#x2F;MIT6.S081&#x2F;&quot;&gt;6.s081&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;issue-8&#x2F;%5Bhttps:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2021&#x2F;schedule.html%5D(https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2021&#x2F;schedule.html)&quot;&gt;课程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;阅读文档： https:&#x2F;&#x2F;th0ar.gitbooks.io&#x2F;xv6-chinese&#x2F;content&#x2F;content&#x2F;chapter0.html&lt;&#x2F;p&gt;
&lt;h2 id=&quot;0-cao-zuo-xi-tong-jie-kou&quot;&gt;0. 操作系统接口&lt;&#x2F;h2&gt;
&lt;p&gt;一个&lt;em&gt;向其他运行中程序&lt;&#x2F;em&gt;提供服务的特殊程序。每一个运行中程序（称之为&lt;strong&gt;进程&lt;&#x2F;strong&gt;）都拥有&lt;em&gt;包含指令、数据、栈的内存空间&lt;&#x2F;em&gt; ， &lt;em&gt;指令&lt;&#x2F;em&gt;实现了程序的运算，&lt;em&gt;数据&lt;&#x2F;em&gt;是用于运算过程的变量，&lt;em&gt;栈&lt;&#x2F;em&gt;管理了程序的过程调用&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;&#x2F;strong&gt;通过&lt;strong&gt;系统调用&lt;&#x2F;strong&gt;使用内核服务，系统调用会进入内核，让内核执行服务然后返回。所以 &lt;strong&gt;进程总是在用户空间和内核空间之间交替运行&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间，内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-kou&quot;&gt;接口&lt;&#x2F;h3&gt;
&lt;p&gt;内核提供的一系列系统调用就是用户程序可见的操作系统接口&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统调用&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;fork()&lt;&#x2F;td&gt;&lt;td&gt;创建进程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;exit()&lt;&#x2F;td&gt;&lt;td&gt;结束当前进程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;wait()&lt;&#x2F;td&gt;&lt;td&gt;等待子进程结束&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;kill(pid)&lt;&#x2F;td&gt;&lt;td&gt;结束 pid 所指进程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;getpid()&lt;&#x2F;td&gt;&lt;td&gt;获得当前进程 pid&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;sleep(n)&lt;&#x2F;td&gt;&lt;td&gt;睡眠 n 秒&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;exec(filename, *argv)&lt;&#x2F;td&gt;&lt;td&gt;加载并执行一个文件&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;sbrk(n)&lt;&#x2F;td&gt;&lt;td&gt;为进程内存空间增加 n 字节&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;open(filename, flags)&lt;&#x2F;td&gt;&lt;td&gt;打开文件，flags 指定读&#x2F;写模式&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;read(fd, buf, n)&lt;&#x2F;td&gt;&lt;td&gt;从文件中读 n 个字节到 buf&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;write(fd, buf, n)&lt;&#x2F;td&gt;&lt;td&gt;从 buf 中写 n 个字节到文件&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;close(fd)&lt;&#x2F;td&gt;&lt;td&gt;关闭打开的 fd&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;dup(fd)&lt;&#x2F;td&gt;&lt;td&gt;复制 fd&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;pipe( p)&lt;&#x2F;td&gt;&lt;td&gt;创建管道， 并把读和写的 fd 返回到p&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;chdir(dirname)&lt;&#x2F;td&gt;&lt;td&gt;改变当前目录&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;mkdir(dirname)&lt;&#x2F;td&gt;&lt;td&gt;创建新的目录&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;mknod(name, major, minor)&lt;&#x2F;td&gt;&lt;td&gt;创建设备文件&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;fstat(fd)&lt;&#x2F;td&gt;&lt;td&gt;返回文件信息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;link(f1, f2)&lt;&#x2F;td&gt;&lt;td&gt;给 f1 创建一个新名字(f2)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;unlink(filename)&lt;&#x2F;td&gt;&lt;td&gt;删除文件&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;shell 是一个普通的程序，它接受用户输入的命令并且执行它们，它也是传统 Unix 系统中最基本的用户界面。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jin-cheng-he-nei-cun&quot;&gt;进程和内存&lt;&#x2F;h3&gt;
&lt;p&gt;xv6 进程的组成部分：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户内存空间： &lt;strong&gt;（指令，数据，栈）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;仅对内核可见的进程状态：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;xv6 是一个操作系统&lt;&#x2F;strong&gt;，而不是一个普通的程序。它包含了操作系统的核心组件，如进程管理、内存管理、文件系统、设备驱动等。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-1&quot;&gt;问题1：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么我可以在我的操作系统上同时运行xv6来进行学习呢？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-1&quot;&gt;回答1：&lt;&#x2F;h4&gt;
&lt;p&gt;xv6 是作为一个 &lt;strong&gt;虚拟机&lt;&#x2F;strong&gt; 运行的，而不是直接在你的物理硬件上运行。以下是详细的解释：&lt;&#x2F;p&gt;
&lt;p&gt;因为使用了 QEMU： - &lt;strong&gt;QEMU&lt;&#x2F;strong&gt;：一个开源的虚拟化工具，可以模拟完整的计算机硬件。
类似于vm所以可以运行&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;xv6-fen-shi-te-xing&quot;&gt;xv6 &lt;em&gt;分时特性&lt;&#x2F;em&gt; ：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;分时（Time-sharing）&lt;&#x2F;strong&gt; 是 xv6 的一个重要特性，允许多个进程共享 CPU 资源，通过快速切换进程来实现“同时运行”的效果。以下是 xv6 分时特性的具体实现：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轮转调度算法&lt;&#x2F;strong&gt; ： &lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;zh-cn&#x2F;%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6&quot;&gt;时间片轮转调度&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;上下文切换&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;多进程并发&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;系统调用支持&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;中断机制&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;关于 &lt;a href=&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;raind&#x2F;p&#x2F;10077982.html&quot; title=&quot;发布于 2018-12-06 17:26&quot;&gt;多CPU，多核，多进程，多线程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-2&quot;&gt;问题2：&lt;&#x2F;h4&gt;
&lt;p&gt;进程是怎么产生的？ 我们桌面上的一个软件点击打开的过程发生了什么&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-2&quot;&gt;回答2：&lt;&#x2F;h4&gt;
&lt;p&gt;(1) &lt;strong&gt;进程创建&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;进程通常通过 &lt;strong&gt;系统调用&lt;&#x2F;strong&gt; 创建&lt;&#x2F;p&gt;
&lt;p&gt;(2) &lt;strong&gt;进程执行&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;创建子进程后，通常会用 &lt;code&gt;exec()&lt;&#x2F;code&gt; 系统调用来加载一个新的程序到子进程的内存中，并开始执行。&lt;&#x2F;p&gt;
&lt;p&gt;(3) &lt;strong&gt;进程终止&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程可以通过 &lt;code&gt;exit()&lt;&#x2F;code&gt; 系统调用主动终止，或者因为某些错误（如段错误）被操作系统强制终止。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;父进程可以通过 &lt;code&gt;wait()&lt;&#x2F;code&gt; 系统调用等待子进程终止，并回收子进程的资源。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;fork-jin-cheng-chuang-jian&quot;&gt;fork() 进程创建&lt;&#x2F;h3&gt;
&lt;p&gt;一次调用会返回两次： 一次是 &lt;em&gt;父进程&lt;&#x2F;em&gt; 一次是 &lt;em&gt;子进程&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;示例代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys&amp;#x2F;types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
    pid_t pid;
    int x = 1;
    
    pid = fork();
    
    if (pid == 0) {
        &amp;#x2F;&amp;#x2F; Child process
        printf(&amp;quot;child: x = %d\n&amp;quot;, ++x);
        exit(0);
    } else if (pid &amp;gt; 0) {
        &amp;#x2F;&amp;#x2F; Parent process
        printf(&amp;quot;parent: x = %d\n&amp;quot;, x);
        exit(0);
    } else {
        &amp;#x2F;&amp;#x2F; Error in fork
        perror(&amp;quot;fork failed&amp;quot;);
        exit(1);
    }
    
    return 0;
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;返回结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;parent: x=0
child: x=2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在 &lt;em&gt;shell&lt;&#x2F;em&gt; 中 执行  &lt;em&gt;.&#x2F;hello&lt;&#x2F;em&gt;  ：&lt;&#x2F;p&gt;
&lt;p&gt;shell看为父进程， 程序hello看为子进程，&lt;&#x2F;p&gt;
&lt;p&gt;父子进程都有&lt;em&gt;各自的空间互不干扰&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;程序和进程的&lt;em&gt;区别&lt;&#x2F;em&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;程序是代码 ： 存储在磁盘上  在&lt;em&gt;执行&lt;&#x2F;em&gt; 是程序以段的形式 &lt;em&gt;存在于在内存的地址空间&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;进程&lt;em&gt;为正在执行中程序的具体实例&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;进程状态：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;运行&lt;&#x2F;li&gt;
&lt;li&gt;暂停&lt;&#x2F;li&gt;
&lt;li&gt;终止&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;dui-bi&quot;&gt;对比&lt;&#x2F;h4&gt;
&lt;p&gt;对比fork 和 goroutine&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;fork()&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;Goroutine&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;创建单位&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;进程&lt;&#x2F;td&gt;&lt;td&gt;轻量级线程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;资源开销&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;高（复制整个进程）&lt;&#x2F;td&gt;&lt;td&gt;低（共享地址空间）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;通信方式&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;进程间通信（IPC）如管道、信号&lt;&#x2F;td&gt;&lt;td&gt;通道（channel）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;调度&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;操作系统调度&lt;&#x2F;td&gt;&lt;td&gt;Go 运行时调度&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;使用场景&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;需要完全独立执行的任务&lt;&#x2F;td&gt;&lt;td&gt;高并发任务&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;wen-ti-3&quot;&gt;问题3：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;如果有两个fork()函数在放在上下句 那么第一个fork出来的子进程是调用两次fork还是一次fork呢？&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-3&quot;&gt;回答3：&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一个 &lt;code&gt;fork()&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：创建子进程 C1。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二个 &lt;code&gt;fork()&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原始进程创建子进程 C2。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;子进程 C1 创建子进程 C3。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;因此，第一个 &lt;code&gt;fork()&lt;&#x2F;code&gt; 创建的子进程 C1 会调用一次 &lt;code&gt;fork()&lt;&#x2F;code&gt;，创建子进程 C3。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;使用gcc编译程序&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;gcc  ~.c -o XXX&lt;&#x2F;p&gt;
&lt;p&gt;.&#x2F;XXX&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;理解这段程序的执行顺序&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys&amp;#x2F;types.h&amp;gt;
#include &amp;lt;sys&amp;#x2F;wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
    pid_t pid;
    pid = fork();  &amp;#x2F;&amp;#x2F; 创建子进程

    if (pid &amp;gt; 0) {
        &amp;#x2F;&amp;#x2F; 父进程
        printf(&amp;quot;parent: waiting for child to finish\n&amp;quot;);
        pid_t child_pid = wait(NULL);  &amp;#x2F;&amp;#x2F; 等待子进程完成
        printf(&amp;quot;parent: child %d finished\n&amp;quot;, child_pid);
    } else if (pid == 0) {
        &amp;#x2F;&amp;#x2F; 子进程
        printf(&amp;quot;child: doing some work\n&amp;quot;);
        sleep(2);  &amp;#x2F;&amp;#x2F; 模拟子进程工作
        printf(&amp;quot;child: exiting\n&amp;quot;);
        exit(0);  &amp;#x2F;&amp;#x2F; 子进程退出
    } else {
        &amp;#x2F;&amp;#x2F; fork 错误
        printf(&amp;quot;fork error\n&amp;quot;);
    }

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;pid_t child_pid = wait(NULL);  &#x2F;&#x2F; 等待子进程完成  &lt;em&gt;执行顺序&lt;&#x2F;em&gt;：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;parent: waiting for child to finish&lt;&#x2F;li&gt;
&lt;li&gt;打印else里面的pid == 0也就是 子进程： child: doing some work  child: exiting&lt;&#x2F;li&gt;
&lt;li&gt;wait收到了子进程的退出&lt;&#x2F;li&gt;
&lt;li&gt;parent: child %d finished&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;父进程和子进程唯一的区别：&lt;&#x2F;p&gt;
&lt;p&gt;fork()返回的的进程号不一样 也就是返回两个值 父进程大于0 子进程小于0&lt;&#x2F;p&gt;
&lt;h3 id=&quot;exec&quot;&gt;exec()&lt;&#x2F;h3&gt;
&lt;p&gt;加载并执行一个新的程序,替换当前进程的镜像,将指定的可执行文件（如 &lt;code&gt;.&#x2F;a.out&lt;&#x2F;code&gt;）加载到当前进程的地址空间中。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载程序&lt;&#x2F;strong&gt;：将指定的可执行文件（如 &lt;code&gt;.&#x2F;a.out&lt;&#x2F;code&gt;）加载到当前进程的地址空间中。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;替换当前进程映像&lt;&#x2F;strong&gt;：当前进程的代码、数据、堆栈等都会被新的程序替换。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;执行新程序&lt;&#x2F;strong&gt;：新程序开始执行，从其 &lt;code&gt;main()&lt;&#x2F;code&gt; 函数开始。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;不返回&lt;&#x2F;strong&gt;：一旦调用 &lt;code&gt;exec&lt;&#x2F;code&gt;，它会完全替换当前进程的执行代码，因此 &lt;strong&gt;不会返回到原来的代码&lt;&#x2F;strong&gt;（如果成功执行 &lt;code&gt;exec&lt;&#x2F;code&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int main() {
    char *args[] = {&amp;quot;&amp;#x2F;bin&amp;#x2F;ls&amp;quot;, &amp;quot;-l&amp;quot;, NULL};  &amp;#x2F;&amp;#x2F; 执行的程序及参数
    execv(&amp;quot;&amp;#x2F;bin&amp;#x2F;ls&amp;quot;, args);  &amp;#x2F;&amp;#x2F; 使用 execv 执行 ls 命令
    return 0;  &amp;#x2F;&amp;#x2F; 如果 execv 执行成功，这行代码永远不会被执行
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;code&gt;sleep 2000&lt;&#x2F;code&gt;  执行这句指令 的父进程是bash终端
&lt;code&gt;pstree -p&lt;&#x2F;code&gt; 查看进程树
&lt;code&gt;echo $$&lt;&#x2F;code&gt;    是输出当前 shell 进程的 PID，这在一些进程管理和调试过程中很有用&lt;&#x2F;p&gt;
&lt;p&gt;结合 exec&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;exec sleep 200&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这样使sleep进程替换了原来的bash进程
如果此时终止睡眠则终端直接关闭，因为sleep进程替换了bash进程&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;vim test.sh&lt;&#x2F;code&gt; shell脚本&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#! &amp;#x2F;bin&amp;#x2F;bash

sleep 200
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;添加执行权限：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;chmod +x test.sh&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.&#x2F;test&#x2F;sh&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;执行脚本相当于： 用当前交互的Shell运行了一个shell子进程&lt;&#x2F;p&gt;
&lt;h4 id=&quot;i-o-he-wen-jian-miao-shu-fu&quot;&gt;I&#x2F;O 和文件描述符&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;文件描述符&lt;&#x2F;strong&gt;是一个整数，它代表了一个进程可以读写的被内核管理的对象&lt;&#x2F;p&gt;
&lt;p&gt;文件描述符指向的对象称为“文件”&lt;&#x2F;p&gt;
&lt;p&gt;可以理解为key value 一个整数或者几个整数 对应一个文件&lt;&#x2F;p&gt;
&lt;p&gt;文件描述符和进程相伴相生&lt;&#x2F;p&gt;
&lt;p&gt;每个进程都有一个从0开始的文件描述符空间&lt;&#x2F;p&gt;
&lt;p&gt;0 1 2&lt;&#x2F;p&gt;
&lt;p&gt;0： 标准输入： 键盘对应的存储空间&lt;&#x2F;p&gt;
&lt;p&gt;1： 标准输出 ： 输出到屏幕所对应的存储空间&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.&#x2F;test &amp;gt; test.txt&lt;&#x2F;code&gt; 将 程序 结果输出 到 文本文件中&lt;&#x2F;p&gt;
&lt;p&gt;2： 标准出错 ： 出错信息打印到屏幕&lt;&#x2F;p&gt;
&lt;p&gt;shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符&lt;&#x2F;p&gt;
&lt;p&gt;系统调用 &lt;code&gt;read&lt;&#x2F;code&gt; 和 &lt;code&gt;write&lt;&#x2F;code&gt; 从文件描述符所指的文件中读或者写 n 个字节  &lt;code&gt;read(fd, buf, n)&lt;&#x2F;code&gt; 从 &lt;code&gt;fd&lt;&#x2F;code&gt; 读最多 n 个字节 将它们拷贝到 &lt;code&gt;buf&lt;&#x2F;code&gt; 中，然后返回读出的字节数&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;write(fd, buf, n)&lt;&#x2F;code&gt; 写 &lt;code&gt;buf&lt;&#x2F;code&gt; 中的 n 个字节到 &lt;code&gt;fd&lt;&#x2F;code&gt; 并且返回实际写出的字节数&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;&#x2F;code&gt; 的本质实现:&lt;&#x2F;p&gt;
&lt;p&gt;将数据从标准输入复制到标准输出&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;if(fork() == 0) {
    write(1, &amp;quot;hello &amp;quot;, 6);
    exit();
} else {
    wait();
    write(1, &amp;quot;world\n&amp;quot;, 6);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;dup&lt;&#x2F;code&gt; &lt;&#x2F;p&gt;
&lt;p&gt;复制一个已有的文件描述符，返回一个指向同一个输入&#x2F;输出对象的新描述符&lt;&#x2F;p&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;fd = dup(1);
write(1, &amp;quot;hello&amp;quot;, 6);
write(fd, &amp;quot;world\n&amp;quot;, 6);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;dup()&lt;&#x2F;code&gt; 主要用来复制文件描述符，方便使用多个描述符来操作同一个文件或 I&#x2F;O 对象。它广泛用于 I&#x2F;O 重定向、进程间共享文件描述符等场景。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;guan-yu-zuo-ti-zhi-qian-de-yi-xie-jian-yi&quot;&gt;关于做题之前的一些建议&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;了解对指针的运算&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;p[i] = *(p + i)&lt;&#x2F;p&gt;
&lt;p&gt;(int)p + 1，(int)(p + 1)&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;gdb调试&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;make qemu-gdb&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当 内核悬挂（例如，由于僵局）或无法进一步执行&lt;&#x2F;p&gt;
&lt;p&gt;使用GDB来找出其悬挂的位置 ：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;run &#x27;make qemu-gdb&#x27; in one window&lt;&#x2F;em&gt;  , &lt;em&gt;run gdb (riscv64-linux-gnu-gdb) in another windows&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;理解程序：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;char*
strcpy(char *s, const char *t)
{
  char *os;

  os = s;
  while((*s++ = *t++) != 0)
    ;
  return os;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;make grade&lt;&#x2F;code&gt;  查看所有程序是否通过&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.&#x2F;grade-lab-util sleep&lt;&#x2F;code&gt;  单独 运行某个程序  &lt;code&gt;or&lt;&#x2F;code&gt;   &lt;code&gt;make GRADEFLAGS=sleep grade&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;快速查找：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;grep &quot;关键字&quot; 文件名&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1-xia-zai-qemuman&quot;&gt;1. 下载qemu慢&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt; cd &#x2F;mnt&#x2F;c&#x2F;Users&#x2F;30413&#x2F;Downloads&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在wsl 可以 转换到本地目录&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt; cp qemu-7.2.16.tar.xz ~&lt;&#x2F;code&gt;直接就过来了&lt;&#x2F;p&gt;
&lt;p&gt;在wsl中下载qemu实在是太慢了&lt;&#x2F;p&gt;
&lt;p&gt;解压：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;tar xvJf qemu-7.2.16.tar.xz -C &#x2F;opt&#x2F;qemu&lt;&#x2F;code&gt;
&lt;code&gt;tar tvJf qemu-7.2.16.tar.xz&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;成功运行了！&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2-make-grade&quot;&gt;2.&lt;code&gt;make grade&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;解决xv6无法&lt;code&gt; make grade&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;参考仓库：&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;heeyoung-choi&#x2F;xv6-lab&#x2F;blob&#x2F;main&#x2F;Makefile&lt;&#x2F;p&gt;
&lt;p&gt;强制删除在git中嵌套的仓库，以避免推送出现问题&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;git rm -f --cached xv6-public&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;sleep-c&quot;&gt;sleep.c&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;

int
main(int argc, char *argv[])
{
    if (argc &amp;lt; 2 || argc &amp;gt; 2 )
    {
    write(2,&amp;quot;only 1 arguments place write again\n&amp;quot;,36);
    exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;guan-dao&quot;&gt;管道&lt;&#x2F;h3&gt;
&lt;p&gt;pipe() &lt;strong&gt;创建了一个文件&lt;&#x2F;strong&gt; 放在内存中 特殊的文件可供读写的一段存储空间&lt;&#x2F;p&gt;
&lt;p&gt;使用文件描述符去操作管道
int fd[2]：&lt;&#x2F;p&gt;
&lt;p&gt;fd的两个元素 fd[0]读取内容 fd[1]写内容 两个文件描述符操作一个管道&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;操作系统对于文件描述符的分配： 在所有的整数中取最小的整数 0 1 2 被使用过了 所以是 3和4分别为 fd[0] fd[1]&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Pipe(fd)&lt;&#x2F;p&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;fcntl.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;

int main() {
    int fd[2];
    pipe (fd);
    int pid = fork();
   if (pid == 0) {
    &amp;#x2F;&amp;#x2F;char* receive = (char*) malloc (100*sizeof(char));
    int *num = (int*) malloc (2*sizeof(int));
    read(fd[0], num, 2*sizeof(int));
    &amp;#x2F;&amp;#x2F;printf(&amp;quot;form father receive is :%s&amp;quot;,receive);
    printf(&amp;quot;the receive is %d,%d\n&amp;quot;,*num,*(num + 1));
   }
   else {
   &amp;#x2F;&amp;#x2F;char test[] = &amp;quot;hello world&amp;quot;;
   int num[4] = {8,4,2,1};
   write(fd[1],num,4*sizeof(int));
   }
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dup()&lt;&#x2F;code&gt; 系统调用用于复制一个文件描述符。 会创建一个新的文件描述符，指向与原始文件描述符相同的文件或资源。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;li-jie-ming-ling-wc&quot;&gt;理解命令wc&lt;&#x2F;h4&gt;
&lt;p&gt;示例程序:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int p[2];
char *argv[2];
argv[0] = &amp;quot;wc&amp;quot;;
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]); &amp;#x2F;&amp;#x2F;利用文件描述符性质，这个dup会占用最小整数0的文件描述符
    close(p[0]);
    close(p[1]);
    exec(&amp;quot;&amp;#x2F;bin&amp;#x2F;wc&amp;quot;, argv);
} else {
    write(p[1], &amp;quot;hello world\n&amp;quot;, 12);
    close(p[0]);
    close(p[1]);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;wen-ti&quot;&gt;问题：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么要close(0)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;当打开一个新文件或复制一个文件描述符时，系统会分配 &lt;strong&gt;最小的可用文件描述符&lt;&#x2F;strong&gt;。
例如：
&lt;ul&gt;
&lt;li&gt;如果文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt; 被关闭，那么下一个可用的文件描述符就是 &lt;code&gt;0&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;如果文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt; 已经被占用，系统会分配下一个可用的文件描述符（如 &lt;code&gt;3&lt;&#x2F;code&gt;、&lt;code&gt;4&lt;&#x2F;code&gt; 等）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;为什么不直接使用p[0]呢？？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jie-da&quot;&gt;解答：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确保 &lt;code&gt;dup(p[0])&lt;&#x2F;code&gt; 复制到文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不关闭标准输入，文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt; 仍然指向默认的标准输入（通常是终端）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;dup(p[0])&lt;&#x2F;code&gt; 时，系统会分配一个可用的文件描述符（如 &lt;code&gt;3&lt;&#x2F;code&gt;），而不是文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这样，&lt;code&gt;wc&lt;&#x2F;code&gt; 命令仍然会从终端读取输入，而不是从管道读取数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;wc&lt;&#x2F;code&gt; 命令默认从 标准输入（文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt;） 读取数据&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果直接使用 &lt;code&gt;p[0]&lt;&#x2F;code&gt;，&lt;code&gt;wc&lt;&#x2F;code&gt; 仍然会从标准输入读取数据，而不是从 &lt;code&gt;p[0]&lt;&#x2F;code&gt; 读取。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这意味着 &lt;code&gt;wc&lt;&#x2F;code&gt; 会等待用户从终端输入数据，而不是从管道读取数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;（2）文件描述符的语义&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文件描述符 &lt;code&gt;0&lt;&#x2F;code&gt; 是标准输入，许多程序（如 &lt;code&gt;wc&lt;&#x2F;code&gt;、&lt;code&gt;cat&lt;&#x2F;code&gt; 等）都依赖于这一约定。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果直接使用 &lt;code&gt;p[0]&lt;&#x2F;code&gt;，需要修改 &lt;code&gt;wc&lt;&#x2F;code&gt; 的源代码，使其从 &lt;code&gt;p[0]&lt;&#x2F;code&gt; 读取数据，而不是标准输入。这是不现实的，因为无法修改所有命令行工具的源代码。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wc&lt;&#x2F;code&gt; 命令仍然从标准输入读取数据，但它实际上是从管道读取数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;总结： 关闭标准输入并使用 &lt;code&gt;dup(p[0])&lt;&#x2F;code&gt; 的目的是将管道的读端重定向到标准输入。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Ctrl+D&lt;&#x2F;code&gt;，如果你在命令行直接按 &lt;code&gt;Ctrl+D&lt;&#x2F;code&gt;，用于表示 &lt;strong&gt;End of File (EOF, 文件结束)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pingpong-c&quot;&gt;pingpong.c&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;


int
main(int argc,char* argv[])
{
int fd[2];
pipe(fd);

if (fork() == 0)
{
read(fd[0],&amp;quot;received ping\n&amp;quot;,14);
close(fd[1]);
write(fd[1],&amp;quot;pong&amp;quot;,4);
exit(0)
}else
{
write(fd[1],&amp;quot;ping&amp;quot;,4);
close(fd[0]);
read(fd[0],&amp;quot;recdived pong\n&amp;quot;,5);
close(fd[0]);
}
wait(0);
exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一次写出来的 错误代码！&lt;&#x2F;p&gt;
&lt;p&gt;最终修改：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;

&amp;#x2F;*对于错误处理第一次整体都没有判断 read write pipe*&amp;#x2F;
int
main(int argc,char* argv[])
{

char buf[5];
int fd[2];

if (pipe(fd) &amp;lt; 0)
{
fprintf(2, &amp;quot;pipe failed\n&amp;quot;);
exit(1);
}

if (fork() == 0)
{
read(fd[0],buf,4);
buf[4] = &amp;#x27;\0&amp;#x27;;
printf(&amp;quot;%d received %s\n&amp;quot;,getpid(),buf);
close(fd[0]);
write(fd[1],&amp;quot;pong&amp;quot;,4);
close(fd[1]);
exit(0);
}else
{
write(fd[1],&amp;quot;ping&amp;quot;,4);
close(fd[1]);
read(fd[0],buf,4);
buf[4] = &amp;#x27;\0&amp;#x27;; &amp;#x2F;&amp;#x2F; 添加空字符 忘记添加了
printf(&amp;quot;%d: received %s\n&amp;quot;,getpid(),buf);
close(fd[0]);
}
wait(0);
exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;我觉得这段程序可能会导致父子进程之间的相互竞争&lt;&#x2F;em&gt; 事实可能也是这样&lt;&#x2F;p&gt;
&lt;p&gt;重点：&lt;&#x2F;p&gt;
&lt;p&gt;正确使用 &lt;code&gt;pipe&lt;&#x2F;code&gt;、&lt;code&gt;fork&lt;&#x2F;code&gt;、&lt;code&gt;read&lt;&#x2F;code&gt; 和 &lt;code&gt;write&lt;&#x2F;code&gt;，以及关闭文件描述符和等待子进程完成&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;

int
main(int argc, char *argv[])
{
  int p1[2];
  int p2[2];
  if (-1 == pipe(p1) || -1 == pipe(p2)) {
    write(2, &amp;quot;error\n&amp;quot;, 6);
  }

  if (fork() == 0) {
    char buf[1];
    read(p2[0], buf, 1);
    printf(&amp;quot;%d: received ping\n&amp;quot;, getpid());
    write(p1[1], &amp;quot;x&amp;quot;, 1);
  } else {
    write(p2[1], &amp;quot;x&amp;quot;, 1);
    char buf[1];
    read(p1[0], buf, 1);
    printf(&amp;quot;%d: received pong\n&amp;quot;, getpid());
  }
  exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是取巧的一段代码&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;第一次程序出现的问题：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;父进程没有等待子进程完成&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;父进程在读取 &lt;code&gt;pong&lt;&#x2F;code&gt; 后直接退出，没有调用 &lt;code&gt;wait(0)&lt;&#x2F;code&gt; 等待子进程完成。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这可能导致子进程的输出被截断，或者父进程提前退出。
&lt;strong&gt;第二次程序：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;添加wait（）等待子进程完成操作，避免造成竞争&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;wen-jian-miao-shu-fu-de-yi-huo&quot;&gt;文件描述符的疑惑&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;if(fork() == 0) {
    write(1, &amp;quot;hello &amp;quot;, 6);
    exit();
} else {
    wait();
    write(1, &amp;quot;world\n&amp;quot;, 6);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段程序子进程使用1这个文件描述符后没有关闭，会不会导致父进程无法使用1这个文件描述符呢&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jie-da-1&quot;&gt;解答：&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;每个进程都有自己独立的文件描述符表。子进程通过 `fork()` 创建时，会继承父进程的文件描述符表，但子进程和父进程的文件描述符是相互独立的。子进程对文件描述符的操作（如写入、关闭）不会影响父进程的文件描述符。

当子进程调用 `exit()` 退出时，操作系统会关闭子进程打开的所有文件描述符。这些关闭操作仅限于子进程，不会影响父进程的文件描述符。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为：&lt;&#x2F;p&gt;
&lt;p&gt;每个进程可以打开的文件描述符数量是有限的（由系统配置决定，可以通过 &lt;code&gt;ulimit -n&lt;&#x2F;code&gt; 查看）。如果不关闭文件描述符，可能会导致文件描述符泄漏，最终耗尽系统资源。&lt;&#x2F;p&gt;
&lt;p&gt;在编写pingpong.c时：&lt;&#x2F;p&gt;
&lt;p&gt;因为是对&lt;em&gt;管道的读写&lt;&#x2F;em&gt;，&lt;em&gt;管道的读写&lt;&#x2F;em&gt;操作是阻塞的。如果不关闭文件描述符，可能会导致进程一直等待，无法正常结束。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果父进程不关闭 &lt;code&gt;fd[1]&lt;&#x2F;code&gt;，子进程的 &lt;code&gt;read(fd[0], buf, 4)&lt;&#x2F;code&gt; 可能会一直等待，因为父进程的 &lt;code&gt;fd[1]&lt;&#x2F;code&gt; 仍然打开，子进程无法确定父进程是否已经完成写入。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果子进程不关闭 &lt;code&gt;fd[1]&lt;&#x2F;code&gt;，父进程的 &lt;code&gt;read(fd[0], buf, 4)&lt;&#x2F;code&gt; 可能会一直等待，因为子进程的 &lt;code&gt;fd[1]&lt;&#x2F;code&gt; 仍然打开，父进程无法确定子进程是否已经完成写入。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;管道的设计遵循以下规则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果写入端（&lt;code&gt;fd[1]&lt;&#x2F;code&gt;）关闭，读取端（&lt;code&gt;fd[0]&lt;&#x2F;code&gt;）的 &lt;code&gt;read()&lt;&#x2F;code&gt; 会返回 &lt;code&gt;0&lt;&#x2F;code&gt;，表示没有更多数据可读（即文件结束，EOF）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果读取端（&lt;code&gt;fd[0]&lt;&#x2F;code&gt;）关闭，写入端（&lt;code&gt;fd[1]&lt;&#x2F;code&gt;）的 &lt;code&gt;write()&lt;&#x2F;code&gt; 会触发 &lt;code&gt;SIGPIPE&lt;&#x2F;code&gt; 信号，通常导致写入进程终止。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;这并不是通过信号实现的&lt;&#x2F;strong&gt;，而是通过管道的文件描述符状态实现的。
如果父进程关闭了 &lt;code&gt;fd[1]&lt;&#x2F;code&gt;，子进程的 &lt;code&gt;read()&lt;&#x2F;code&gt; 会返回 &lt;code&gt;0&lt;&#x2F;code&gt;，表示管道已经关闭，没有更多数据可读。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xin-hao-yu-guan-dao-de-qu-bie&quot;&gt;&lt;strong&gt;信号与管道的区别&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号&lt;&#x2F;strong&gt;：是一种异步通知机制，用于通知进程发生了某些事件（如 &lt;code&gt;SIGINT&lt;&#x2F;code&gt;、&lt;code&gt;SIGTERM&lt;&#x2F;code&gt; 等）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;管道&lt;&#x2F;strong&gt;：是一种同步通信机制，通过文件描述符的状态（如关闭写入端）来通知读取端&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wen-jian-xi-tong&quot;&gt;文件系统&lt;&#x2F;h3&gt;
&lt;p&gt;文件就是一个简单的字节数组，&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chdir()&lt;&#x2F;code&gt; 是一个系统调用，用于改变当前进程的工作目录。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;primes-c&quot;&gt;primes.c&lt;&#x2F;h3&gt;
&lt;p&gt;第一次尝试&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void fork(int *father_pipe)
{
    int n;
    int pid = fork();
    int son_pipe[2];
    pipe[son_pipe];

    if (pid == 0)
    {
        while (1)
        {
            read(father_pipe[0], &amp;amp;n, sizeof(n));
            for (int i = 2; i &amp;lt; 35; i++)
            {
                if (n % i != 0)
                {
                    write(son_pipe[1], &amp;amp;n, sizeof(n));
                }
            }
        }
        close(father_pipe[0]);
        close(son_pipe[1]);
    }
    else
    {
        int st;
        wait(&amp;amp;st);
    }
}

int main(int argc, char *argv[])
{
    int fd[2];
    int buf[36];
    pipe[fd];

    for (int i = 2; i &amp;lt;= 35; i++)
    {
        write(fd[1], &amp;amp;i, sizeof(i));
    }
    close(fd[1]);
    f(fd);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我的思想：&lt;&#x2F;p&gt;
&lt;p&gt;父亲传入数据到管道的时候，在函数中应该需要先&lt;em&gt;fork出一个子进程&lt;&#x2F;em&gt; 来与&lt;em&gt;父进程通信&lt;&#x2F;em&gt;读取，并且我对从管道中读取数据也有点模糊，是一口气全部读出来，还是一个个读取然后做处理，我是想对所有的数字依次被2-35除然后筛选一层层向子进程传递，并最终打印出最终结果&lt;&#x2F;p&gt;
&lt;p&gt;以下是我的想法，并能求出的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;
#include &amp;quot;stddef.h&amp;quot;


void create_child(int *input_pipe, int divisor) {
    int output_pipe[2];
    pipe(output_pipe); &amp;#x2F;&amp;#x2F; 创建输出管道

    int pid = fork(); &amp;#x2F;&amp;#x2F; 创建子进程
    if (pid == 0) {
        &amp;#x2F;&amp;#x2F; 子进程
        close(input_pipe[1]); &amp;#x2F;&amp;#x2F; 关闭父进程的写入端
        close(output_pipe[0]); &amp;#x2F;&amp;#x2F; 关闭子进程的读取端

        int num;
        while (read(input_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) {
            if (num % divisor != 0 || num == divisor) {
                &amp;#x2F;&amp;#x2F; 如果不能被当前除数整除，或者数字是当前除数本身，传递给下一个子进程
                write(output_pipe[1], &amp;amp;num, sizeof(num));
            }
        }

        close(input_pipe[0]); &amp;#x2F;&amp;#x2F; 关闭父进程的读取端
        close(output_pipe[1]); &amp;#x2F;&amp;#x2F; 关闭子进程的写入端
        exit(0);
    } else {
        &amp;#x2F;&amp;#x2F; 父进程
        close(input_pipe[0]); &amp;#x2F;&amp;#x2F; 关闭父进程的读取端
        close(output_pipe[1]); &amp;#x2F;&amp;#x2F; 关闭子进程的写入端

        if (divisor &amp;gt;= 35) {
            int num;
            while (read(output_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) {
                printf(&amp;quot;prime %d\n&amp;quot;, num); &amp;#x2F;&amp;#x2F; 打印质数
            }
            close(output_pipe[0]); &amp;#x2F;&amp;#x2F; 关闭读取端
        } else {
            &amp;#x2F;&amp;#x2F; 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
        }
    }
}

int main() {
    int fd[2];
    pipe(fd); &amp;#x2F;&amp;#x2F; 创建初始管道

    &amp;#x2F;&amp;#x2F; 将数字 2 到 35 写入管道
    for (int i = 2; i &amp;lt;= 35; i++) {
        write(fd[1], &amp;amp;i, sizeof(i));
    }
    close(fd[1]); &amp;#x2F;&amp;#x2F; 关闭写入端

    &amp;#x2F;&amp;#x2F; 创建第一个子进程，从 2 开始筛选
    create_child(fd, 2);

    &amp;#x2F;&amp;#x2F; 父进程等待所有子进程结束
    while (wait(NULL) &amp;gt; 0);

    return 0;
}这段程序并不能正常打印出6.s081课程的素数题目的最终结果，我还应该怎么修改？
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段程序的错误：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;筛选条件&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;递归逻辑问题：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;正确的做法应该是每个子进程从输入管道中读取第一个数作为新的&lt;code&gt;divisor&lt;&#x2F;code&gt;（质数），然后用它筛选后续的数。而原代码强制&lt;code&gt;divisor&lt;&#x2F;code&gt;递增，导致后续进程可能使用非质数作为除数&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;打印时机：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;只有当&lt;code&gt;divisor &amp;gt;=35&lt;&#x2F;code&gt;时，父进程才会读取&lt;code&gt;output_pipe&lt;&#x2F;code&gt;并打印结果。这意味着只有最后一个进程才会打印，而实际上每个进程应负责打印自己筛选出的质数（即第一个接收到的数）&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-1-1&quot;&gt;问题 1：&lt;&#x2F;h4&gt;
&lt;p&gt;read(input_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0 我并不理解有时候 在read和write中括号后面时常会出现 &amp;gt;0 =0 &amp;lt;0 都是什么意思？ 用while循环的目的又是什么&lt;&#x2F;p&gt;
&lt;p&gt;如何处理对于本身 例如： 2 % 2 == 0 ！&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jie-da-1-1&quot;&gt;解答 1：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;read：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;gt; 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：成功读取了数据，返回值是实际读取的字节数。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;= 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：读取到文件结束（EOF），表示写入端已经关闭，没有更多数据可读。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt; 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：读取失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;write：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;gt; 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：成功写入了数据，返回值是实际写入的字节数。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;= 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：没有写入任何数据（通常不会发生，除非 &lt;code&gt;count&lt;&#x2F;code&gt; 为 0）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt; 0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：写入失败，通常是由于错误（如文件描述符无效、管道被意外关闭等）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;while (read(input_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0)&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;持续从 &lt;code&gt;input_pipe[0]&lt;&#x2F;code&gt; 中读取数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果读取成功（&lt;code&gt;read()&lt;&#x2F;code&gt; 返回 &lt;code&gt;&amp;gt; 0&lt;&#x2F;code&gt;），则处理数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;回答2：&lt;&#x2F;p&gt;
&lt;p&gt;直接传递给下一个进程&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-2-1&quot;&gt;问题 2：&lt;&#x2F;h4&gt;
&lt;p&gt;不理解这里的&lt;em&gt;数据是一次性全部传入管道一次性读取还是 父进程传入一个数据经过处理后然后再读取&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jie-da-2&quot;&gt;解答 2：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;理解管道特性&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;管道是一种 &lt;strong&gt;先进先出（FIFO）&lt;&#x2F;strong&gt; 的通信机制。数据写入管道后，会按照写入的顺序依次被读取。管道的读写是 &lt;strong&gt;阻塞的&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果管道为空，读取端会阻塞，直到有数据写入。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果管道已满，写入端会阻塞，直到有数据被读取。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;代码中数据是一次性全部写入管道的， 当父进程&lt;em&gt;关闭写入端，表示数据写入完成&lt;&#x2F;em&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;子进程从管道中 &lt;strong&gt;逐个读取数据&lt;&#x2F;strong&gt;，而不是一次性读取所有数据。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;每读取一个数据，就根据 &lt;code&gt;divisor&lt;&#x2F;code&gt; 进行筛选，并将筛选后的数据写入下一个管道。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;子进程：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逐个处理&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个子进程从管道中 &lt;strong&gt;逐个读取数据&lt;&#x2F;strong&gt;，处理后再写入下一个管道。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;数据是 &lt;strong&gt;流式处理&lt;&#x2F;strong&gt; 的，而不是一次性全部读取。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;批量处理&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果管道中有多个数据，子进程会逐个读取并处理，直到管道为空。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;he-xin-dai-ma&quot;&gt;核心代码：&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt; while (read(input_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) {
            if (num == divisor) {
                &amp;#x2F;&amp;#x2F; 如果是当前除数本身，直接传递给下一个子进程
                write(output_pipe[1], &amp;amp;num, sizeof(num));
            } else if (num % divisor != 0) {
                &amp;#x2F;&amp;#x2F; 如果不能被当前除数整除，传递给下一个子进程
                write(output_pipe[1], &amp;amp;num, sizeof(num));
            }
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为什么可以持续的读，可以自动检测读完吗？&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt; while (read(output_pipe[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) {
                printf(&amp;quot;primes: %d\n&amp;quot;, num); &amp;#x2F;&amp;#x2F; 打印质数
            }
            close(output_pipe[0]); &amp;#x2F;&amp;#x2F; 关闭读取端
        } else {
            &amp;#x2F;&amp;#x2F; 将子进程的输出管道作为下一个子进程的输入管道
            create_child(output_pipe, divisor + 1);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;重点解释：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;管道的写入端关闭

 当父进程写入数据并关闭写入端时，管道的写入端会被标记为关闭。
    
 关闭写入端后，读取端的 `read()` 行为会发生变化：
    
 如果管道中还有数据，`read()` 会继续读取数据。
        
 如果管道中没有数据，`read()` 会返回 `0`，表示写入端已经关闭，没有更多数据可读。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;- 管道的内部实现会跟踪写入端的状态。
    
- 当写入端关闭时，操作系统会通知读取端，表示没有更多数据会写入管道。
    
- 如果读取端尝试读取数据，但管道中没有数据且写入端已关闭，`read()` 会返回 `0`。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;chu-hu-yi-liao&quot;&gt;出乎意料&lt;&#x2F;h4&gt;
&lt;p&gt;这段程序并没有成功打印出结果！&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;重新修改 primes.c&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;

void create_child(int parent_fd[]) {
    int p;
    &amp;#x2F;&amp;#x2F; 读取第一个数字，它一定是质数
    if (read(parent_fd[0], &amp;amp;p, sizeof(p)) == 0) {
        close(parent_fd[0]);
        exit(0);
    }
    printf(&amp;quot;prime %d\n&amp;quot;, p); &amp;#x2F;&amp;#x2F; 立即打印当前质数

    int child_fd[2];
    pipe(child_fd);

    if (fork() == 0) {
        &amp;#x2F;&amp;#x2F; 子进程：关闭不必要的文件描述符，递归处理
        close(parent_fd[0]);
        close(child_fd[1]);
        create_child(child_fd);
        exit(0);
    } else {
        &amp;#x2F;&amp;#x2F; 父进程：过滤并传递剩余数字
        close(child_fd[0]);
        int num;
        while (read(parent_fd[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) {
            if (num % p != 0) {
                write(child_fd[1], &amp;amp;num, sizeof(num));
            }
        }
        close(parent_fd[0]);
        close(child_fd[1]);
        wait(0); &amp;#x2F;&amp;#x2F; 等待子进程结束
    }
}

int main() {
    int initial_fd[2];
    pipe(initial_fd);

    for (int i = 2; i &amp;lt;= 35; i++) {
        write(initial_fd[1], &amp;amp;i, sizeof(i));
    }
    close(initial_fd[1]);

    create_child(initial_fd);

    &amp;#x2F;&amp;#x2F; 确保所有子进程结束
    while (wait(0) &amp;gt; 0);
    exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;疑问：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;while (read(parent_fd[0], &amp;amp;num, sizeof(num)) &amp;gt; 0) { if (num % p != 0) { write(child_fd[1], &amp;amp;num, sizeof(num)); } } 
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段程序不是也会把2等过滤掉吗&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;管道是队列结构&lt;&#x2F;strong&gt;​&lt;br &#x2F;&gt;
管道（Pipe）本质上是一个&lt;strong&gt;先进先出（FIFO）的字节流&lt;&#x2F;strong&gt;。每次调用 &lt;code&gt;read&lt;&#x2F;code&gt; 读取数据时，读取过的数据会从管道中移除，后续的 &lt;code&gt;read&lt;&#x2F;code&gt; 操作只会读取未被读取的数据。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-chu-zhong-ding-xiang&quot;&gt;输出重定向&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;redirect-c&quot;&gt;redirect.c&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;7d19d7e4-f139-4902-8975-65a70cc2d956&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;你不必成为专家， 你花费大量时间开发维护和调试，会了解很多操作系统的知识，
ls &amp;gt; out 输出重定向
echo hello &amp;gt; out
cat &amp;lt; out
子进程调用exit(1) -&amp;gt; 父进程会接受到子进程的退出&lt;br &#x2F;&gt;
exec会丢弃所有复制的内存，并将其替换为
思考fork的副本复制 复制了所有的内存 所花费的时间
虚拟内存映射
为子进程分配权重&lt;&#x2F;p&gt;
&lt;p&gt;观看完第一集视频，看完第一章内容，还剩两道题没有做&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;find-c&quot;&gt;find.c&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;li-jie-ls-c-cheng-xu&quot;&gt;&lt;em&gt;理解 ls.c 程序：&lt;&#x2F;em&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;em&gt;理解 ls.c 程序：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;......写起来有点费劲，不太理解&lt;&#x2F;p&gt;
&lt;p&gt;寻求博客帮助：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.sheniao.top&#x2F;os&#x2F;68.html#morphing&quot;&gt;有帮助的博客1.&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;diana-learningcpp&#x2F;p&#x2F;15579535.html&quot;&gt;有帮助的博客2.&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在 Linux 中，只使用 ls 并不会显示 &lt;code&gt;.&lt;&#x2F;code&gt; 和 &lt;code&gt;..&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;-a：显示所有文件及目录 (ls 内定将文件名或目录名称开头为 &quot;.&quot; 的视为隐藏档，不会列出)&lt;&#x2F;li&gt;
&lt;li&gt;-A：同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;ls.c程序&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fmtname()&lt;&#x2F;code&gt; 函数&lt;&#x2F;strong&gt;：格式化文件名。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ls()&lt;&#x2F;code&gt; 函数&lt;&#x2F;strong&gt;：遍历目录并打印文件信息。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;main()&lt;&#x2F;code&gt; 函数&lt;&#x2F;strong&gt;：解析命令行参数并调用 &lt;code&gt;ls()&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fmtname()&lt;&#x2F;code&gt; 函数&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;char* fmtname(char *path) {
    static char buf[DIRSIZ+1];
    char *p;

    &amp;#x2F;&amp;#x2F; 找到最后一个斜杠后的字符
    for(p = path + strlen(path); p &amp;gt;= path &amp;amp;&amp;amp; *p != &amp;#x27;&amp;#x2F;&amp;#x27;; p--)
        ;
    p++;

    &amp;#x2F;&amp;#x2F; 返回格式化后的文件名
    if(strlen(p) &amp;gt;= DIRSIZ)
        return p;
    memmove(buf, p, strlen(p));
    memset(buf + strlen(p), &amp;#x27; &amp;#x27;, DIRSIZ - strlen(p));
    return buf;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从路径末尾向前查找最后一个斜杠（&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;），找到文件名起始位置。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果文件名长度超过 &lt;code&gt;DIRSIZ&lt;&#x2F;code&gt;，直接返回文件名。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;否则，将文件名复制到 &lt;code&gt;buf&lt;&#x2F;code&gt; 中，并用空格填充剩余部分。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;思路：&lt;&#x2F;p&gt;
&lt;p&gt;首先确定递归的边界条件之一：第一个参数dir_name是一个文件名。使用fmtname（需要修改一下）处理文件名之后直接比对即可，然后返回函数。find遍历目录的方式和ls基本相同。遍历目录时，遇到.和..两个文件要跳过，遇到文件时就和file_name比对，如果相同就打印这个文件的相对路径。如果遇到了目录，就递归调用search函数。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;中途思考：printf 和 write(1)的区别&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;printf&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;write(1, ...)&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;功能&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;格式化输出&lt;&#x2F;td&gt;&lt;td&gt;原始数据输出&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;缓冲机制&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;有缓冲（行缓冲或全缓冲）&lt;&#x2F;td&gt;&lt;td&gt;无缓冲&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;易用性&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;高（支持格式化字符串）&lt;&#x2F;td&gt;&lt;td&gt;低（需要手动计算长度）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;性能&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;较慢（由于缓冲和格式化开销）&lt;&#x2F;td&gt;&lt;td&gt;较快（直接系统调用）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;适用场景&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;通用输出，适合大多数情况&lt;&#x2F;td&gt;&lt;td&gt;底层操作，适合精确控制输出的场景&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;zhi-zhen-yong-fa&quot;&gt;指针用法：&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;char buf[256] = &amp;quot;hello&amp;quot;;
char *p = buf + strlen(buf); &amp;#x2F;&amp;#x2F; p 指向 buf 中字符串的末尾
strcpy(p, &amp;quot; world&amp;quot;);         &amp;#x2F;&amp;#x2F; 在 buf 中追加 &amp;quot; world&amp;quot;
printf(&amp;quot;%s\n&amp;quot;, buf);         &amp;#x2F;&amp;#x2F; 输出 &amp;quot;hello world&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;struct-dirent-yong-fa&quot;&gt;struct dirent 用法&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;

int main() {
    DIR *dir = opendir(&amp;quot;.&amp;quot;);  &amp;#x2F;&amp;#x2F; 打开当前目录
    if (dir == NULL) {
        perror(&amp;quot;opendir failed&amp;quot;);
        return 1;
    }

    struct dirent de;
    while ((de = readdir(dir)) != NULL) {  &amp;#x2F;&amp;#x2F; 读取目录项
        printf(&amp;quot;File: %s\n&amp;quot;, de-&amp;gt;d_name);  &amp;#x2F;&amp;#x2F; 打印文件名
    }

    closedir(dir);  &amp;#x2F;&amp;#x2F; 关闭目录
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;de.inum == 0&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;目录项仍然存在，但 &lt;code&gt;inum&lt;&#x2F;code&gt; 为 &lt;code&gt;0&lt;&#x2F;code&gt;，表示该目录项是空闲的或无效的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;memmove(buf, p, strlen(p));&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将文件名从指针 &lt;code&gt;p&lt;&#x2F;code&gt; 指向的位置复制到缓冲区 &lt;code&gt;buf&lt;&#x2F;code&gt; 中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;quot;kernel&amp;#x2F;types.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;stat.h&amp;quot;
#include &amp;quot;user&amp;#x2F;user.h&amp;quot;
#include &amp;quot;kernel&amp;#x2F;fs.h&amp;quot;

char*
fmtname(char *path)
{
  static char buf[DIRSIZ+1];
  char *p;

  &amp;#x2F;&amp;#x2F; Find first character after last slash.
  for(p=path+strlen(path); p &amp;gt;= path &amp;amp;&amp;amp; *p != &amp;#x27;&amp;#x2F;&amp;#x27;; p--)
    ;
  p++;

  &amp;#x2F;&amp;#x2F; Return blank-padded name.
  if(strlen(p) &amp;gt;= DIRSIZ)
    return p;
  memmove(buf, p, strlen(p));
  memset(buf+strlen(p), &amp;#x27; &amp;#x27;, DIRSIZ-strlen(p));
  return buf;
}

void
find(char* dir_name, char* file_name)
{
char buf[256];
int fd;
struct stat st;
struct dirent de;


if(fd = open(dir_name,0))
{
    fprintf(2, &amp;quot;find cannot open dir %s\n&amp;quot;,dir_name);
    return;
}
if(fstat(fd,&amp;amp;st) &amp;lt; 0)
{
    fprintf(2,&amp;quot;find: cannot stat dir %s\n&amp;quot;,dir_name);
}
&amp;#x2F;&amp;#x2F;如果是文件则直接输出
if(st.type == T_FILE)
{
if(!strcmp(fmtname(dir_name),file_name))
{
    printf(&amp;quot;%s\n&amp;quot;,dir_name);
}
return;
}

&amp;#x2F;&amp;#x2F;如果是目录应该遍历目录下的文件
if(st.type = T_DIR)
{
if(strlen(dir_name) + 1 + DIRSIZ + 1 &amp;gt; sizeof(buf))
{
    printf(&amp;quot;find: path too long\n&amp;quot;);
    return;
}
}
    strcpy(buf, dir_name);
    p = buf + strlen(buf);&amp;#x2F;&amp;#x2F;定位指针
    *p++ = &amp;#x27;&amp;#x2F;&amp;#x27;;
struct stat st_temp;
while(read(fd,.&amp;amp;de,sizeof(de)) == sizeof(de))
{

if(de.inum == 0)
{
    continue;
}
    memmove(p,de.name,DIRSIZE);
    p[DIRSIZ] = 0;
if(stat(buf,&amp;amp;st_temp) &amp;lt; 0)
{
continue;
}

if(st_tmp.type==T_FILE)&amp;#x2F;&amp;#x2F;如果是普通文件
    {
        if(!strcmp(de.name,file_name))&amp;#x2F;&amp;#x2F;找到文件
        {
        printf(&amp;quot;%s\n&amp;quot;,buf);&amp;#x2F;&amp;#x2F;打印文件的相对路径
        }
    }
if(st_tmp.type==T_DIR)&amp;#x2F;&amp;#x2F;如果是目录
    {
        &amp;#x2F;&amp;#x2F;递归搜索，使用BFS遍历directory tree
        &amp;#x2F;&amp;#x2F;禁止遍历. .. 这两个目录
        if((!strcmp(de.name,this_dir))||(!strcmp(de.name,parent_dir)))
        continue;
        find(buf,file_name);&amp;#x2F;&amp;#x2F;递归搜索
    }
}
return;
}

int
main(int argc, char* argv[]){

if(argc &amp;lt; 3 ) {
    fprintf(2,&amp;quot;too few arguments\n&amp;quot;);
    exit(1);
}
find(argv[1],argv[2]);
exit(0);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一次完成代码： 有很多问题，代码格式还需要修改！&lt;&#x2F;p&gt;
&lt;p&gt;需要修改很多地方&lt;&#x2F;p&gt;
&lt;p&gt;关键点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while(read(...))&lt;&#x2F;code&gt; 循环遍历目录项，每次 &lt;code&gt;read&lt;&#x2F;code&gt; 取出一个 &lt;code&gt;de&lt;&#x2F;code&gt; 结构体，赋值给 &lt;code&gt;de.name&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;!strcmp(de.name, file_name)&lt;&#x2F;code&gt; 持续比较 &lt;code&gt;de.name&lt;&#x2F;code&gt; 和 &lt;code&gt;file_name&lt;&#x2F;code&gt;，匹配成功时打印路径。&lt;&#x2F;li&gt;
&lt;li&gt;递归调用 &lt;code&gt;find(buf, file_name)&lt;&#x2F;code&gt;，在子目录里重复上述过程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;正确代码已推送至仓库：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;6.s081&quot;&gt;我的6.s081仓库&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zong-jie-find-cxi-tong-diao-yong-han-shu&quot;&gt;总结find.c系统调用函数：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;find.c&lt;&#x2F;code&gt; 中使用的操作系统调用函数及其作用如下：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;&#x2F;th&gt;&lt;th&gt;作用&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;open&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;打开目录或文件。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;close&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;关闭文件描述符。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fstat&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;获取文件或目录的状态信息。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;read&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;读取目录项。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;stat&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;获取文件或目录的状态信息。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;strcmp&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;比较文件名。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;strcpy&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;复制路径字符串。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;memmove&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;复制文件名到缓冲区。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;memset&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;填充缓冲区。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;printf&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;输出文件路径或信息。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fprintf&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;输出错误信息到标准错误流。&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;xargs-c&quot;&gt;xargs.c&lt;&#x2F;h3&gt;
&lt;p&gt;如何将指令的结果 作为 参数传给xargs.c&lt;&#x2F;p&gt;
&lt;p&gt;指针含义&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;char *args[MAXARG]; &amp;#x2F;&amp;#x2F;  每个元素是一个 char*
args[argc - 1] = p; &amp;#x2F;&amp;#x2F;将 p 指向的字符串存入args数组的第 argc - 1个位置
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xargs&lt;&#x2F;code&gt; 的作用是将标准输入的内容作为参数，拼接到指定命令的后面。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;过程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始时，&lt;code&gt;p&lt;&#x2F;code&gt; 指向 &lt;code&gt;buf&lt;&#x2F;code&gt; 的开头，内容是 &lt;code&gt;hello too\n&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;跳过空白字符（如果有），这里没有前导空白。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;hello&lt;&#x2F;code&gt; 作为一个参数，存入 &lt;code&gt;args&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;args = [&quot;echo&quot;, &quot;bye&quot;, &quot;hello&quot;]&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;继续解析，将 &lt;code&gt;too&lt;&#x2F;code&gt; 作为一个参数，存入 &lt;code&gt;args&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;args = [&quot;echo&quot;, &quot;bye&quot;, &quot;hello&quot;, &quot;too&quot;]&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;遇到换行符 &lt;code&gt;\n&lt;&#x2F;code&gt;，解析结束。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在这个例子中：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo hello too&lt;&#x2F;code&gt; 输出 &lt;code&gt;hello too&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xargs&lt;&#x2F;code&gt; 读取 &lt;code&gt;hello too&lt;&#x2F;code&gt;，将其解析为参数 &lt;code&gt;hello&lt;&#x2F;code&gt; 和 &lt;code&gt;too&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;hello&lt;&#x2F;code&gt; 和 &lt;code&gt;too&lt;&#x2F;code&gt; 拼接到 &lt;code&gt;echo bye&lt;&#x2F;code&gt; 后面，形成 &lt;code&gt;echo bye hello too&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;最终输出 &lt;code&gt;bye hello too&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;’\0‘ 作为字符串的结束&lt;&#x2F;p&gt;
&lt;p&gt;关键代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;while ((n = read(0, buf, sizeof(buf))) {
        if (n &amp;lt; 0) {
            fprintf(2, &amp;quot;xargs: read error\n&amp;quot;);
            exit(1);
        }

        &amp;#x2F;&amp;#x2F; 将输入数据解析为参数
        char *p = buf;
        while (*p != &amp;#x27;\0&amp;#x27;) {
            &amp;#x2F;&amp;#x2F; 跳过空白字符
            while (*p == &amp;#x27; &amp;#x27; || *p == &amp;#x27;\n&amp;#x27;) {
                *p++ = &amp;#x27;\0&amp;#x27;;
            }

            &amp;#x2F;&amp;#x2F; 如果遇到非空白字符，将其作为参数
            if (*p != &amp;#x27;\0&amp;#x27;) {
                args[argc - 1] = p;
                argc++;
                while (*p != &amp;#x27;\0&amp;#x27; &amp;amp;&amp;amp; *p != &amp;#x27; &amp;#x27; &amp;amp;&amp;amp; *p != &amp;#x27;\n&amp;#x27;) {
                    p++;
                }
            }
        }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;今天执行程序测试的时候出现了问题：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;make: *** No rule to make target &amp;#x27;user&amp;#x2F;_xargs\&amp;#x27;, needed by &amp;#x27;fs.img&amp;#x27;. Stop.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就是xargs配置出现了问题 问题应该是在Makfile中&lt;&#x2F;p&gt;
&lt;p&gt;emmm 缩进使用的空格造成了问题！ 直接使用tab就好了&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt; ((n = read(0, buf, sizeof(buf))) &amp;gt; 0)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运算优先级&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;1-di-yi-ge-jin-cheng&quot;&gt;1. 第一个进程：&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;binlovetech&#x2F;p&#x2F;17571929.html&quot;&gt;很好的页表讲解&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;![[页表映射.png]]&lt;&#x2F;p&gt;
&lt;p&gt;xv6是如何开始运行的：&lt;&#x2F;p&gt;
&lt;p&gt;进程，它让一个程序可以假设它独占一台机器。进程向程序提供“看上去”私有的，其他进程无法读写的内存系统（或地址空间），以及一颗“看上去”仅执行该程序的CPU&lt;&#x2F;p&gt;
&lt;p&gt;xv6 使用页表 为每个进程提供其独有的地址空间。页表将_虚拟地址_&lt;em&gt;(x86 指令所使用的地址&lt;&#x2F;em&gt;) 翻译 为_物理地址_(&lt;em&gt;处理器芯片向主存发送的地址&lt;&#x2F;em&gt;)&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;shu-ju-jie-gou-fen-ye-biao&quot;&gt;数据结构： 分页表&lt;&#x2F;h3&gt;
&lt;p&gt;用于计算机 操作系统中的 &lt;em&gt;虚拟内存 系统&lt;&#x2F;em&gt;，其&lt;em&gt;存储了虚拟地址到物理地址间的映射&lt;&#x2F;em&gt;。虚拟地址在访问进程中是唯一的，而物理地址在硬件（比如内存)中是唯一的&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;操作系统中使用虚拟内存， 进程会认为 &lt;em&gt;自己使用了一块大的连续内存&lt;&#x2F;em&gt;，但是事实 每个进程的&lt;em&gt;内存散布在 物理内存 的不同区域&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;进程和页表都存储在内存中，查询进程数据时，需要访问两次内存， 放入寄存器中加快查询速度&lt;&#x2F;p&gt;
&lt;p&gt;操作系统负责把程序生成的虚拟地址，映射到实际存储的物理内存上  存储虚拟地址到物理地址的映射&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;3963fdd5-c8be-4808-b291-bbb7af5afb9e&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;xv6 为每个进程维护了不同的页表&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;41bf1ee9-618f-491b-beaa-afcdbbc1de90&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程： 每个进程都有一个运行线程 来执行进程的指令 &lt;em&gt;线程可以被暂时挂起，稍后再恢复运行&lt;&#x2F;em&gt;   系统在&lt;em&gt;进程之间切换&lt;&#x2F;em&gt; 实际上就是&lt;em&gt;挂起&lt;&#x2F;em&gt;当前运行的&lt;em&gt;线程&lt;&#x2F;em&gt;，&lt;em&gt;恢复&lt;&#x2F;em&gt;另一个进程的&lt;em&gt;线程&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;进程的组成： 每个进程都有 &lt;em&gt;用户栈&lt;&#x2F;em&gt;  和  &lt;em&gt;内核栈&lt;&#x2F;em&gt; ： 进程运行&lt;em&gt;用户指令&lt;&#x2F;em&gt;时，只有其&lt;em&gt;用户栈被使用&lt;&#x2F;em&gt;，其内核栈则是空的，当进程（通过&lt;em&gt;系统调用或中断&lt;&#x2F;em&gt;）进入&lt;em&gt;内核&lt;&#x2F;em&gt;时，内核代码就在进程的&lt;em&gt;内核栈&lt;&#x2F;em&gt;中执行，进程处于内核中时，其&lt;em&gt;用户栈仍然保存着数据&lt;&#x2F;em&gt;，只是&lt;em&gt;暂时处于不活跃状态&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;线程&lt;em&gt;交替地使用&lt;&#x2F;em&gt;着用户栈和内核栈 内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，&lt;em&gt;内核也能保持运行&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码， 当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级，转入用户栈 线程可以在内核中“阻塞”，等待 I&#x2F;O, 在 I&#x2F;O 结束后再恢复运行&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;p-&amp;gt;state&lt;&#x2F;code&gt; 指示了进程的状态：新建、准备运行、运行、等待 I&#x2F;O 或退出状态中&lt;&#x2F;p&gt;
&lt;p&gt;PC 开机时：  从磁盘中载入 &lt;em&gt;boot loader&lt;&#x2F;em&gt; 到内存并运行 &lt;em&gt;boot loader&lt;&#x2F;em&gt; 把 xv6 内核从磁盘中载入并从 &lt;code&gt;entry&lt;&#x2F;code&gt;（1040）开始运行&lt;&#x2F;p&gt;
&lt;p&gt;分页硬件在此时还没有开始工作；所以这时的虚拟地址是直接映射到物理地址上的&lt;&#x2F;p&gt;
&lt;p&gt;boot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I&#x2F;O 设备的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;88b08622-7de2-4d0b-90d2-7ba6c921fc46&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;为了让内核的剩余部分能够运行，&lt;code&gt;entry&lt;&#x2F;code&gt; 的代码设置了页表 将 0x80000000开始的虚拟地址映射到物理地址 0x0 处 页表经常会这样把两段不同的虚拟内存映射到相同的一段物理内存&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;lab3&quot;&gt;lab3 ：&lt;&#x2F;h2&gt;
&lt;p&gt;多路复用 隔离&lt;&#x2F;p&gt;
&lt;p&gt;将一个cpu抽象为一个进程 4核心就是同时或并行四个进程每个核心上都有一个进程 不同的进程之间进行时间复用&lt;&#x2F;p&gt;
&lt;p&gt;exec： 抽象了内存 内存映像
files： 抽象了磁盘块&lt;br &#x2F;&gt;
proc.c 有关多路复用
Strong isolation between apps + os&lt;&#x2F;p&gt;
&lt;p&gt;User&#x2F;kernel modev&lt;&#x2F;p&gt;
&lt;p&gt;cpu vitual memory：&lt;&#x2F;p&gt;
&lt;p&gt;page table  将虚拟地址 映射到 物理地址&lt;&#x2F;p&gt;
&lt;p&gt;查看 kernel&#x2F;kernel.asm&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gdbdiao-shi&quot;&gt;*gdb调试：&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;8d087a24-c559-4809-9e9d-3a499cd1a26a&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;使用 &lt;code&gt;gdb-multiarch&lt;&#x2F;code&gt; 指令开启gdb 并且使用 &lt;code&gt;target remote :25000&lt;&#x2F;code&gt; 连接到qemu&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;53393104-daef-49a8-a763-a9be02dff4f7&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;视频中老师使用的linux版本并不是ubuntu 所以指令在ubuntu中并不适用，需要更改！！&lt;&#x2F;p&gt;
&lt;p&gt;首先要手动读取内核：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;file kernel&#x2F;kernel&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;之后就可以看到详细的输出了 但是没有视频中的纤细输出&lt;&#x2F;p&gt;
&lt;p&gt;b ~~  给某个位置打断点&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;b _entry&lt;&#x2F;code&gt; &lt;code&gt;b main&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;c&lt;&#x2F;code&gt;  (Continue) - 继续执行直到下一个断点&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;si&lt;&#x2F;code&gt;  (Step Instruction) - 单步执行一条汇编指令&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;n&lt;&#x2F;code&gt; (Next) - 单步执行一行源代码&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;6aa9c086-a65d-49bb-95e1-2cb0216dcc13&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;layout asm&lt;&#x2F;code&gt;  :&lt;&#x2F;p&gt;
&lt;p&gt;纯汇编视图&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;只显示&lt;strong&gt;汇编指令&lt;&#x2F;strong&gt;，适用于低级调试（如 OS 内核、Bootloader）。&lt;&#x2F;li&gt;
&lt;li&gt;适合用 &lt;code&gt;si&lt;&#x2F;code&gt;（单步执行指令）进行逐条汇编指令调试。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;**&lt;code&gt;layout split&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;源代码 + 汇编混合视图&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;上半部分&lt;&#x2F;strong&gt;：显示源码（C 代码）。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;下半部分&lt;&#x2F;strong&gt;：显示对应的&lt;strong&gt;汇编指令&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;适用于调试 C 语言时，同时观察 C 代码和编译后的汇编代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;ctrl + x a 退出&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;lab-2-system-calls&quot;&gt;lab 2： System-calls&lt;&#x2F;h2&gt;
&lt;p&gt;测评脚本修改为：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo python3 grade-lab-syscall trace
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;system-call-tracing&quot;&gt;System call tracing&lt;&#x2F;h4&gt;
&lt;p&gt;添加一个系统调用跟踪功能，该功能可能会在调试后续实验时为您提供帮助&lt;&#x2F;p&gt;
&lt;h2 id=&quot;di-er-zhang-ye-biao&quot;&gt;*第二章：页表&lt;&#x2F;h2&gt;
&lt;p&gt;页表使得 xv6 能够让不同进程各自的地址空间映射到相同的物理内存上，还能够为不同进程的内存提供保护&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;cha-ru-xue-xi&quot;&gt;插入学习：&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;suo&quot;&gt;锁&lt;&#x2F;h4&gt;
&lt;p&gt;xv6 运行在多处理器上，即计算机上有多个单独执行代码的 CPU。这些 CPU 操作同一片地址空间并分享其中的数据结构；xv6 必须建立一种合作机制防止它们互相干扰。即使是在单个处理器上，xv6 也必须使用某些机制来&lt;em&gt;防止中断处理程序与非中断代码之间互相干扰&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;锁提供了互斥功能，保证某个时间点只有一个 CPU 能持有锁&lt;&#x2F;p&gt;
&lt;h4 id=&quot;guan-jian&quot;&gt;关键：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;你一定要问自己另一个处理器的存在是否会让这行代码无法达到期望的运行结果（因为另一个处理器也可能正在运行该行代码，或者另一行修改这个共享变量的代码），还要考虑如果这里执行一个中断处理程序，又会发生什么情况。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;一行 C 代码可能由多条机器指令组成，而另一个处理器或者中断可能在这些指令中间影响之。你不能假设这些代码是顺序执行的，也不能假设一个 C 指令是以原子操作执行的。并发使得考虑代码的正确性变得困难。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jing-zheng-tiao-jian&quot;&gt;竞争条件：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么我们需要锁？？&lt;&#x2F;p&gt;
&lt;p&gt;一段链表代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;struct list{
    int data;
    struct list *next;
};

struct list *list = 0;

void
insert(int data)
{
    struct list *l;
    l = malloc(sizeof *l);
    l-&amp;gt;data = data;
    l-&amp;gt;next = list;
    list = l;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;即使可以证明其正确性，实际上这种实现也是错误的，至少不能在多处理器上运行&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt; &lt;strong&gt;全局变量 &lt;code&gt;list&lt;&#x2F;code&gt; 的潜在问题&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;这意味着所有对链表的操作都会共享同一个 &lt;code&gt;list&lt;&#x2F;code&gt;。在多线程环境中，这可能会导致竞争条件（race condition），因为多个线程可能同时修改 &lt;code&gt;list&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wo-de-xiang-fa&quot;&gt;我的想法：&lt;&#x2F;h4&gt;
&lt;p&gt;如何模拟多线程 使这段原本正常运行的代码出现问题？ 打开两个编译器同时执行这段代码可以吗？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jie-da-3&quot;&gt;解答：&lt;&#x2F;h4&gt;
&lt;p&gt;打开两个编译器同时执行这段代码并不能模拟多线程环境，因为每个编译器运行的是独立的进程，它们的内存空间是隔离的，不会共享全局变量 &lt;code&gt;list&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;要模拟多线程环境，你需要在同一个进程内创建多个线程，并让这些线程同时操作共享的全局变量 &lt;code&gt;list&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;竞争问题在于它们的结果由 CPU 执行时间以及其内存操作的先后决定的&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;使用c语言模拟多线程编程导致的资源竞争：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;

&amp;#x2F;&amp;#x2F; 链表结构体
struct list {
    int data;
    struct list* next;
};

struct list* list = NULL;
&amp;#x2F;&amp;#x2F;CRITICAL_SECTION lock;  &amp;#x2F;&amp;#x2F; 互斥锁

void insert(int data) {
    struct list* l = malloc(sizeof * l);
    if (l == NULL) {
        fprintf(stderr, &amp;quot;Memory allocation failed\n&amp;quot;);
        exit(EXIT_FAILURE);
    }
    l-&amp;gt;data = data;

    &amp;#x2F;&amp;#x2F; 线程安全的修改
    &amp;#x2F;&amp;#x2F;EnterCriticalSection(&amp;amp;lock);
    l-&amp;gt;next = list;
    list = l;
    &amp;#x2F;&amp;#x2F;LeaveCriticalSection(&amp;amp;lock);
}

void print_list() {
    struct list* current = list;
    while (current != NULL) {
        printf(&amp;quot;%d -&amp;gt; &amp;quot;, current-&amp;gt;data);
        current = current-&amp;gt;next;
    }
    printf(&amp;quot;NULL\n&amp;quot;);
}

DWORD WINAPI thread_func(LPVOID arg) {
    for (int i = 0; i &amp;lt; 10; i++) {
        insert(i);
    }
    return 0;
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    insert(40);
   &amp;#x2F;&amp;#x2F; InitializeCriticalSection(&amp;amp;lock);  &amp;#x2F;&amp;#x2F; 初始化互斥锁

    HANDLE thread1, thread2;

    &amp;#x2F;&amp;#x2F; 创建两个线程
    thread1 = CreateThread(NULL, 0, thread_func, NULL, 0, NULL);
    thread2 = CreateThread(NULL, 0, thread_func, NULL, 0, NULL);

    &amp;#x2F;&amp;#x2F; 等待线程结束
   &amp;#x2F;&amp;#x2F; WaitForSingleObject(thread1, INFINITE);
    &amp;#x2F;&amp;#x2F;WaitForSingleObject(thread2, INFINITE);

    print_list();

    &amp;#x2F;&amp;#x2F;DeleteCriticalSection(&amp;amp;lock);  &amp;#x2F;&amp;#x2F; 释放互斥锁
    return 0;
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;jin-cheng-he-xian-cheng-de-guan-xi&quot;&gt;&lt;strong&gt;进程和线程的关系&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;&#x2F;strong&gt;：进程是操作系统分配资源的基本单位。每个进程都有独立的内存空间、文件描述符、环境变量等资源。进程之间是相互隔离的，一个进程崩溃通常不会影响其他进程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;&#x2F;strong&gt;：线程是进程内的执行单元，是&lt;em&gt;操作系统调度的基本单位&lt;&#x2F;em&gt;。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源（如堆、全局变量、文件描述符等），但每个线程有自己的栈和寄存器状态。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-2-2&quot;&gt;问题2：&lt;&#x2F;h4&gt;
&lt;p&gt;一个进程会没有线程吗？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-2-1&quot;&gt;回答2：&lt;&#x2F;h4&gt;
&lt;p&gt;一个进程至少有一个线程，称为主线程（main thread）。当你运行一个普通的 C 程序时，&lt;code&gt;main&lt;&#x2F;code&gt; 函数就是在主线程中执行的。这种进程是单线程的。&lt;&#x2F;p&gt;
&lt;p&gt;通过调用线程库（如 &lt;code&gt;pthread&lt;&#x2F;code&gt;），可以在一个进程中创建多个线程，这些线程并发执行。&lt;&#x2F;p&gt;
&lt;p&gt;没有线程的进程是不存在的。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void
acquire(struct spinlock *lk)
{
    for(;;) {
        if(!lk-&amp;gt;locked) {
            lk-&amp;gt;locked = 1;
            break;
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码在现代处理器上并不能保证互斥   代码会导致 两个不同的 CPU 持有锁，违反了互斥&lt;&#x2F;p&gt;
&lt;p&gt;若要保证代码的正确，就必须让操作是&lt;em&gt;原子操作&lt;&#x2F;em&gt;的 意味着在执行过程中不会被其他线程或 CPU 核心打断。&lt;&#x2F;p&gt;
&lt;p&gt;特殊指令 &lt;code&gt;xchg&lt;&#x2F;code&gt;   &lt;code&gt;xchg(&amp;amp;lk-&amp;gt;locked, 1);&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;交换了内存中的一个字和一个寄存器的值&lt;&#x2F;p&gt;
&lt;p&gt;交换了什么？&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存中的值&lt;&#x2F;strong&gt;：&lt;code&gt;lk-&amp;gt;locked&lt;&#x2F;code&gt; 的当前值（可能是 &lt;code&gt;0&lt;&#x2F;code&gt; 或 &lt;code&gt;1&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寄存器中的值&lt;&#x2F;strong&gt;：&lt;code&gt;1&lt;&#x2F;code&gt;（表示尝试获取锁）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-3-1&quot;&gt;问题3：&lt;&#x2F;h4&gt;
&lt;p&gt;如果两个线程同时运行到xarg这个语句不也还是会造成冲突吗&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-3-1&quot;&gt;回答3：&lt;&#x2F;h4&gt;
&lt;p&gt;关键在于 &lt;strong&gt;&lt;code&gt;xchg&lt;&#x2F;code&gt; 指令的原子性&lt;&#x2F;strong&gt;。即使两个线程同时运行到 &lt;code&gt;xchg&lt;&#x2F;code&gt; 语句，也不会造成冲突，因为 &lt;code&gt;xchg&lt;&#x2F;code&gt; 是硬件级别的原子操作。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 会确保 &lt;code&gt;xchg&lt;&#x2F;code&gt; 指令的执行是原子的。即使多个线程同时执行 &lt;code&gt;xchg&lt;&#x2F;code&gt;，硬件也会通过锁总线（bus locking）或缓存一致性协议（cache coherence）来保证只有一个线程能够成功执行 &lt;code&gt;xchg&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;syscall-c&quot;&gt;syscall.c&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p-&amp;gt;trapframe-&amp;gt;a7;
  if(num &amp;gt; 0 &amp;amp;&amp;amp; num &amp;lt; NELEM(syscalls) &amp;amp;&amp;amp; syscalls[num]) {
    &amp;#x2F;&amp;#x2F; Use num to lookup the system call function for num, call it,
    &amp;#x2F;&amp;#x2F; and store its return value in p-&amp;gt;trapframe-&amp;gt;a0
    p-&amp;gt;trapframe-&amp;gt;a0 = syscalls[num]();
  } else {
    printf(&amp;quot;%d %s: unknown sys call %d\n&amp;quot;,
            p-&amp;gt;pid, p-&amp;gt;name, num);
    p-&amp;gt;trapframe-&amp;gt;a0 = -1;
  }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;解读&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;myproc()&lt;&#x2F;code&gt; 是 xv6 中的一个函数，用于获取当前正在运行的进程的 &lt;code&gt;proc&lt;&#x2F;code&gt; 结构体指针。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;系统调用号是通过寄存器 &lt;code&gt;a7&lt;&#x2F;code&gt; 传递的。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;寄存器 RS触发器&lt;&#x2F;em&gt; ：&lt;&#x2F;p&gt;
&lt;p&gt;是cpu用来&lt;em&gt;暂存指令，数据，地址的电脑存储器&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;f9fa6347-2430-4f65-878a-9dbbe4227cec&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;作用：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从用户进程的陷阱帧中获取系统调用号。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;根据系统调用号找到对应的内核函数并执行。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;将系统调用的结果返回给用户进程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果系统调用号无效，则返回错误信息。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;***DMA *&lt;em&gt;插入知识&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yu-jian-cuo-wu&quot;&gt;遇见错误：&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;kernel&amp;#x2F;syscall.c:129:15: error: ‘sys_close’ undeclared here (not in a function); did you mean ‘sys_closei’?
  129 | [SYS_close]   sys_close,
      |               ^~~~~~~~~
      |               sys_closei
make: *** [&amp;lt;builtin&amp;gt;: kernel&amp;#x2F;syscall.o] Error 1

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;手贱 修改了 extern uint64 sys_close(void); 为 extern uint64 sys_closei(void);&lt;&#x2F;p&gt;
&lt;p&gt;系统调用表&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;static uint64 (*syscalls[])(void) = {

[SYS_fork]    sys_fork,

[SYS_exit]    sys_exit,

[SYS_wait]    sys_wait,

[SYS_pipe]    sys_pipe,

[SYS_read]    sys_read,

[SYS_kill]    sys_kill,

[SYS_exec]    sys_exec,

[SYS_fstat]   sys_fstat,

[SYS_chdir]   sys_chdir,

[SYS_dup]     sys_dup,

[SYS_getpid]  sys_getpid,

[SYS_sbrk]    sys_sbrk,

[SYS_sleep]   sys_sleep,

[SYS_uptime]  sys_uptime,

[SYS_open]    sys_open,

[SYS_write]   sys_write,

[SYS_mknod]   sys_mknod,

[SYS_unlink]  sys_unlink,

[SYS_link]    sys_link,

[SYS_mkdir]   sys_mkdir,

[SYS_close]   sys_close,

};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;wen-ti-4&quot;&gt;问题：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么在 char* syscall_name[]数组中如果顺序错误，会导致 在调用&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;trace 32 grep hello README&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;产生的命令也会不一样（4: syscall read -&amp;gt; 1023） （3: syscall pipe -&amp;gt; 1023）&lt;&#x2F;p&gt;
&lt;p&gt;关键：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;syscall.c&lt;&#x2F;code&gt;  &lt;code&gt;proc.c&lt;&#x2F;code&gt; &lt;code&gt;sysproc.c&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;在做实验的时候 因为镜像不是教程使用的镜像 所以导致很多环境缺失，我现在必须切换另一个仓库&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;for branch in $(git branch -r | grep -v HEAD); do
    git branch --track ${branch#origin&amp;#x2F;} $branch
done
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;拉取另一个仓库的所有分支&lt;&#x2F;p&gt;
&lt;p&gt;终于配好了环境！！！&lt;&#x2F;p&gt;
&lt;p&gt;先接着做，回头再补上之前的代码&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sys-sysinfo-c&quot;&gt;sys_sysinfo.c&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;  

uint64 acquire_freemem(){

  struct run *r;

  uint64 cnt = 0;

  

  acquire(&amp;amp;kmem.lock);

  r = kmem.freelist;

  while(r) {

    r = r-&amp;gt;next;

    cnt++;

  }

  if(r)

    kmem.freelist = r-&amp;gt;next;

  release(&amp;amp;kmem.lock);

  

  return cnt * PGSIZE;

}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt; if (argaddr(0,&amp;amp;addr)&amp;lt;0) {

    return -1

  }

  if (copyout(p-&amp;gt;pagetable,addr,(char*)&amp;amp;info,sizeof(info))&amp;lt;0)

    return -1;

}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从系统调用的参数中获取用户空间的地址。&lt;&#x2F;p&gt;
&lt;p&gt;将内核中的 &lt;code&gt;info&lt;&#x2F;code&gt; 结构体数据复制到用户空间的地址 &lt;code&gt;addr&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p-&amp;gt;pagetable&lt;&#x2F;code&gt;：当前进程的页表，用于将内核虚拟地址映射到用户虚拟地址。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;(char *)&amp;amp;info&lt;&#x2F;code&gt;：内核中 &lt;code&gt;info&lt;&#x2F;code&gt; 结构体的起始地址，强制转换为 &lt;code&gt;char *&lt;&#x2F;code&gt; 以便逐字节复制&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-4-1&quot;&gt;问题4：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么会考虑使用链表来管理空闲内存&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-4&quot;&gt;回答4：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;动态内存管理的需求&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;链表在分配和释放操作上的时间复杂度为 O(1），非常高效。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;高效的内存分配和释放&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;：每个空闲页只需要一个指针&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;适应碎片化内存&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;：轻松管理不连续的空闲页&lt;&#x2F;p&gt;
&lt;h4 id=&quot;kalloc-c-de-he-xin-gong-neng&quot;&gt;&lt;code&gt;kalloc.c&lt;&#x2F;code&gt; 的核心功能&lt;&#x2F;h4&gt;
&lt;p&gt;使用一个链表来管理空闲的物理内存页。每个空闲页的开头存储一个指向下一个空闲页的指针。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;一个页表在物理内存中像一棵两层的树。树的根是一个 4096 字节的_页目录_，其中包含了 1024 个类似 PTE 的条目，每个条目是指向一个_页表页_的引用&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pte-ye-ye-biao&quot;&gt;&lt;strong&gt;PTE &amp;amp; 页 &amp;amp; 页表&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;PTE 结构通常包含以下关键字段：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理页帧号（PFN，Page Frame Number）&lt;&#x2F;strong&gt;：映射的物理页地址。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存在位（Present Bit）&lt;&#x2F;strong&gt;：指示该页是否在内存中（1 代表在内存，0 代表不在，需要从磁盘调入）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读&#x2F;写权限（R&#x2F;W Bit）&lt;&#x2F;strong&gt;：控制该页是否可写（1 可写，0 只读）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户&#x2F;内核权限（U&#x2F;S Bit）&lt;&#x2F;strong&gt;：决定该页是用户态（1）还是内核态（0）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问位（Accessed Bit）&lt;&#x2F;strong&gt;：指示该页最近是否被访问过（用于页面置换策略）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;脏位（Dirty Bit）&lt;&#x2F;strong&gt;：如果该页被修改过，操作系统可能需要回写到磁盘。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;每个字节的物理内存都有一个地址     &lt;em&gt;虚拟地址则是程序所使用的&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;每个进程都有自己的页表 xv6 会在&lt;strong&gt;进程切换时通知分页硬件切换页表&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;分页机制&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;采用 &lt;strong&gt;两级页表&lt;&#x2F;strong&gt; 结构，即 &lt;strong&gt;页表目录（Page Directory）+ 页表（Page Table）&lt;&#x2F;strong&gt;，用于管理 &lt;strong&gt;虚拟地址到物理地址的映射&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页表目录是一个“目录”，指向多个页表。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页表是具体的“映射表”，存储 PTE（页表项），负责映射虚拟地址到物理地址。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PTE 是最终的映射单元，包含物理地址和权限控制信息。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-5&quot;&gt;问题5：&lt;&#x2F;h4&gt;
&lt;p&gt;每个进程有独立的页表是什么意思？ 如果有两个进程 并且两个进程的页表分别都映射到了相同的物理地址怎么办？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-5&quot;&gt;回答5：&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&amp;#x2F;&amp;#x2F; 进程A的页表（部分）
虚拟页0x1000 → 物理页帧0x2000 (存变量X)
虚拟页0x2000 → 物理页帧0x3000 (存代码段)

&amp;#x2F;&amp;#x2F; 进程B的页表（部分） 
虚拟页0x1000 → 物理页帧0x4000 (存变量Y) 
虚拟页0x2000 → 物理页帧0x3000 (共享库代码)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虽然两个进程都有虚拟地址 &lt;code&gt;0x1000&lt;&#x2F;code&gt;，但实际指向不同物理内存&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;两者都访问 &lt;code&gt;0x2000&lt;&#x2F;code&gt; 时，却指向同一物理页帧（共享库）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;共享代码库（故意共享）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;&#x2F;strong&gt;：多个PTE指向同一物理页，节省内存&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键&lt;&#x2F;strong&gt;：页表项标记为&lt;strong&gt;只读&lt;&#x2F;strong&gt;，防止互相干扰&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;解析：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;e6c58e1d-b24b-4713-8019-50ec8a481734&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1. 层级包含关系图示&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;复制&lt;&#x2F;p&gt;
&lt;p&gt;页表 (Page Table)
│
├── 页表项 (PTE 1) → 映射到物理页帧 X
├── 页表项 (PTE 2) → 映射到物理页帧 Y
├── ...
└── 页表项 (PTE N) → 标记为无效（缺页）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个PTE对应一个虚拟页&lt;&#x2F;strong&gt;，记录该页的物理位置和属性。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-6&quot;&gt;问题6：&lt;&#x2F;h4&gt;
&lt;p&gt;教授提出问题：为什么ppn存在于page directory中？目的是什么&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-6&quot;&gt;回答6：&lt;&#x2F;h4&gt;
&lt;h3 id=&quot;ye-mu-lu-de-ben-zhi-yu-zuo-yong&quot;&gt; &lt;strong&gt;页目录的本质与作用&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;页目录是多级页表的第一级（如x86的PML4或ARM的L1页表），其核心功能是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定位下级页表&lt;&#x2F;strong&gt;：存储下一级页表（Page Table）的&lt;strong&gt;物理页帧号（PPN）&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制访问权限&lt;&#x2F;strong&gt;：通过标志位管理整个下级页表的全局权限（如是否可写、用户态可否访问）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;（1）多级页表的物理地址连续性要求&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键约束&lt;&#x2F;strong&gt;：CPU的MMU硬件在查表时，必须直接访问&lt;strong&gt;物理内存&lt;&#x2F;strong&gt;（因为此时尚未完成虚拟→物理地址转换）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;&#x2F;strong&gt;：页目录项中存储下级页表的&lt;strong&gt;物理页帧号（PPN）&lt;&#x2F;strong&gt;，使MMU能直接定位下级页表的物理位置。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;satpzuo-yong&quot;&gt;satp作用：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;satp&lt;&#x2F;code&gt;（Supervisor Address Translation and Protection，监管者地址转换和保护）是 RISC-V 架构中控制 &lt;strong&gt;虚拟内存系统&lt;&#x2F;strong&gt; 的核心寄存器，主要功能包括：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启用&#x2F;禁用分页机制&lt;&#x2F;strong&gt;：决定是否开启虚拟地址到物理地址的转换。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置页表基地址&lt;&#x2F;strong&gt;：告诉 CPU 当前进程的页表在物理内存中的起始位置。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择地址转换模式&lt;&#x2F;strong&gt;：例如 Sv32（32位）、Sv39（39位虚拟地址）等。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;若 &lt;code&gt;satp.PPN = 0x1000&lt;&#x2F;code&gt;，表示顶级页表（L2）位于物理地址 &lt;code&gt;0x1000&lt;&#x2F;code&gt; 处。&lt;&#x2F;p&gt;
&lt;p&gt;CPU 根据 &lt;code&gt;satp&lt;&#x2F;code&gt; 寄存器找到顶级页表（L2）的物理地址。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;satp&lt;&#x2F;code&gt; 是页表系统的“大脑”&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;告诉 CPU 页表在哪里（&lt;code&gt;PPN&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;控制是否开启分页（&lt;code&gt;MODE&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;协助隔离进程（&lt;code&gt;ASID&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-7&quot;&gt;问题7：&lt;&#x2F;h4&gt;
&lt;p&gt;为什么要设置多级页表，如果这样做好的话，那么更多级别的不是越来越好吗？如果不好为什么要设计多级&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-7&quot;&gt;回答7：&lt;&#x2F;h4&gt;
&lt;p&gt;多级页表的设计是为了 &lt;strong&gt;节省内存&lt;&#x2F;strong&gt;，并 &lt;strong&gt;提高地址翻译的效率&lt;&#x2F;strong&gt;。但页表层级 &lt;strong&gt;不是越多越好&lt;&#x2F;strong&gt;，因为层级过多会 &lt;strong&gt;增加访问开销&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;1. 为什么要使用多级页表？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果使用 &lt;strong&gt;单级页表&lt;&#x2F;strong&gt;，每个进程需要维护完整的页表，会导致 &lt;strong&gt;巨大的内存占用&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;单级页表的问题&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;假设：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;虚拟地址&lt;&#x2F;strong&gt; 是 64-bit（常见架构）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页大小&lt;&#x2F;strong&gt; 是 &lt;code&gt;4KB&lt;&#x2F;code&gt;（即 &lt;code&gt;2^12&lt;&#x2F;code&gt; = &lt;code&gt;4096&lt;&#x2F;code&gt; 字节）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;每个页表项（PTE）&lt;&#x2F;strong&gt; 占 &lt;code&gt;8B&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;计算单级页表大小：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要管理 &lt;code&gt;2^64 &#x2F; 2^12 = 2^52&lt;&#x2F;code&gt; 个页&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;每个 PTE &lt;code&gt;8B&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单级页表大小&lt;&#x2F;strong&gt; = &lt;code&gt;2^52 × 8B = 36PB&lt;&#x2F;code&gt;（&lt;strong&gt;无法接受！&lt;&#x2F;strong&gt;）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;如果使用多级页表，只分配“必要的页表”，而不是整个大表，从而减少内存开销！&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;2. 为什么不是越多级越好？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;多级页表减少内存占用，但增加了访问开销！&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-zhi-fan-yi-de-cheng-ben&quot;&gt;&lt;strong&gt;地址翻译的成本&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;假设使用 &lt;strong&gt;3 级页表（Sv39）&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[ L2 (9-bit) ] [ L1 (9-bit) ] [ PTE (9-bit) ] [ Offset (12-bit) ]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;访问过程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问 &lt;code&gt;L2 页表&lt;&#x2F;code&gt;（取出 &lt;code&gt;L1 页表&lt;&#x2F;code&gt; 的 PPN）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;访问 &lt;code&gt;L1 页表&lt;&#x2F;code&gt;（取出 &lt;code&gt;物理页&lt;&#x2F;code&gt; 的 PPN）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;访问 &lt;code&gt;物理页&lt;&#x2F;code&gt; 计算最终物理地址&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总共 3 次内存访问&lt;&#x2F;strong&gt; 才能完成一次翻译！&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;如果使用 5 级页表，会有更多次内存访问，导致性能下降！&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-xian-you-jia-gou-shi-ru-he-xuan-ze-ji-shu-de&quot;&gt;&lt;strong&gt;3. 现有架构是如何选择级数的？&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sv32（2 级页表）&lt;&#x2F;strong&gt; → 适用于 &lt;strong&gt;32-bit 系统&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sv39（3 级页表）&lt;&#x2F;strong&gt; → 适用于 &lt;strong&gt;大多数 64-bit 服务器&#x2F;PC&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sv48（4 级页表）&lt;&#x2F;strong&gt; → 适用于 &lt;strong&gt;超大内存服务器&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sv57（5 级页表）&lt;&#x2F;strong&gt; → 适用于 &lt;strong&gt;未来超大内存&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-guan-jian-zong-jie&quot;&gt;&lt;strong&gt;4. 关键总结&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;✅ &lt;strong&gt;多级页表减少内存占用&lt;&#x2F;strong&gt;，因为它 &lt;strong&gt;按需分配页表&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
❌ &lt;strong&gt;页表级别过多会降低访问速度&lt;&#x2F;strong&gt;，因为每次地址转换都要查多个级别&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;最优解&lt;&#x2F;strong&gt; 取决于 &lt;strong&gt;物理内存大小&lt;&#x2F;strong&gt; 和 &lt;strong&gt;性能需求&lt;&#x2F;strong&gt;，不是越多级越好！&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-8&quot;&gt;问题8：&lt;&#x2F;h4&gt;
&lt;p&gt;所以每一个进程都会有一个虚拟地址是吗？ 这样做的目的是什么呢？为了隔离应用程序吗？所以如果要通过寻找虚拟地址的物理地址，经过多次的内存读写是不是也是很大的问题？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-8&quot;&gt;回答8：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;连续虚拟空间&lt;&#x2F;strong&gt;：程序无需关心物理内存碎片。例如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;进程的堆、栈、代码段在虚拟地址中是连续的，但物理内存可能分散。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;每次访问虚拟地址需查页表（多级页表可能需4-5次内存访问）：&lt;&#x2F;p&gt;
&lt;p&gt;解决：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TLB（Translation Lookaside Buffer）&lt;&#x2F;strong&gt;：CPU缓存近期使用的 &lt;code&gt;虚拟页→物理页&lt;&#x2F;code&gt; 映射。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命中时：1个周期完成转换。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;未命中时：触发“页表遍历”（由MMU硬件加速）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TLB效果&lt;&#x2F;strong&gt;：典型程序的TLB命中率 &amp;gt;99%，几乎无额外开销。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;我的错误想法，把cpu等同于处理器了！&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;cpu并不等同于处理器&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;&#x2F;strong&gt; = 大脑（负责思考）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理器芯片&lt;&#x2F;strong&gt; = 整个头（大脑+眼睛+耳朵+嘴巴）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h4 id=&quot;wen-ti-9&quot;&gt;问题9：&lt;&#x2F;h4&gt;
&lt;p&gt;那mmu是什么？ 和cpu的关系是什么&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-9&quot;&gt;回答9：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;MMU（Memory Management Unit，内存管理单元）是CPU的“地址翻译官”&lt;&#x2F;strong&gt;，负责把程序用的虚拟地址（如&lt;code&gt;0x8048000&lt;&#x2F;code&gt;）转换成物理内存的真实地址（如&lt;code&gt;0x12340000&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;现代CPU&lt;&#x2F;strong&gt;：MMU直接集成在CPU内部（如Intel的MMU叫“&lt;strong&gt;Memory Management Unit&lt;&#x2F;strong&gt;”，ARM的叫“&lt;strong&gt;MMU&lt;&#x2F;strong&gt;”或“&lt;strong&gt;SMMU&lt;&#x2F;strong&gt;”）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-10&quot;&gt;问题10：&lt;&#x2F;h4&gt;
&lt;p&gt;cache和TLB之间的区别是什么？都是缓存 当计算机处理数据的时候什么时候用到TLB什么时候用到cache&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-10&quot;&gt;回答10：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;Cache 和 TLB 的区别及使用场景&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;一句话总结&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cache（缓存）&lt;&#x2F;strong&gt;：存储 &lt;strong&gt;数据&lt;&#x2F;strong&gt; 和 &lt;strong&gt;指令&lt;&#x2F;strong&gt;，加速CPU访问内存。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TLB（快表）&lt;&#x2F;strong&gt;：存储 &lt;strong&gt;虚拟地址→物理地址的映射关系&lt;&#x2F;strong&gt;，加速MMU查页表。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-11&quot;&gt;问题11：&lt;&#x2F;h4&gt;
&lt;p&gt;page table是谁可以拥有的？ 一个进程吗 也就是一个应用程序吗？ 或者说一个应用程序分为内核态和用户态 这个表是谁在持有谁在控制呢&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-11&quot;&gt;回答11：&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谁拥有页表？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;每个用户进程&lt;&#x2F;strong&gt; 有独立的页表（用户空间部分）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内核&lt;&#x2F;strong&gt; 有全局共享的页表（内核空间部分）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谁控制页表？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内核&lt;&#x2F;strong&gt; 全权管理页表的创建、修改和销毁。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU的MMU&lt;&#x2F;strong&gt; 负责运行时地址转换。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;wen-ti-12&quot;&gt;问题12：&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;为什么分页机制能让虚拟内存远大于物理内存？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da-12&quot;&gt;回答12：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存 ≠ 物理内存&lt;&#x2F;strong&gt;，程序看到的是虚拟地址，由操作系统和硬件（MMU）动态映射到物理内存或磁盘。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;按需加载（Demand Paging）&lt;&#x2F;strong&gt;：程序运行时，只有当前需要的部分数据会加载到物理内存，其余部分暂存磁盘。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分页与交换&lt;&#x2F;strong&gt;：当物理内存不足时，操作系统将不活跃的内存页（Page）换出（Swap Out）到磁盘，腾出空间给新数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;wo-de-xiang-fa-1&quot;&gt;我的想法&lt;&#x2F;h4&gt;
&lt;p&gt;以xv6操作系统举例 分页机制就是分成了三个L2 L1 L0 然后分别对应了三个高级 中级 低级表，为什么只是用一个单表不行呢？ 如果只是用一个单表，并且设置为按需加载不是可以达到一样的效果吗？ 我的理解哪里出现了差错？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hui-da&quot;&gt;回答：&lt;&#x2F;h4&gt;
&lt;p&gt;主要错误：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;可能错误地认为单级页表可以按需加载页表项，但实际上单级页表的结构导致必须预先分配所有条目，而多级页表通过层次结构允许动态分配。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;单页表&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存占用爆炸&lt;&#x2F;strong&gt;：&lt;br &#x2F;&gt;
若虚拟地址空间为 239239（如RISC-V Sv39标准），页大小为4KB（212212），则单级页表需要 239&#x2F;212=227239&#x2F;212=227 个页表项（PTE）。&lt;br &#x2F;&gt;
每个PTE占8字节（RISC-V标准），总内存占用为 227×8B=1GB227×8B=1GB。&lt;br &#x2F;&gt;
这意味着&lt;strong&gt;每个进程的页表自身就需要占用1GB物理内存&lt;&#x2F;strong&gt;，显然不可行。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;按需加载的局限性&lt;&#x2F;strong&gt;：&lt;br &#x2F;&gt;
单级页表的所有PTE必须预先分配（即使虚拟地址未使用），否则无法通过单级结构定位到缺失的PTE。&lt;br &#x2F;&gt;
&lt;strong&gt;按需加载只能管理页面（Page），无法管理页表本身&lt;&#x2F;strong&gt;。若页表条目未预先分配，硬件在地址转换时无法找到下一级PTE，导致无法触发缺页异常。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单级页表&lt;&#x2F;strong&gt;：固定占用4MB（无论实际用了多少内存）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二级页表&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页目录&lt;&#x2F;strong&gt;：始终占用1个页（4KB，含1024个条目）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页表&lt;&#x2F;strong&gt;：只需为已使用的虚拟页分配二级页表。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若3个物理页分散在3个不同的二级页表中，最多需要3个二级页表（每个4KB），总占用 4KB+3×4KB=16KB4KB+3×4KB=16KB。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;若3个物理页集中在1个二级页表内，则仅需 4KB+4KB=8KB4KB+4KB=8KB。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;page-fault&quot;&gt;page fault&lt;&#x2F;h4&gt;
&lt;p&gt;当程序首次访问某个虚拟地址时：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件查页目录，发现对应的二级页表“不存在”（标记为无效）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;触发 &lt;strong&gt;缺页异常&lt;&#x2F;strong&gt;，操作系统动态分配一个二级页表，并将其地址填入页目录。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;继续执行地址转换。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;多级页表通过层级查询&lt;&#x2F;strong&gt;，允许中间层PTE标记为“无效”，从而跳过下级页表的分配。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多级页表&lt;&#x2F;strong&gt;：像图书馆的层级目录：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先按大类（页目录）查找 → 再按小类（页表）查找 → 最后找到具体的书（物理页）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果某大类无人借阅（未使用的地址空间），整个小类目录无需打印。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;关键代码：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;2fe3d767-68c6-4c98-ab8a-440f8defc461&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如何计算&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;dcbd1dde-7309-49b4-a3ea-41431177ee2d&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;di-san-zhang-zhong-duan-he-qu-dong-cheng-xu&quot;&gt;第三章：终端和驱动程序&lt;&#x2F;h2&gt;
&lt;p&gt;运行进程时，cpu 一直处于一个大循环中 取指，更新 PC，执行，取指……&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yong-hu-cheng-xu-de-fei-fa-cao-zuo&quot;&gt;用户程序的非法操作&lt;&#x2F;h4&gt;
&lt;p&gt;（例如引用一个找不到页表项的虚拟地址）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;三大挑战&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;内核必须使处理器能够从用户态转换到内核态（并且再转换回用户态）&lt;&#x2F;li&gt;
&lt;li&gt;内核和设备必须协调好他们并行的活动&lt;&#x2F;li&gt;
&lt;li&gt;内核必须知道硬件接口的细节&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;xi-tong-diao-yong-yi-chang-he-zhong-duan&quot;&gt;系统调用，异常和中断&lt;&#x2F;h4&gt;
&lt;p&gt;当硬盘读完一个数据块时，它会产生一个中断来提醒操作系统这个块已经准备好被获取了 &lt;em&gt;所有的中断都由内核管理，而不是进程&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;强迫进程服从处理器的调度&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;！系统必须保存寄存器以备将来的状态恢复&lt;br &#x2F;&gt;
！系统必须保持用户进程和系统进程的隔离&lt;&#x2F;p&gt;
&lt;p&gt;处理器需要在用户模式和内核模式之间切换&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;操作系统必须知道硬件是如何处理系统调用、异常和中断的&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一定要记住&lt;em&gt;陷入是由在 cpu 上运行的当前进程导致的&lt;&#x2F;em&gt;，而&lt;em&gt;中断&lt;&#x2F;em&gt;是由&lt;em&gt;设备&lt;&#x2F;em&gt;导致的，可能与当前进程毫无关系&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;陷入（Trap）场景：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当Word执行&lt;code&gt;printf()&lt;&#x2F;code&gt;系统调用请求打印服务时，会主动触发一个陷入（由CPU当前运行的Word进程导致）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这就像你主动打电话给打印机客服（主动触发系统调用）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;陷入与当前进程（Word）直接相关，是它的代码逻辑的一部分&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;中断（Interrupt）场景：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;当打印机完成打印后：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打印机的硬件控制器会发送一个中断信号给CPU&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;此时CPU可能正在运行任何进程（比如你在中断到来时正好切换到Excel做表格）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这个中断与Excel进程完全无关，是外部设备（打印机）触发的&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;就像打印机客服突然回拨电话，不管你现在正在做什么事情都要接听&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;x86de-bao-hu-ji-zhi&quot;&gt;x86的保护机制&lt;&#x2F;h4&gt;
&lt;p&gt;x86 有四个特权级，从 0（特权最高）编号到 3（特权最低）&lt;&#x2F;p&gt;
&lt;p&gt;在操作系统中 &lt;strong&gt;&lt;code&gt;int&lt;&#x2F;code&gt; 指令&lt;&#x2F;strong&gt;（如 &lt;code&gt;int 0x80&lt;&#x2F;code&gt; 或 &lt;code&gt;int 3&lt;&#x2F;code&gt;）和你平时编程中定义的 &lt;code&gt;int n&lt;&#x2F;code&gt;（整数变量）&lt;strong&gt;完全不同&lt;&#x2F;strong&gt;，它是 x86 架构下的一个&lt;strong&gt;机器指令&lt;&#x2F;strong&gt;，用于触发&lt;strong&gt;软中断&lt;&#x2F;strong&gt;（Software Interrupt），从而实现&lt;strong&gt;系统调用、调试断点、异常处理&lt;&#x2F;strong&gt;等关键功能。它的复杂性主要体现在以下几个方面：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;int n&lt;&#x2F;code&gt;（变量声明）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;例如 &lt;code&gt;int n = 10;&lt;&#x2F;code&gt;，这只是声明一个整数变量，属于高级语言（C&#x2F;C++）的语法，与 CPU 无关。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;int&lt;&#x2F;code&gt; 指令（x86 机器指令）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;例如 &lt;code&gt;int 0x80&lt;&#x2F;code&gt;，是 CPU 直接支持的指令，用于&lt;strong&gt;主动触发中断&lt;&#x2F;strong&gt;，让 CPU 从用户态切换到内核态，执行操作系统提供的服务（如读写文件、创建进程等）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;cha-ru-externyong-fa&quot;&gt;插入 extern用法&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1433204&#x2F;how-do-i-use-extern-to-share-variables-between-source-files&quot;&gt;来自Stackoverflow回答&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;仅当您正在构建的程序由多个链接在一起的源文件组成时，使用 &lt;code&gt;extern&lt;&#x2F;code&gt; 才有意义，其中定义的某些变量（例如，在源文件 &lt;code&gt;file1.c&lt;&#x2F;code&gt; 中定义的变量）需要在其他源文件（如 &lt;code&gt;file2.c&lt;&#x2F;code&gt;）中引用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zhong-duan-he-xian-jing&quot;&gt;中断和陷阱&lt;&#x2F;h2&gt;
&lt;p&gt;中断是打断 CPU 的“控制权”，不是打断程序逻辑本身。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-bi-zong-jie&quot;&gt;对比总结：&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;项目&lt;&#x2F;th&gt;&lt;th&gt;中断 Interrupt&lt;&#x2F;th&gt;&lt;th&gt;陷阱 Trap&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;来源&lt;&#x2F;td&gt;&lt;td&gt;外部设备&lt;&#x2F;td&gt;&lt;td&gt;当前程序&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;类型&lt;&#x2F;td&gt;&lt;td&gt;异步&lt;&#x2F;td&gt;&lt;td&gt;同步&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;用途&lt;&#x2F;td&gt;&lt;td&gt;响应外设事件&lt;&#x2F;td&gt;&lt;td&gt;系统调用、错误处理&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;控制权转移&lt;&#x2F;td&gt;&lt;td&gt;用户态 -&amp;gt; 内核态&lt;&#x2F;td&gt;&lt;td&gt;用户态 -&amp;gt; 内核态&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;pre&gt;&lt;code&gt;+-------------------+       +-------------------+       +-------------------+
|   用户程序执行      |       |   中断处理流程     |       |   操作系统内核     |
|                   |       |                   |       |                   |
| 执行int 0x80指令  | ----&amp;gt; | 1. 保存CPU上下文  | ----&amp;gt; | 查找系统调用表    |
| (系统调用)         |       | 2. 切换内核模式    |       | 执行对应服务例程  |
|                   |       | 3. 识别中断号      |       |                   |
| 发生除零错误       | ----&amp;gt; | 1. 保存CPU上下文  | ----&amp;gt; | 执行异常处理程序  |
| (异常)            |       | 2. 切换内核模式    |       | 可能终止进程      |
|                   |       | 3. 识别异常类型    |       |                   |
+-------------------+       +-------------------+       +-------------------+
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;中断可能打断一个正在持有锁的上下文，然后又尝试去拿这个锁，造成自己等自己释放锁 → 死锁。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-xuan-suo-spinlock-de-zuo-yong&quot;&gt;&lt;strong&gt;自旋锁（Spinlock）的作用&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;自旋锁是一种 &lt;strong&gt;低级的同步机制&lt;&#x2F;strong&gt;，用于在多核 CPU 或并发线程中保护共享资源（如全局变量、数据结构）。它的核心行为是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取锁（&lt;code&gt;acquire&lt;&#x2F;code&gt;）&lt;&#x2F;strong&gt;：如果锁已被其他 CPU&#x2F;线程占用，当前 CPU&#x2F;线程会 &lt;strong&gt;忙等待（自旋）&lt;&#x2F;strong&gt;，直到锁被释放。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;释放锁（&lt;code&gt;release&lt;&#x2F;code&gt;）&lt;&#x2F;strong&gt;：当前持有者解锁，允许其他竞争者获取。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;struct spinlock lock;
int shared_data = 0;

void thread_A() {
    acquire(&amp;amp;lock);      &amp;#x2F;&amp;#x2F; 获取锁
    shared_data += 1;    &amp;#x2F;&amp;#x2F; 安全修改共享数据
    release(&amp;amp;lock);      &amp;#x2F;&amp;#x2F; 释放锁
}

void thread_B() {
    acquire(&amp;amp;lock);      &amp;#x2F;&amp;#x2F; 如果锁被 thread_A 持有，则自旋等待
    shared_data -= 1;
    release(&amp;amp;lock);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;wei-shen-me-xu-yao-zhi-dao-dang-qian-chi-you-suo-de-cpu&quot;&gt;&lt;strong&gt;为什么需要知道“当前持有锁的 CPU”？&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;自旋锁的实现中，通常会记录 &lt;strong&gt;当前持有锁的 CPU 核心编号&lt;&#x2F;strong&gt;（通过 &lt;code&gt;cpuid()&lt;&#x2F;code&gt; 获取），目的是：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;死锁检测&lt;&#x2F;strong&gt;：防止同一 CPU 重复获取锁（导致永久等待）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调试信息&lt;&#x2F;strong&gt;：在发生死锁时，打印持有锁的 CPU 编号，帮助定位问题。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;zi-xuan-suo-de-you-que-dian&quot;&gt;&lt;strong&gt;自旋锁的优缺点&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;优点&lt;&#x2F;strong&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;strong&gt;缺点&lt;&#x2F;strong&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;无上下文切换，响应快&lt;&#x2F;td&gt;&lt;td&gt;忙等待浪费 CPU 周期&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;适合极短临界区（如修改一个变量）&lt;&#x2F;td&gt;&lt;td&gt;不适合长时间持有锁&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;实现简单&lt;&#x2F;td&gt;&lt;td&gt;可能引发活锁（高竞争场景）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;yuan-zi-cao-zuo&quot;&gt;原子操作&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;lab-page-table&quot;&gt;Lab Page table&lt;&#x2F;h2&gt;
&lt;h4 id=&quot;speed-up-system-calls&quot;&gt;Speed up system calls&lt;&#x2F;h4&gt;
&lt;p&gt;通过在用户空间和内核之间的&lt;em&gt;只读区域中共享数据来加速某些系统调用&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;技术实现关键点&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存映射&lt;&#x2F;strong&gt;：通过页表机制，将内核中的一块物理页面同时映射到内核和用户地址空间，并标记为用户只读（避免用户篡改）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步问题&lt;&#x2F;strong&gt;：由于数据是只读的，内核在更新数据时（如进程切换后更新PID），需保证用户态看到的是最新值（可通过原子写或页表权限动态调整实现）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;&#x2F;strong&gt;：必须确保用户程序不能修改共享数据（通过硬件页表权限保护）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;jigsaw-zong-mu-biao&quot;&gt;🧩 总目标&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;实现在用户态，不用执行系统调用，就能获取当前进程的 &lt;code&gt;pid&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;li-jie-kvmmap&quot;&gt;理解kvmmap&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void

kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)

{

  if(mappages(kpgtbl, va, sz, pa, perm) != 0)

    panic(&amp;quot;kvmmap&amp;quot;);

}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int

mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)

{

  uint64 a, last;

  pte_t *pte;

  

  if(size == 0)

    panic(&amp;quot;mappages: size&amp;quot;);

  a = PGROUNDDOWN(va);

  last = PGROUNDDOWN(va + size - 1);

  for(;;){

    if((pte = walk(pagetable, a, 1)) == 0)

      return -1;

    if(*pte &amp;amp; PTE_V)

      panic(&amp;quot;mappages: remap&amp;quot;);

    *pte = PA2PTE(pa) | perm | PTE_V;

    if(a == last)

      break;

    a += PGSIZE;

    pa += PGSIZE;

  }

  return 0;

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;2-risc-v-sv39-di-zhi-hua-fen&quot;&gt;&lt;strong&gt;2. RISC-V Sv39 地址划分&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;虚拟地址 &lt;code&gt;va&lt;&#x2F;code&gt; 被划分为 5 部分（从高到低）：&lt;&#x2F;p&gt;
&lt;p&gt;| 63..39 | 38..30 (L2) | 29..21 (L1) | 20..12 (L0) | 11..0 (offset) |&lt;&#x2F;p&gt;
&lt;p&gt;必须为0    二级页表索引   一级页表索引   零级页表索引     页内偏移&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每级页表索引占 9 位（&lt;code&gt;2^9=512&lt;&#x2F;code&gt; 个 PTE）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;页表项（PTE）存储下一级页表的 &lt;strong&gt;物理地址（PA）&lt;&#x2F;strong&gt; 或最终页的物理地址。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)
参数	含义
pagetable	根页表（即 satp 指向的页表）
va	虚拟地址
alloc	如果中间页表不存在，是否允许自动 kalloc
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RISC-V 使用三级页表：&lt;strong&gt;level 2 → level 1 → level 0&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;每级页表有 512 项，对应 VA 中的不同段（用 &lt;code&gt;PX(level, va)&lt;&#x2F;code&gt; 取出）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;PGROUNDDOWN(a) = a &amp;amp; ~(PGSIZE - 1)
PGSIZE - 1 就是 0xFFF（即 4095，低 12 位全是 1）

~(PGSIZE - 1) 就是 0xFFFFF000，高位全是 1，低 12 位全是 0

a &amp;amp; ~(PGSIZE - 1) 会把 a 的低 12 位清零


&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;ye-biao-xiang-pte-ru-he-cun-chu-wu-li-di-zhi&quot;&gt;页表项（PTE）如何存储物理地址&lt;&#x2F;h3&gt;
&lt;p&gt;一个 PTE 是一个 64 位的数。其结构如下：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;| 63        ...        10 | 9 ... 0 | |     PPN (物理页号)      | 标志位 |&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pte-dao-wu-li-di-zhi-de-guo-cheng-shi-zhe-yang-de&quot;&gt;PTE 到物理地址的过程是这样的&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;uint64 ppn = *pte &amp;gt;&amp;gt; 10;        &amp;#x2F;&amp;#x2F; 去掉低 10 位的标志
uint64 pa = ppn &amp;lt;&amp;lt; 12;          &amp;#x2F;&amp;#x2F; 得到物理页起始地址
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;页号 * 页大小&lt;&#x2F;p&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;p&gt;第一个页 页号为1 页大小固定为4K &lt;code&gt;0x1000 ~ 0x1FFF&lt;&#x2F;code&gt;（4096 字节大小）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;pa = ppn × 4096 = ppn × 2¹² = ppn &amp;lt;&amp;lt; 12&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;12288 = 0x3000 怎么快速计算出&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;4096 = 0x1000&lt;&#x2F;code&gt;（因为 &lt;code&gt;16^3 = 4096&lt;&#x2F;code&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分解 12288&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;12288 ÷ 4096 = 3&lt;&#x2F;code&gt; → 表示有 &lt;strong&gt;3 个 0x1000&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;因此：&lt;code&gt;3 × 0x1000 = 0x3000&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;下次遇到类似计算，直接问自己：&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
“这个数包含几个 4096？” → 答案就是 &lt;code&gt;0xN000&lt;&#x2F;code&gt; 中的 &lt;code&gt;N&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-jie-initcode-s&quot;&gt;理解 initcode.S&lt;&#x2F;h2&gt;
&lt;p&gt;目前还看不懂啊&lt;&#x2F;p&gt;
&lt;h3 id=&quot;czhong-zhi-zhen-yu-shu-zu-de-guan-xi&quot;&gt;c中指针与数组的关系&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;帮我理解一下 数组和指针的关系以及操作我对这里还是有点模糊就是 pte_t pte = pagetable[i]; typedef uint64 *pagetable_t; &amp;#x2F;&amp;#x2F; 512 PTEs
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;typedef uint64* pagetable_t;  &#x2F;&#x2F; 页表是 uint64 的指针，指向 512 个 PTE（页表项） &lt;&#x2F;code&gt;
&lt;code&gt;pagetable_t pagetable;  &#x2F;&#x2F; 等价于：uint64* pagetable; &lt;&#x2F;code&gt;
&lt;code&gt;pagetable[i] 等价于 *(pagetable + i)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pagetable&lt;&#x2F;code&gt; 是一个指针，指向第一个 PTE；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pagetable + i&lt;&#x2F;code&gt; 就是跳过 i 个 PTE 的位置；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;&#x2F;code&gt; 就是取出这个位置的值；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以 &lt;code&gt;pagetable[i]&lt;&#x2F;code&gt; 就是第 i 个页表项（类型是 uint64，也就是 pte_t）；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;内存布局图！  GDB&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Reddit提问</title>
          <pubDate>Wed, 28 May 2025 12:31:52 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-7/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-7/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-7/">&lt;pre&gt;&lt;code&gt;hello everyone! Recently, while learning the concurrency model of Go language, I have been very interested in its idea of &amp;quot;Do not communicate by sharing memory&amp;quot; (instant, share memory by communication).The channel mechanism of Go replaces explicit locks with data transfer between goroutines, making concurrent programming safer and simpler. This makes me think: can similar ideas be used in operating system design? For example, replacing traditional IPC mechanisms such as shared memory and semaphore with channels?I would like to discuss the following points with everyone:The inter process&amp;#x2F;thread communication (IPC) of the operating system currently relies on shared memory, message queues, pipelines, and so on. What are the advantages and challenges of using a mechanism similar to Go channel?Will performance become a bottleneck (such as system call overhead)?Realistic case:Have any existing operating systems or research projects attempted this design? (For example, microkernel, Unikernel, or certain academic systems?)? ）Do you think the abstraction of channels is feasible at the OS level?  
大家好！最近，我在学习 Go 语言的并发模型时，对它的 “Do not communicate by sharing memory” （instant， share memory by communication） 的思想非常感兴趣。Go 的通道机制用 goroutine 之间的数据传输取代了显式锁，使并发编程更安全、更简单。这让我思考：类似的思路可以用在作系统设计中吗？例如，用通道替换共享内存和信号量等传统 IPC 机制？我想和大家讨论以下几点：作系统的进程间 &amp;#x2F; 线程通信（IPC）目前依赖于共享内存、消息队列、管道等。使用类似于 Go 频道的机制有哪些优势和挑战？性能会不会成为瓶颈（如系统调用开销）？现实案例：是否有任何现有的作系统或研究项目尝试过这种设计？（例如，微内核、Unikernel 或某些学术系统？）您认为通道的抽象在 OS 级别是否可行？
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是我第一次重视reddit&lt;&#x2F;p&gt;
&lt;p&gt;这是我的第一次提问在社区中，非常的难忘！社区中的大家是那么的热情，即使你们从未见过面！英文部分是我的想法用ai转换之后得来的，我的英语并不是很好哈哈&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;1krtd88&#x2F;could_gos_share_memory_by_communicating&#x2F;&quot;&gt;很开心这么多人回复问题！&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;understanding-csp&quot;&gt;Understanding CSP&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;CSP（Communicating Sequential Processes）&lt;&#x2F;strong&gt; 是一种并发模型，全称是 &lt;strong&gt;通信顺序进程&lt;&#x2F;strong&gt;，由计算机科学家 &lt;strong&gt;Tony Hoare&lt;&#x2F;strong&gt; 在 1978 年提出。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSP 的核心思想是：进程之间不共享内存，而是通过通信（消息传递）来协作&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;papering&#x2F;p&#x2F;9479496.html&quot;&gt;CSP_blog&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func worker(ch chan int) {
    val := &amp;lt;-ch         &amp;#x2F;&amp;#x2F; 接收数据
    fmt.Println(val)
}

func main() {
    ch := make(chan int)
    go worker(ch)
    ch &amp;lt;- 42             &amp;#x2F;&amp;#x2F; 发送数据
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个例子就是标准的 CSP：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个顺序进程（&lt;code&gt;main&lt;&#x2F;code&gt; 和 &lt;code&gt;worker&lt;&#x2F;code&gt;）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通道 &lt;code&gt;ch&lt;&#x2F;code&gt; 是它们的通信桥梁&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;没有共享内存，只靠通道通信&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CSP&lt;&#x2F;strong&gt; 是一种并发编程理论，强调进程通过**事件（Event）**通信（而非共享内存）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程（Process）&lt;&#x2F;strong&gt;：代表一个独立的行为实体（如售货机或顾客），通过&lt;strong&gt;事件序列&lt;&#x2F;strong&gt;描述行为。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步（Synchronization）&lt;&#x2F;strong&gt;：多个进程在特定事件上必须“同步执行”（如顾客投币和售货机接收硬币是同一个 &lt;code&gt;coin&lt;&#x2F;code&gt; 事件）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;1-shou-huo-ji-jin-cheng&quot;&gt;&lt;strong&gt;1. 售货机进程&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;行为&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;1. 等待 `coin` 事件（投币）。
    
2. 执行 `choc` 事件（发放巧克力）。
    
3. 终止（`STOP`）。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;&#x2F;strong&gt;：售货机&lt;strong&gt;必须先收钱再给货&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;2-gu-ke-jin-cheng&quot;&gt;&lt;strong&gt;2. 顾客进程&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Person = (coin \rightarrow STOP) \square (card \rightarrow STOP)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行为&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;□&lt;&#x2F;code&gt; 表示&lt;strong&gt;外部选择&lt;&#x2F;strong&gt;（顾客可以选 &lt;code&gt;coin&lt;&#x2F;code&gt; 或 &lt;code&gt;card&lt;&#x2F;code&gt; 事件，但不会同时发生）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;选择后终止（&lt;code&gt;STOP&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;意义&lt;&#x2F;strong&gt;：顾客有&lt;strong&gt;两种支付方式&lt;&#x2F;strong&gt;（硬币或刷卡），但每次只能选一种。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;3-ru-guo-shou-huo-ji-zhi-tong-bu-coin&quot;&gt;&lt;strong&gt;3. 如果售货机只同步 &lt;code&gt;coin&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;VendingMachine ,|, [coin] ,|, Person&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;(coin \rightarrow choc \rightarrow STOP) \square (card \rightarrow STOP)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顾客选 &lt;code&gt;coin&lt;&#x2F;code&gt;：正常走售货机流程。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;顾客选 &lt;code&gt;card&lt;&#x2F;code&gt;：售货机不响应，顾客直接终止（&lt;code&gt;STOP&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;4-yin-cang-shi-jian&quot;&gt;&lt;strong&gt;4. 隐藏事件&lt;&#x2F;strong&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;&#x2F;strong&gt;：外部只能看到 &lt;code&gt;choc&lt;&#x2F;code&gt; 或直接终止，表现为&lt;strong&gt;非确定性选择&lt;&#x2F;strong&gt;（&lt;code&gt;⊓&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;p&gt;(choc \rightarrow STOP) \sqcap STOP&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可能发放巧克力后停止，也可能直接停止（因为看不到顾客的支付选择）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;同步约束：售货机和顾客必须就支付方式达成一致（如只支持现金时，刷卡会失败）。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;非确定性：隐藏内部事件后，系统行为对外部观察者变得不可预测（如同实际场景中，路人看不到顾客是否投币，只能看到巧克力是否出来）。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;CSP 的 &lt;code&gt;coin → choc → STOP&lt;&#x2F;code&gt; 类似 Go 中通过 channel 同步的两个 goroutine：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步失败&lt;&#x2F;strong&gt;：如果 &lt;code&gt;vendingMachine&lt;&#x2F;code&gt; 只监听 &lt;code&gt;coin&lt;&#x2F;code&gt;，&lt;code&gt;card&lt;&#x2F;code&gt; 会阻塞。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;cao-zuo-xi-tong-wei-shen-me-mei-yong-csp&quot;&gt;操作系统为什么没用 CSP：&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;性能优先：共享内存更快&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;操作系统关注 &lt;strong&gt;高性能调度与资源访问&lt;&#x2F;strong&gt;，**共享内存 + 同步机制（如锁、信号量）**可以做到：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最低延迟（不需要拷贝）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;高吞吐（直接访问同一块内存）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;➡ 相比之下，&lt;strong&gt;CSP 的通信（尤其跨进程）要复制数据、上下文切换，代价更大&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;OS 中的“进程”不是 CSP 的“轻量进程”&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;CSP 模型适合的是 &lt;strong&gt;轻量并发实体（如 goroutine）&lt;&#x2F;strong&gt;，操作系统的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程：重量级，切换成本高&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;进程：拥有独立内存空间，天然隔离&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;操作系统级别的“进程”之间&lt;strong&gt;不共享内存&lt;&#x2F;strong&gt;，但通信靠 IPC（管道、socket、共享内存）实现——和 CSP 很像，但远不如 goroutine 高效。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ipc-jin-cheng-jian-tong-xin&quot;&gt;IPC 进程间通信&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;IPC（Inter-Process Communication，进程间通信）是一种机制，允许操作系统中不同进程之间交换数据或信号。由于每个进程拥有独立的内存空间，它们无法直接访问彼此的数据，因此需要通过IPC来实现协作和资源共享。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;cspde-you-lie-shi&quot;&gt;CSP的优劣势&lt;&#x2F;h3&gt;
&lt;p&gt;原则： 如果违反 CSP 原则，&lt;strong&gt;通过 Channel 间接共享内存&lt;&#x2F;strong&gt;，仍需要锁：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type Data struct{ X int }
func main() {
    ch := make(chan *Data)
    d := &amp;amp;Data{X: 1}
    go func() { ch &amp;lt;- d }() &amp;#x2F;&amp;#x2F; 发送指针
    go func() { d.X++ }()   &amp;#x2F;&amp;#x2F; 竞态！违背 CSP
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;channel 不是万能保险，传的是引用时就要小心。&lt;&#x2F;p&gt;
&lt;p&gt;社区回答！&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;There are cases where CSP produces better performance and cases where the performance is worse. On the one hand, for code that does a lot of small multithreaded operations (like incrementing integers etc), converting all operations to happen via channels is going to be much less performant because channels involve more work per operation. On the other hand, the fact that memory isn&amp;#x27;t concurrently shared means that you can write faster single threaded code because you don&amp;#x27;t need to worry about mutexes and barriers etc for objects received from channels.

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go-benchmarks.com&#x2F;synchronization-methods&quot;&gt;同步方法测试&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.jtolio.com&#x2F;2016&#x2F;03&#x2F;go-channels-are-bad-and-you-should-feel-bad&#x2F;&quot;&gt;一篇帖子的说明&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;作者的吐槽点&lt;&#x2F;em&gt; ： “- &lt;strong&gt;channel 适合某些场景&lt;&#x2F;strong&gt;（如任务队列、事件通知、流水线模式）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mutex 适合另一些场景&lt;&#x2F;strong&gt;（如保护共享状态、简单临界区）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&quot;channel of channels&quot; 确实可能增加复杂度&lt;&#x2F;strong&gt;，但 Go 的 select + channel 机制也能提供强大的并发控制能力。”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;“作者的观点是 &lt;strong&gt;&quot;不要为了用 channel 而用 channel&quot;&lt;&#x2F;strong&gt;，应该根据实际情况选择最合适的同步机制（mutex 或 channel），而不是盲目遵循 Go 的 &quot;share memory by communicating&quot; 哲学。”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;songlh.github.io&#x2F;paper&#x2F;go-study.pdf&quot;&gt;一篇论文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yi-csp-de-lie-shi-chang-jing-xing-neng-chai&quot;&gt;一、CSP 的劣势场景（性能差）：&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; 用 mutex 的方式做 ++ 操作
mu.Lock()
counter++
mu.Unlock()

&amp;#x2F;&amp;#x2F; 用 channel 的方式做 ++ 操作
counterChan &amp;lt;- 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chan&lt;&#x2F;code&gt; 本质是有同步开销的（排队、调度、阻塞），一个简单的 &lt;code&gt;++&lt;&#x2F;code&gt; 操作搞成 channel 会变得很重。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以在高频、低开销场景，&lt;strong&gt;channel 性能不如原子操作 &#x2F; 锁&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;csp-de-you-shi-chang-jing-xing-neng-hao&quot;&gt;CSP 的优势场景（性能好）：&lt;&#x2F;h4&gt;
&lt;p&gt;“但另一方面，因为内存不是共享的，单线程处理收到的 channel 数据，不需要加锁，写起来更快、更简单。”&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;内存不是共享的”表述不严谨&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel 的底层本质仍然是共享内存；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;它只是&lt;strong&gt;封装了共享细节，让你不直接共享&lt;&#x2F;strong&gt;；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以说准确表述应是：“你&lt;strong&gt;不需要直接访问共享内存&lt;&#x2F;strong&gt;”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&amp;#x2F;&amp;#x2F; 一个 goroutine 独占处理任务队列
go func() {
  for task := range taskChan {
    handle(task) &amp;#x2F;&amp;#x2F; 不需要担心并发访问
  }
}()

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;kun-huo&quot;&gt;困惑&lt;&#x2F;h4&gt;
&lt;p&gt;channel的内部也就是底层实现 不还是使用的内存共享+锁机制实现的吗，这里面真的会有性能差别吗？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;he-xin-hui-da&quot;&gt;核心回答！&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;你用不用锁，和系统&#x2F;库替你加不加锁，是两回事。&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Go 的 &lt;code&gt;channel&lt;&#x2F;code&gt; 底层确实是用&lt;strong&gt;共享内存 + 加锁&lt;&#x2F;strong&gt;实现的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chan&lt;&#x2F;code&gt; 的发送和接收涉及锁（&lt;code&gt;mutex&lt;&#x2F;code&gt;）、等待队列（&lt;code&gt;sudog&lt;&#x2F;code&gt;）、调度协程切换等。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以说 channel 本身也有“同步开销”。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那为什么说 “你写的代码没锁” 性能反而更好？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;guan-jian-shi-feng-zhuang-he-bing-fa-yu-zui-xiao-hua&quot;&gt;&lt;strong&gt;关键是“封装” 和 “并发域最小化”&lt;&#x2F;strong&gt;：&lt;&#x2F;h4&gt;
&lt;blockquote&gt;
&lt;p&gt;channel 把“并发边界”控制在接口级别，而不是让你每个字段自己去加锁。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;strong&gt;你写的处理函数&lt;&#x2F;strong&gt;只处理 &lt;code&gt;&amp;lt;-chan&lt;&#x2F;code&gt; 接收的数据，不访问共享变量：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它是&lt;strong&gt;串行&lt;&#x2F;strong&gt;的，不涉及任何并发操作；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所以&lt;strong&gt;你可以不用管加锁、原子操作、同步屏障&lt;&#x2F;strong&gt;；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;你的代码天然是“线程安全”的，这会&lt;strong&gt;减少脑力负担 + 提高可维护性 + 避免 bug&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;channel 是“通信安全”，不是“零成本”。&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
真正的性能差异不在“是否用了内存共享”，而是&lt;strong&gt;谁来负责并发同步的复杂性&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;数据被携带着传输”这句，&lt;strong&gt;精准命中了 CSP 的核心思想&lt;&#x2F;strong&gt;，也正是 Go 在并发编程中推荐的思维方式。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;不要通过共享内存来通信，而应该通过通信来共享内存。&lt;&#x2F;strong&gt;（Go 编程语言官方理念）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;plan-9-from-bell-labs&quot;&gt;&lt;strong&gt;Plan 9 from Bell Labs&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;The OS itself also avoids sharing memory, and of course there are &amp;quot;channels&amp;quot; for communicating: file descriptors, which can be devices, pipes, network connections, etc. Like in Unix. But it goes beyond what traditional Unix does, because many userspace applications are file servers that provide a file descriptor that can be mounted onto the file system, and provide more such file descriptors, etc. It&amp;#x27;s a very simple but powerful system.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;plan9操作系统避免了共享内存, 那内部是什么样的呢 进程之间如何通信呢&lt;&#x2F;p&gt;
&lt;p&gt;在Go SDK中 runtime包中含又 plan9的身影！&lt;&#x2F;p&gt;
&lt;p&gt;Plan 9 &lt;strong&gt;避免传统的共享内存和多线程同步机制&lt;&#x2F;strong&gt;，鼓励进程之间用“文件通信”（如命名管道、9P 协议）：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类似 Go 的 Channel，但用的是文件协议。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;所有通信都可序列化，可远程传输。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote&gt;
&lt;p&gt;难道操作文件就不是操作同一块内存了吗？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;p&gt;共享内存&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;int *shared = mmap(...);  &amp;#x2F;&amp;#x2F; 多个进程访问这个地址
*shared = 42;             &amp;#x2F;&amp;#x2F; 谁都能读写这块内存
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;文件通信&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;echo 42 &amp;gt; &amp;#x2F;srv&amp;#x2F;somefile     # 写入
cat &amp;#x2F;srv&amp;#x2F;somefile           # 另一个程序读
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;虽然最终数据可能写入页缓存或磁盘（确实会进内存），但你&lt;strong&gt;无法直接访问或共享那块内存&lt;&#x2F;strong&gt;，只能通过：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统调用（read&#x2F;write）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Channel 抽象（Go）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;文件协议（Plan 9）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;yi-wen&quot;&gt;疑问：&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;那xv6系统的内存的关于 前面所说的CSP理论和共享内存，xv6是偏向与什么？ 或者说linux系统都沿用了文件通信？&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;xv6 和 Linux 都以“共享内存 + 文件通信”为基础，核心机制是“共享内存 + 加锁”，而不是 CSP 模型。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;所以说文件通信和CSP之间的关系是什么？ 有联系吗 为什么前面你跟我说Plan 9 设计就是避免共享内存，强调文件通信 + 用户态协议 那既然文件通信是避免共享内存，那为什么不能说xv6等liunx操作系统不是CSP模型呢&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;文件通信是一种实现机制，CSP 是一种并发模型。Plan 9 把文件通信机制用于实现类似 CSP 的并发风格；而 Linux 虽然也有文件通信，但仍然基于共享内存 + 锁，不符合 CSP 的并发语义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;Linux&#x2F;xv6&lt;&#x2F;th&gt;&lt;th&gt;CSP (Plan 9 风格)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;默认通信方式&lt;&#x2F;td&gt;&lt;td&gt;共享内存 + 锁&lt;&#x2F;td&gt;&lt;td&gt;Channel &#x2F; 消息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;文件通信&lt;&#x2F;td&gt;&lt;td&gt;有，但不普遍用作并发通信&lt;&#x2F;td&gt;&lt;td&gt;核心机制&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;并发语义&lt;&#x2F;td&gt;&lt;td&gt;多线程共享状态&lt;&#x2F;td&gt;&lt;td&gt;顺序过程 + 通信&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;并发控制&lt;&#x2F;td&gt;&lt;td&gt;mutex、atomic、lock&lt;&#x2F;td&gt;&lt;td&gt;通信即同步&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;数据一致性&lt;&#x2F;td&gt;&lt;td&gt;程序员手动维护&lt;&#x2F;td&gt;&lt;td&gt;通信机制保证&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Plan 9 并没有在商业或主流社区中广泛流行，但它对&lt;strong&gt;现代操作系统的设计理念影响深远&lt;&#x2F;strong&gt;。许多重要思想被吸收进 Linux、Go 语言、Docker 等系统中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mkfifo-is-os-s-channel&quot;&gt;mkfifo is OS&#x27;s channel&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkfifo&lt;&#x2F;code&gt; 是一个 Linux 系统调用（命令），用于&lt;strong&gt;创建一个命名管道（FIFO）&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;FIFO = First In, First Out，像文件一样存在于磁盘，但其实是一种特殊的**IPC（进程间通信）**手段。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;创建后，多个进程可以通过读写这个“文件”来通信。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Go 的 &lt;code&gt;chan&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;OS 的 &lt;code&gt;mkfifo&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;语言级通道，只在 Go 中使用&lt;&#x2F;td&gt;&lt;td&gt;系统级别，多个进程&#x2F;语言可用&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;内存中的结构，速度快&lt;&#x2F;td&gt;&lt;td&gt;磁盘上的文件，效率低，但能跨进程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;用于 goroutine 间通信&lt;&#x2F;td&gt;&lt;td&gt;用于进程间通信（IPC）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;类型安全、阻塞&#x2F;非阻塞控制强&lt;&#x2F;td&gt;&lt;td&gt;只能读字节流，无结构化信&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;xian-cheng-chi&quot;&gt;线程池&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;pi-ping-go-yu-yan-zai-cuo-wu-chu-li-he-yi-xie-te-shu-yu-fa-shang-de-bu-yi-zhi-xing&quot;&gt; &lt;strong&gt;批评 Go 语言在错误处理和一些特殊语法上的不一致性&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;bravenewgeek.com&#x2F;go-is-unapologetically-flawed-heres-why-we-use-it&#x2F;&quot;&gt;另一篇&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;There are other peculiar idiosyncrasies. Error handling is generally done by returning error values. This is fine, and I can certainly see the motivation coming from the abomination of C++ exceptions, but there are cases where Go doesn’t follow its own rule. For example, map lookups return two values: the value itself (or zero-value&amp;#x2F;nil if it doesn’t exist) and a boolean indicating if the key was in the map. Interestingly, we can choose to ignore the boolean value altogether—a syntax reserved for certain blessed types in the standard library. Type assertions and channel receives have equally curious behavior.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;file, err := os.Open(&amp;quot;foo.txt&amp;quot;)
if err != nil {
    return err
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;这是 Go 的核心设计哲学之一：&lt;strong&gt;强制程序员显式处理错误&lt;&#x2F;strong&gt;，避免像 C++ 异常（exceptions）那样隐式传播。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;value, exists := myMap[&amp;quot;key&amp;quot;]  &amp;#x2F;&amp;#x2F; 返回值和布尔值
value = myMap[&amp;quot;key&amp;quot;]           &amp;#x2F;&amp;#x2F; 可以忽略布尔值，直接取值
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;但 Go 允许 &lt;strong&gt;直接忽略布尔值&lt;&#x2F;strong&gt;，这种语法是 &lt;strong&gt;标准库的 &quot;特权&quot;&lt;&#x2F;strong&gt;（&quot;blessed types&quot;），普通函数无法实现类似行为。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这违背了 Go 的 &quot;显式处理&quot; 原则。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;str, ok := x.(string)  &amp;#x2F;&amp;#x2F; 安全写法，返回 (value, bool)
str = x.(string)       &amp;#x2F;&amp;#x2F; 如果失败，直接 panic（类似异常）
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种形式（返回 &lt;code&gt;bool&lt;&#x2F;code&gt;）符合 Go 的错误处理风格。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二种形式（直接 &lt;code&gt;panic&lt;&#x2F;code&gt;）却 &lt;strong&gt;退回到了异常机制&lt;&#x2F;strong&gt;，与 Go 的哲学矛盾。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;val, ok := &amp;lt;-ch  &amp;#x2F;&amp;#x2F; 如果 channel 关闭，ok 为 false
val = &amp;lt;-ch       &amp;#x2F;&amp;#x2F; 如果 channel 关闭，返回零值（无警告）
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种形式可以检测 channel 是否关闭。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第二种形式 &lt;strong&gt;静默接受零值&lt;&#x2F;strong&gt;，可能导致隐蔽的 bug。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;对开发者的启示：&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;需要警惕这些 &quot;语法糖&quot; 可能隐藏的问题。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;在关键代码中，始终使用完整形式（如 &lt;code&gt;val, ok := m[key]&lt;&#x2F;code&gt;）以避免 bug。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;li-jie-yi-chang-he-cuo-wu&quot;&gt;理解异常和错误&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;错误（&lt;code&gt;error&lt;&#x2F;code&gt;）——正常业务流程中的问题&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;本质：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是一种&lt;strong&gt;值&lt;&#x2F;strong&gt;（&lt;code&gt;error&lt;&#x2F;code&gt; 接口类型），代表函数运行时出现的问题。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;你需要主动检查和处理&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;异常（&lt;code&gt;panic&lt;&#x2F;code&gt;）——非正常流程，程序直接崩溃&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;本质：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是 Go 用来表示&lt;strong&gt;程序出现严重问题时&lt;&#x2F;strong&gt;的机制。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;一旦 &lt;code&gt;panic&lt;&#x2F;code&gt; 被调用，当前函数就会停止执行，&lt;strong&gt;逐层向上退出栈帧&lt;&#x2F;strong&gt;，直到程序崩溃或被 &lt;code&gt;recover&lt;&#x2F;code&gt; 捕获&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;常用于：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组越界&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;nil 指针调用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;程序员写错逻辑时提示开发者修复&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;错误（error）是业务可恢复的问题，异常（panic）是不可恢复、必须终止或特殊处理的问题。&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
在实际开发中，&lt;strong&gt;90% 的问题都用 error 返回，不要滥用 panic&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Go 的理念之一是“通过交流分享记忆;不要通过共享内存来交流。这是标准库似乎经常打破的另一个规则。标准库中大约有 60 个通道，不包括测试。如果您浏览代码，您会发现互斥锁往往是首选，并且通常性能更好 — 稍后将对此进行详细介绍。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sync-atomic&quot;&gt;sync&#x2F;atomic&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;We want sync to be clearly documented and used when appropriate. We generally don’t want sync&amp;#x2F;atomic to be used at all…Experience has shown us again and again that very very few people are capable of writing correct code that uses atomic operations…If we had thought of internal packages when we added the sync&amp;#x2F;atomic package, perhaps we would have used that. Now we can’t remove the package because of the Go 1 guarantee.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sync&lt;&#x2F;code&gt; 包的定位&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sync&lt;&#x2F;code&gt; 包（如 &lt;code&gt;sync.Mutex&lt;&#x2F;code&gt;、&lt;code&gt;sync.WaitGroup&lt;&#x2F;code&gt;）是 &lt;strong&gt;官方推荐&lt;&#x2F;strong&gt; 的同步原语，应该被 &lt;strong&gt;清晰地文档化&lt;&#x2F;strong&gt; 并在合适的场景使用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这些高阶同步工具（如互斥锁、条件变量）已经封装了底层复杂性，普通开发者可以安全使用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sync&#x2F;atomic&lt;&#x2F;code&gt; 包的定位&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sync&#x2F;atomic&lt;&#x2F;code&gt;（提供原子操作，如 &lt;code&gt;atomic.AddInt32&lt;&#x2F;code&gt;）&lt;strong&gt;本应设计为内部包&lt;&#x2F;strong&gt;（&lt;code&gt;internal&lt;&#x2F;code&gt;），因为它的正确使用需要极深的并发编程经验。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;绝大多数开发者 &lt;strong&gt;无法写出正确的原子操作代码&lt;&#x2F;strong&gt;（即使是有经验的程序员也容易犯错）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;但由于历史原因（Go 1 兼容性承诺），现在无法移除或隐藏该包。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Go 团队认为 原子操作是危险的，应该尽量避免使用，除非在极少数底层库（如运行时、标准库内部）中。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;普通业务代码应优先使用 &lt;code&gt;sync&lt;&#x2F;code&gt; 包提供的更安全的抽象（如 &lt;code&gt;Mutex&lt;&#x2F;code&gt;），而非直接操作 &lt;code&gt;atomic&lt;&#x2F;code&gt;。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;WHY？？？&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子操作的正确性依赖于 &lt;strong&gt;内存模型&lt;&#x2F;strong&gt;（memory model）和 &lt;strong&gt;CPU 指令顺序&lt;&#x2F;strong&gt;（memory ordering）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;开发者需要理解 &lt;strong&gt;可见性&lt;&#x2F;strong&gt;（visibility）、&lt;strong&gt;重排序&lt;&#x2F;strong&gt;（reordering）、&lt;strong&gt;ABA 问题&lt;&#x2F;strong&gt; 等复杂概念，否则极易写出有 bug 的代码。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;基于原子操作的代码通常难以阅读和调试（例如无锁数据结构）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;团队协作时，其他成员可能无法理解其背后的并发逻辑。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre&gt;&lt;code&gt; Go 团队的历史决策反思
1. `internal` 包的缺失：

    - Go 早期没有 `internal` 包机制（限制某些包仅限标准库内部使用）。
        
    - 如果当时有，`sync&amp;#x2F;atomic` 可能会被标记为 `internal`，避免外部开发者误用。
        
2. Go 1 兼容性承诺：
    
    - Go 1 版本承诺不破坏向后兼容性，因此即使现在认识到 `atomic` 的问题，也无法移除或降级该包。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;Clearly, channels are not particularly great for workload throughput, and you’re typically better off using a lock-free ring buffer or even a synchronized queue. Channels as a unit of composition tend to [fall short](https:&amp;#x2F;&amp;#x2F;gist.github.com&amp;#x2F;kachayev&amp;#x2F;21e7fe149bc5ae0bd878) as well. Instead, they are better suited as a coordination pattern, a mechanism for signaling and timing-related code. Ultimately, you must use channels judiciously if you are sensitive to performance.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;yuan-zi-cao-zuo-he-suo-de-qu-bie&quot;&gt;原子操作和锁的区别&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;原子操作（&lt;code&gt;atomic&lt;&#x2F;code&gt;）&lt;&#x2F;th&gt;&lt;th&gt;锁（&lt;code&gt;Mutex&lt;&#x2F;code&gt;）&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;底层机制&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;直接使用 CPU 原子指令（如 &lt;code&gt;CAS&lt;&#x2F;code&gt;、&lt;code&gt;LL&#x2F;SC&lt;&#x2F;code&gt;）&lt;&#x2F;td&gt;&lt;td&gt;基于操作系统调度（如 &lt;code&gt;futex&lt;&#x2F;code&gt;）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;粒度&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;单变量级别（如 &lt;code&gt;int32&lt;&#x2F;code&gt;、&lt;code&gt;pointer&lt;&#x2F;code&gt;）&lt;&#x2F;td&gt;&lt;td&gt;代码块级别（保护一段逻辑）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;是否阻塞&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;非阻塞（硬件级原子操作，无上下文切换）&lt;&#x2F;td&gt;&lt;td&gt;阻塞（竞争失败时，线程会休眠）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;适用场景&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;简单变量操作（计数器、标志位）&lt;&#x2F;td&gt;&lt;td&gt;复杂逻辑（需保护多个变量或代码段）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;性能&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;极高（无锁，无线程切换）&lt;&#x2F;td&gt;&lt;td&gt;较低（锁竞争时有上下文切换开销）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;正确性难度&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;高（需理解内存模型，易写出 bug）&lt;&#x2F;td&gt;&lt;td&gt;低（直接加锁，逻辑清晰）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;gong-xiang-nei-cun-he-csp&quot;&gt;共享内存和CSP&lt;&#x2F;h2&gt;
&lt;p&gt;共享内存去并发，和csp理论去并发 为什么会有很大的差别，为什么csp貌似是对并发更好的模型&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;共享内存并发强调“状态共享”，而 CSP 并发强调“消息传递”&lt;&#x2F;strong&gt;。&lt;br &#x2F;&gt;
&lt;strong&gt;CSP 更容易构建正确、安全、可组合的并发程序。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方面&lt;&#x2F;th&gt;&lt;th&gt;共享内存 (Shared Memory)&lt;&#x2F;th&gt;&lt;th&gt;CSP（通信顺序进程）&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;本质&lt;&#x2F;td&gt;&lt;td&gt;多个线程访问同一内存变量&lt;&#x2F;td&gt;&lt;td&gt;多个进程通过通道通信&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;协作方式&lt;&#x2F;td&gt;&lt;td&gt;读写共享变量 + 加锁&lt;&#x2F;td&gt;&lt;td&gt;发送消息 + 阻塞等待&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;错误风险&lt;&#x2F;td&gt;&lt;td&gt;数据竞争，死锁，难调试&lt;&#x2F;td&gt;&lt;td&gt;更可控，天然同步&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;例子&lt;&#x2F;td&gt;&lt;td&gt;C&#x2F;C++ 中的线程 + mutex&lt;&#x2F;td&gt;&lt;td&gt;Go 中的 goroutine + channel&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;em&gt;共享内存的问题！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可见性问题&lt;&#x2F;strong&gt;：一个线程修改变量，另一个线程可能看不到（CPU 缓存、编译器优化等）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;竞争条件（Race Condition）&lt;&#x2F;strong&gt;：线程读写冲突导致不一致&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加锁非常脆弱&lt;&#x2F;strong&gt;：容易忘记加锁、锁顺序死锁、性能差、调试困难&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态耦合&lt;&#x2F;strong&gt;：多个线程对共享数据的意图难以区分&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;CSP 把“并发的核心问题”转化了：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从“如何共享变量”转为“如何传递消息”&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通道通信是同步的，相当于自带锁机制&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;goroutine 是轻量级的，天然适合大规模并发&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;CSP 不是性能最强的模型，但&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对“人类开发者”更友好；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对复杂系统的“构建和演化”更稳定；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;也是构建现代高并发系统时的&lt;strong&gt;主流模型之一&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;！！！ 你不是去“抢”变量，而是“请求”那个管理它的 goroutine 来操作它。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;plan9-go&quot;&gt;Plan9 &amp;amp; Go&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;she-ji-si-xiang-de-guan-lian&quot;&gt;设计思想的关联&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Plan 9 的设计思想&lt;&#x2F;th&gt;&lt;th&gt;Go 中的体现&lt;&#x2F;th&gt;&lt;th&gt;说明&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;一切皆文件&lt;&#x2F;strong&gt;（包括网络、图形等）&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;io.Reader&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;io.Writer&lt;&#x2F;code&gt; 接口统一抽象&lt;&#x2F;td&gt;&lt;td&gt;所有输入输出都被看作流（stream），统一接口风格&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;简洁统一的接口设计&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;接口设计简洁、不需显式实现，强调组合&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;interface&lt;&#x2F;code&gt; 不需要 &lt;code&gt;implements&lt;&#x2F;code&gt;，鼓励面向抽象编程&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;资源命名空间 per process&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;每个 &lt;code&gt;goroutine&lt;&#x2F;code&gt; 轻量、可独立使用 channel&lt;&#x2F;td&gt;&lt;td&gt;更细粒度的资源隔离感，goroutine 独立如 namespace&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;9P 协议：分布式资源像本地一样访问&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Go 的网络库设计抽象化（如 &lt;code&gt;net.Conn&lt;&#x2F;code&gt;）&lt;&#x2F;td&gt;&lt;td&gt;可以轻松写出“远程等于本地”的通信程序&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;并发不是线程，是消息通信（管道）&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;goroutine&lt;&#x2F;code&gt; + &lt;code&gt;channel&lt;&#x2F;code&gt; 是核心特性&lt;&#x2F;td&gt;&lt;td&gt;正是 CSP 模型（通讯顺序进程），而非线程锁死等待&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;最小化系统复杂性&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Go 排除继承、多重继承、异常机制&lt;&#x2F;td&gt;&lt;td&gt;简单就是力量，避免复杂性带来的维护成本&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;自举系统（compiler&#x2F;runtime 用自己写）&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Go 的工具链也是用 Go 写的（包括编译器、fmt 工具等）&lt;&#x2F;td&gt;&lt;td&gt;自洽、可控、统一体验&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;从plan9中吸收的内容&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;组合优于继承&lt;&#x2F;strong&gt;：Plan 9 没有传统面向对象；Go 同样用接口 + 组合结构体替代类继承；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消息通信代替共享内存&lt;&#x2F;strong&gt;：Plan 9 提倡“不要共享内存”；Go 鼓励用 channel 通信而非锁；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;极简内核&lt;&#x2F;strong&gt;：Plan 9 内核极简但灵活；Go 工具链同样追求“一个命令搞定”的体验；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统一接口抽象&lt;&#x2F;strong&gt;：Plan 9 的资源访问统一为文件；Go 将几乎所有资源抽象成 &lt;code&gt;io.Reader&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Writer&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Plan 9 的几个核心哲学在 Go 中的体现&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;1-yi-qie-jie-wen-jian-io-reader-io-writer-chou-xiang&quot;&gt;1. &lt;strong&gt;一切皆文件 &#x2F; io.Reader + io.Writer 抽象&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
)

func main() {
	var r io.Reader = strings.NewReader(&amp;quot;Hello Plan 9!&amp;quot;)
	io.Copy(os.Stdout, r) &amp;#x2F;&amp;#x2F; 输出到标准输出：Hello Plan 9!
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;无论是文件、字符串、网络连接，只要实现 &lt;code&gt;Reader&lt;&#x2F;code&gt; 接口，就能互换使用。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;2-zu-he-you-yu-ji-cheng&quot;&gt;2. &lt;strong&gt;组合优于继承&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type Logger struct{}

func (l Logger) Log(msg string) {
	println(&amp;quot;[LOG]&amp;quot;, msg)
}

type Service struct {
	Logger &amp;#x2F;&amp;#x2F; 嵌入，而非继承
}

func main() {
	s := Service{}
	s.Log(&amp;quot;Service started&amp;quot;) &amp;#x2F;&amp;#x2F; 调用嵌入字段的方法
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 不用继承，通过结构体组合来共享行为。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;zu-he-you-yu-ji-cheng-wei-shen-me-zai-go-zhong-shi-zheng-que-de&quot;&gt;组合优于继承” 为什么在 Go 中是正确的？&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type Logger struct{}
func (l Logger) Log(msg string) { fmt.Println(&amp;quot;[LOG]&amp;quot;, msg) }

type Service struct {
	Logger &amp;#x2F;&amp;#x2F; 组合，而不是继承
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;继承带来耦合，组合带来解耦&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;灵活：只组合需要的行为&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;解耦：Logger 改变不影响 Service&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;模块化更强，符合现代微服务理念&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;3-csp-bing-fa-mo-xing-goroutine-channel&quot;&gt;3. &lt;strong&gt;CSP 并发模型（goroutine + channel）&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func worker(ch chan string) {
	for msg := range ch {
		println(&amp;quot;received:&amp;quot;, msg)
	}
}

func main() {
	ch := make(chan string)
	go worker(ch)

	ch &amp;lt;- &amp;quot;task 1&amp;quot;
	ch &amp;lt;- &amp;quot;task 2&amp;quot;
	close(ch)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;goroutine 类似 Plan 9 的 lightweight process，channel 是通信通道，避免共享内存。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;4-zi-yuan-an-ming-ming-kong-jian-chou-xiang-net-conn-chou-xiang&quot;&gt;4. &lt;strong&gt;资源按命名空间抽象（net.Conn 抽象）&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net&amp;quot;
)

func main() {
	conn, _ := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;example.com:80&amp;quot;)
	fmt.Fprintf(conn, &amp;quot;GET &amp;#x2F; HTTP&amp;#x2F;1.0\r\n\r\n&amp;quot;)
	buf := make([]byte, 4096)
	n, _ := conn.Read(buf)
	fmt.Println(string(buf[:n]))
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;net.Conn&lt;&#x2F;code&gt; 可以代表 TCP、Unix socket 等，是统一的“文件风格”资源访问。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;5-zi-ju-zui-xiao-gong-ju-lian-go-bian-yi-qi-gong-ju-jiu-shi-yong-go-xie-de&quot;&gt;5. &lt;strong&gt;自举 + 最小工具链：Go 编译器&#x2F;工具就是用 Go 写的&lt;&#x2F;strong&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;go build main.go
go fmt main.go
go run main.go
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;没有 &lt;code&gt;make&lt;&#x2F;code&gt;，不需要配置，直接编译运行，体现极简主义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h3&gt;
&lt;p&gt;Go 语言很多地方直接体现了 Plan 9 的理念，尤其是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;接口驱动的抽象&lt;&#x2F;strong&gt;：&lt;code&gt;io.Reader&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;net.Conn&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发设计&lt;&#x2F;strong&gt;：channel 通信优先于加锁&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结构体组合&lt;&#x2F;strong&gt;：轻松构造可复用模块&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;极简工具链&lt;&#x2F;strong&gt;：从构建到部署尽可能统一&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;xi-tong-zi-liao&quot;&gt;系统资料&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;250967&#x2F;&quot;&gt;Articles&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go-proverbs.github.io&#x2F;&quot;&gt;Go 谚语&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;draven.co&#x2F;golang&#x2F;&quot;&gt;Go语言设计与实现&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;luminousmen.com&#x2F;&quot;&gt;技术博客&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pipe-he-channel&quot;&gt;pipe 和 channel&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;channel 和管道（pipe）不是一个东西&lt;&#x2F;strong&gt;，虽然它们的用途都是“通信”，但它们&lt;strong&gt;作用范围、实现层级、性能、使用方式都不同&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;Go &lt;code&gt;channel&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;操作系统 &lt;code&gt;pipe&lt;&#x2F;code&gt;（管道）&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;属于哪一层&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;用户态&lt;&#x2F;strong&gt;，Go runtime 提供&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;内核态&lt;&#x2F;strong&gt;，操作系统提供&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;通信对象&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;Goroutine 之间通信（线程级）&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;进程之间通信（进程级）&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;是否跨语言&lt;&#x2F;td&gt;&lt;td&gt;否（Go 专属）&lt;&#x2F;td&gt;&lt;td&gt;是（C、Python、Bash 等都能用）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;是否跨进程&lt;&#x2F;td&gt;&lt;td&gt;否&lt;&#x2F;td&gt;&lt;td&gt;是&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;是否需要内核参与&lt;&#x2F;td&gt;&lt;td&gt;否（调度在用户态）&lt;&#x2F;td&gt;&lt;td&gt;是（需要系统调用）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;通信方式&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;ch &amp;lt;- val&lt;&#x2F;code&gt;, &lt;code&gt;&amp;lt;- ch&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;write(pipefd[1], ...)&lt;&#x2F;code&gt;, &lt;code&gt;read(...)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;性能&lt;&#x2F;td&gt;&lt;td&gt;高（上下文切换成本低）&lt;&#x2F;td&gt;&lt;td&gt;相对低（涉及内核上下文切换）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;线程安全&lt;&#x2F;td&gt;&lt;td&gt;是（channel 天然并发安全）&lt;&#x2F;td&gt;&lt;td&gt;是（由内核控制）&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;strong&gt;pipe 并不使用 CSP（通信顺序进程）思想&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;操作系统中的 &lt;code&gt;pipe&lt;&#x2F;code&gt; 本质上是&lt;strong&gt;两个进程通过共享内核缓冲区来读写数据&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;写进程调用 &lt;code&gt;write()&lt;&#x2F;code&gt; 把数据写入 pipe（内核缓冲区）；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;读进程调用 &lt;code&gt;read()&lt;&#x2F;code&gt; 从 pipe 中读取数据；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;管道本质上是&lt;strong&gt;一个 FIFO（先进先出）缓冲区&lt;&#x2F;strong&gt;；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;多数是&lt;strong&gt;阻塞式&lt;&#x2F;strong&gt;的（读时无数据就阻塞，写时缓冲区满也阻塞）；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;是一种&lt;strong&gt;共享内存 + 同步机制&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title> 提问的智慧</title>
          <pubDate>Wed, 28 May 2025 12:26:17 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-6/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-6/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-6/">&lt;p&gt;“好问题！”是诚挚的大力称赞&lt;&#x2F;p&gt;
&lt;p&gt;你必须花费时间在问题上，而不是遇到问题什么也不付出的直接索取！那和强盗没什么区别！&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;你并不是一个不劳而获且浪费别人的时间的提问者&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zai-ti-wen-zhi-qian&quot;&gt;在提问之前&lt;&#x2F;h2&gt;
&lt;p&gt;在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;尝试在你准备提问的论坛的旧文章中搜索答案。&lt;&#x2F;li&gt;
&lt;li&gt;尝试上网搜索以找到答案。&lt;&#x2F;li&gt;
&lt;li&gt;尝试阅读手册以找到答案。&lt;&#x2F;li&gt;
&lt;li&gt;尝试阅读常见问题文件（FAQ）以找到答案。&lt;&#x2F;li&gt;
&lt;li&gt;尝试自己检查或试验以找到答案。&lt;&#x2F;li&gt;
&lt;li&gt;向你身边的强者朋友打听以找到答案。&lt;&#x2F;li&gt;
&lt;li&gt;如果你是程序开发者，请尝试阅读源代码以找到答案。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;em&gt;不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;草率的发问只能得到草率的回答，或者根本得不到任何答案&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;你为解决问题所付出的努力，你越有可能得到实质性的帮助。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shen-xuan-ti-wen-de-lun-tan&quot;&gt;慎选提问的论坛&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;在与主题不合的论坛上贴出你的问题。&lt;&#x2F;li&gt;
&lt;li&gt;在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。&lt;&#x2F;li&gt;
&lt;li&gt;在太多的不同新闻群组上重复转贴同样的问题（cross-post）。&lt;&#x2F;li&gt;
&lt;li&gt;向既非熟人也没有义务解决你问题的人发送私人电邮。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;stack-overflow&quot;&gt;Stack Overflow&lt;&#x2F;h3&gt;
&lt;p&gt;搜索，_然后_在 Stack Exchange 问。&lt;&#x2F;p&gt;
&lt;p&gt;近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。&lt;&#x2F;p&gt;
&lt;p&gt;Stack Exchange 已经成长到&lt;a href=&quot;https:&#x2F;&#x2F;stackexchange.com&#x2F;sites&quot;&gt;超过一百个网站&lt;&#x2F;a&gt;，以下是最常用的几个站：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。&lt;&#x2F;li&gt;
&lt;li&gt;Stack Overflow 是问写程序有关的问题。&lt;&#x2F;li&gt;
&lt;li&gt;Server Fault 是问服务器和网管相关的问题。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wang-zhan-he-irc-lun-tan&quot;&gt;网站和 IRC 论坛&lt;&#x2F;h3&gt;
&lt;p&gt;在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天&lt;&#x2F;p&gt;
&lt;p&gt;RTFM（Read The Fucking Manual）&lt;&#x2F;p&gt;
&lt;p&gt;STFW（Search The Fucking Web）&lt;&#x2F;p&gt;
&lt;p&gt;如何知道你已完全搞砸了哈哈哈&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>你的灯还亮着吗</title>
          <pubDate>Wed, 28 May 2025 12:25:43 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-5/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-5/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-5/">&lt;p&gt;今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题&lt;&#x2F;p&gt;
&lt;p&gt;文字游戏：一句话不同的停顿产生不同的问题&lt;&#x2F;p&gt;
&lt;p&gt;有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）&lt;&#x2F;p&gt;
&lt;p&gt;你是不是真的想要解决这问题？&lt;&#x2F;p&gt;
&lt;p&gt;追溯本源，从一个婴儿视角重新审视这个问题！&lt;&#x2F;p&gt;
&lt;p&gt;一生二，二生三，三生万物： 你对一个问题的解决（是否是真的解决？）一个问题的解决必然产生另一个问题的产生！&lt;&#x2F;p&gt;
&lt;p&gt;看看你是否能从一个问题的解决，来想到它产生了3个其他的问题？&lt;&#x2F;p&gt;
&lt;p&gt;询问问题可能简单的一句话就可以起到很重要的作用！&lt;&#x2F;p&gt;
&lt;p&gt;比如： 在隧道中提醒车辆：你的灯还亮着吗？（避免询问过长） 解决了因为客户要欣赏风景而不清楚他们的灯是否还亮着&lt;&#x2F;p&gt;
&lt;p&gt;从多个角度思一个问题问题的产生，最有可能是由谁来解决，或者说有的问题已经给出了最佳的解决人选，你需要让他自身清楚他需要站出来解决问题&lt;&#x2F;p&gt;
&lt;p&gt;有些问题需要从自身去思考，从而问题也就解决了&lt;&#x2F;p&gt;
&lt;p&gt;鱼事最后一个见到水的：周围环境的影响！（经常思考自己身处的环境）有一些东西已经被固化了！处在一种模式下，你的思想可能也跟着这种思想牵着&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title> 我的2024</title>
          <pubDate>Wed, 28 May 2025 11:56:29 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-3/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-3/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-3/">&lt;h1 id=&quot;2024&quot;&gt;2024&lt;&#x2F;h1&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;date: 2024-10-28&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;在散步的时候感概一年又过去了，问了问自己，大一的这一年都做了什么呢？哈哈哈我使劲的去想，好像没有留下什么&lt;&#x2F;p&gt;
&lt;p&gt;我通过我接触github所创建的仓库，以及电脑中我记录的笔记，和图库等去回想自己在今年都留下了什么痕迹呢&lt;&#x2F;p&gt;
&lt;h2 id=&quot;create-repos&quot;&gt;Create repos&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;&#x2F;th&gt;&lt;th&gt;REPO&lt;&#x2F;th&gt;&lt;th&gt;START&lt;&#x2F;th&gt;&lt;th&gt;UPDATE&lt;&#x2F;th&gt;&lt;th&gt;LANGUAGE&lt;&#x2F;th&gt;&lt;th&gt;STARS&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;-typro-&quot;&gt;-typro-&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-09-05&lt;&#x2F;td&gt;&lt;td&gt;2024-12-13&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;2024&quot;&gt;2024&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-27&lt;&#x2F;td&gt;&lt;td&gt;2024-12-27&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;6.S081os&quot;&gt;6.S081os&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-30&lt;&#x2F;td&gt;&lt;td&gt;2024-12-01&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;7days-golang&quot;&gt;7days-golang&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-22&lt;&#x2F;td&gt;&lt;td&gt;2024-11-22&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;codeforces-go&quot;&gt;codeforces-go&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-05-19&lt;&#x2F;td&gt;&lt;td&gt;2024-05-19&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Go-Programming&quot;&gt;Go-Programming&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-21&lt;&#x2F;td&gt;&lt;td&gt;2024-12-21&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Gopher_training&quot;&gt;Gopher_training&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-17&lt;&#x2F;td&gt;&lt;td&gt;2024-12-17&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;hello-algo&quot;&gt;hello-algo&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-10-15&lt;&#x2F;td&gt;&lt;td&gt;2024-10-15&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Knowledge-network&quot;&gt;Knowledge-network&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-20&lt;&#x2F;td&gt;&lt;td&gt;2024-12-20&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;learning-Golang&quot;&gt;learning-Golang&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-19&lt;&#x2F;td&gt;&lt;td&gt;2024-12-26&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;leetcode-master&quot;&gt;leetcode-master&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-10-14&lt;&#x2F;td&gt;&lt;td&gt;2024-10-14&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;project-based-learning&quot;&gt;project-based-learning&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-27&lt;&#x2F;td&gt;&lt;td&gt;2024-12-27&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;13&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Simple_bank&quot;&gt;Simple_bank&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-10&lt;&#x2F;td&gt;&lt;td&gt;2024-12-08&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;14&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Study_Go&quot;&gt;Study_Go&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-16&lt;&#x2F;td&gt;&lt;td&gt;2024-11-26&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;tongxun&quot;&gt;tongxun&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2023-12-12&lt;&#x2F;td&gt;&lt;td&gt;2024-09-12&lt;&#x2F;td&gt;&lt;td&gt;C++&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;UDP_socket&quot;&gt;UDP_socket&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-27&lt;&#x2F;td&gt;&lt;td&gt;2024-11-27&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;17&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;urlshortener&quot;&gt;urlshortener&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-12-04&lt;&#x2F;td&gt;&lt;td&gt;2024-12-09&lt;&#x2F;td&gt;&lt;td&gt;Go&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;18&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Whuichenggong&quot;&gt;Whuichenggong&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-09-01&lt;&#x2F;td&gt;&lt;td&gt;2024-12-20&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;19&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Whuichenggong&#x2F;Whuichenggong.github.io&quot;&gt;Whuichenggong.github.io&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;2024-11-04&lt;&#x2F;td&gt;&lt;td&gt;2024-12-25&lt;&#x2F;td&gt;&lt;td&gt;HTML&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;emm发现创建的仓库都是在近期创建的，感觉是2024年末端感觉才正式步入后端学习的正轨，重视计算机基础学习，重视语言基础的学习&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2023-9-12yue&quot;&gt;2023. 9~12月&lt;&#x2F;h2&gt;
&lt;p&gt;看了看 git  c++ 等&lt;&#x2F;p&gt;
&lt;p&gt;我清楚地记得在大学刚入学的时候，在图书馆中学习了b站的数据结构课程，看了b站的马士兵的算法，好几天都沉浸在算法中的学习&lt;&#x2F;p&gt;
&lt;p&gt;可能那个时候也没有目标吧，跟着学校学习课程，在课余时间，学习了一些计算机的工具，简单看了看计算机基础，我那个时候觉得&lt;&#x2F;p&gt;
&lt;p&gt;计算机基础确实是很重要的，但是那个时候学习可能也就是死学吧！不讲究效率和技巧。&lt;&#x2F;p&gt;
&lt;p&gt;当时研究了很多数据结构，啊第一次学真的理解的很难哈哈哈，现在重新回来看看有的代码也懂了！&lt;&#x2F;p&gt;
&lt;p&gt;还去图书馆看了较教员的书哈哈：感觉真的很有意义在图书馆看书，而不是复习！&lt;&#x2F;p&gt;
&lt;p&gt;也了解了一些关于计算机的形式，焦虑的很！各种在网上查，目前来说想法也确实有很多变化！&lt;&#x2F;p&gt;
&lt;p&gt;也度过了大学的第一个生日与室友们非常开心!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;e253da76-bfc0-4387-b06c-d6a4ef58cc5b&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;大一上可能就这么过去了吧！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;han-jia&quot;&gt;寒假&lt;&#x2F;h2&gt;
&lt;p&gt;在寒假的时候，与小时候经常在一起玩的小弟，又见面了，也是好几年没见了，感觉和小的时候不一样，感情更加浓厚了！小时候可能&lt;&#x2F;p&gt;
&lt;p&gt;因为小的事去吵架，现在不会了，都长大了哈哈！&lt;&#x2F;p&gt;
&lt;p&gt;家里的饭永远是最香的&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2024-5-7yue-fen&quot;&gt;2024.5~7月份&lt;&#x2F;h2&gt;
&lt;p&gt;加入了学校的实验室！因为没有了自习室，我必须找到一个可以自己学习的地方，我加入了学校实验室！最正确的决定&lt;&#x2F;p&gt;
&lt;p&gt;认识了各有各志向的学长们！&lt;&#x2F;p&gt;
&lt;p&gt;在这个阶段我还是停留在学习go语言基础和计算机基础的一些事情&lt;&#x2F;p&gt;
&lt;p&gt;中间还有一条时间线就是！在加入一些微信群之后，认识的一些工作的老哥们给我指了一些方向，我也听从了并到今天&lt;&#x2F;p&gt;
&lt;p&gt;让我在我的后端语言中选择了Go，至今为止，Go也是我的第一个深入学习的语言&lt;&#x2F;p&gt;
&lt;p&gt;“你弄懂源码，会做项目了，同时计算机原理也大致清楚了，（有疑问的地方自己再补）。你只弄计算机原理，既枯燥记不住，最后还是什么都不会。”&lt;&#x2F;p&gt;
&lt;p&gt;-感谢老哥的建议我也有了一些方向！&lt;&#x2F;p&gt;
&lt;p&gt;在2024年9月我真正的了解到了后端的一些技术，并且跟进的去学习一些工具&lt;&#x2F;p&gt;
&lt;p&gt;我的启蒙项目：&lt;&#x2F;p&gt;
&lt;p&gt;simplebank&lt;&#x2F;p&gt;
&lt;p&gt;至今也在跟着做！这真正的带我走进了后端的大门！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2024nian-shu-jia&quot;&gt;2024年暑假&lt;&#x2F;h2&gt;
&lt;p&gt;最难忘的暑假先是和姐姐在辽宁，玩了半个月非常开心，已经快10年没有相见了哈！&lt;&#x2F;p&gt;
&lt;p&gt;我大姑领着小妹从日本飞了过来，小妹只是在刚出生来中国呆了一段时间!我们一起玩了游戏！&lt;&#x2F;p&gt;
&lt;p&gt;《我的世界》，感觉她非常喜欢玩这个游戏哈哈，非常的听话，很难忘的一个假期&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2024nian-jin-xie-ri-zi&quot;&gt;2024年近些日子&lt;&#x2F;h2&gt;
&lt;p&gt;最能触动我的可能就是周六周日和同学一起去北京参加 开源社的开源年会吧！说走就走的旅程真的很帅！遇见了&lt;&#x2F;p&gt;
&lt;p&gt;伊洪老师等优秀的人！&lt;&#x2F;p&gt;
&lt;p&gt;-人不出去走走，真的被困在这个小世界中&lt;&#x2F;p&gt;
&lt;p&gt;还创建了自己的博客，记录自己的生活，学习&lt;&#x2F;p&gt;
&lt;p&gt;在此期间遇见了一些帮助我的老哥老姐们！互联网真的有一些素未谋面的人会去帮助你，他们不求什么！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;短短几段文字，是我尽可能串联起我的大学的这段日子，还有很多，没有必要全部列出来，只是在12.27日的今天，我想回忆一下我的过去，尽管他没有意义！时间过得很快，你想自己成为什么呢？你可以没有目的的向前走！中途的风景都是你人生中绚烂的一笔！&lt;&#x2F;p&gt;
&lt;p&gt;-感谢我遇见的所有人！&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title> C++ Learning</title>
          <pubDate>Wed, 28 May 2025 11:35:20 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-2/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-2/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-2/">&lt;p&gt;给定 CPU 可以理解的所有可能的机器语言指令的集合称为&lt;strong&gt;指令集&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;每条指令被 CPU 理解为执行非常具体工作的命令，&lt;&#x2F;p&gt;
&lt;p&gt;例如： &lt;em&gt;“比较这两个数字”或“将此数字复制到该内存位置”。在计算机刚发明时，程序员必须直接用机器语&lt;&#x2F;em&gt;
&lt;em&gt;言编写程序，这是一件非常困难且耗时的事情。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;每个 CPU 系列都有自己的机器语言一样，每个 CPU 系列也有自己的汇编语言（旨在为同一 CPU 系列组装成机器语言）。这意味着有许多不同的汇编语言。尽管在概念上相似，但不同的汇编语言支持不同的指令，使用不同的命名约定，等等......&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;fd21e869-6449-4758-b435-1cd1ff5b4e71&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-qian-zou&quot;&gt;一 . 前奏&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;di-1-bu-ding-yi-nin-yao-jie-jue-de-wen-ti&quot;&gt;第 1 步：定义您要解决的问题&lt;&#x2F;h3&gt;
&lt;p&gt;这是 “what” 步骤，您可以在其中弄清楚您打算解决的问题。想出你想要编程的初步想法可能是最简单的步骤，也可能是最困难的一步。但从概念上讲，这是最简单的。您所需要的只是一个可以明确定义的想法，然后您就可以为下一步做好准备。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;“我想编写一个程序，让我输入许多数字，然后计算平均值。”
“我想编写一个程序来生成一个 2D 迷宫并让用户在其中导航。如果用户到达终点，他们就会获胜。
“我想编写一个程序，该程序读取股票价格文件并预测股票是上涨还是下跌。”
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;di-2-bu-que-ding-nin-jiang-ru-he-jie-jue-wen-ti&quot;&gt;第 2 步：确定您将如何解决问题&lt;&#x2F;h3&gt;
&lt;p&gt;这是 “如何” 步骤，您可以在其中确定如何解决在步骤 1 中提出的问题。这也是软件开发中最容易被忽视的步骤。问题的症结在于解决问题的方法有很多种 —— 但是，其中一些解决方案是好的，而另一些是坏的。很多时候，程序员会得到一个想法，坐下来，然后立即开始编写解决方案。这通常会产生一个属于 bad 类别的解决方案。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;好的解决方法的特性：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt; 它们很简单（不会过于复杂或令人困惑）。
 它们有据可查（尤其是围绕所做的任何假设或限制）。
 它们是模块化构建的，因此部分可以重复使用或稍后更改，而不会影响程序的其他部分。
 它们可以正常恢复或在发生意外情况时提供有用的错误消息。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;di-san-bu-bian-xie-cheng-xu&quot;&gt;第三步：编写程序&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;di-si-bu-bian-yi-yuan-dai-ma&quot;&gt;第四步： 编译源代码&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;为了编译 C++ 源代码文件，我们使用 C++ 编译器。C++ 编译器按顺序遍历程序中的每个源代码 （.cpp） 文件，并执行两项重要任务&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，编译器检查您的 C++ 代码，以确保它遵循 C++ 语言的规则。如果没有，编译器将为您提供错误（和相应的行号）以帮助确定需要修复的内容。编译过程也将中止，直到错误得到修复。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;其次，编译器将您的 C++ 代码转换为机器语言指令。这些指令存储在称为&lt;strong&gt;对象文件的&lt;&#x2F;strong&gt;中间文件中。对象文件还包含后续步骤中需要或有用的其他数据（包括步骤 5 中链接器所需的数据，以及步骤 7 中用于调试的数据）。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;如果您的程序有 3 个 .cpp 文件，则编译器将生成 3 个目标文件&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-5-bu-lian-jie-dui-xiang-wen-jian-he-ku-bing-chuang-jian-suo-xu-de-shu-chu-wen-jian&quot;&gt;第 5 步：链接对象文件和库并创建所需的输出文件&lt;&#x2F;h3&gt;
&lt;p&gt;编译器成功完成后，另一个称为&lt;strong&gt;链接器&lt;&#x2F;strong&gt;的程序将启动。链接器的工作是合并所有目标文件并生成所需的输出文件 此过程称为&lt;strong&gt;链接&lt;&#x2F;strong&gt; 如果链接过程中的任何步骤失败，链接器将生成一条描述问题的错误消息，然后中止。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，链接器读取编译器生成的每个目标文件，并确保它们有效。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;其次，链接器确保所有跨文件依赖项都得到正确解析。例如，如果您在一个 .cpp 文件中定义某些内容，然后在不同的 .cpp 文件中使用它，则链接器会将两者连接在一起。如果链接器无法将引用连接到具有其定义的内容，则会收到链接器错误，并且链接过程将中止。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;第三，链接器通常在一个或多个&lt;strong&gt;库文件中&lt;&#x2F;strong&gt;链接，这些文件是预编译代码的集合，这些文件已被“打包”以供其他程序重用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;最后，链接器输出所需的输出文件。通常，这将是一个可以启动的可执行文件&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;示例：&lt;&#x2F;p&gt;
&lt;p&gt;你调用了 &lt;code&gt;fmt.Println()&lt;&#x2F;code&gt;，这个函数并不在你的代码里，而是来自 Go 的标准库 &lt;code&gt;fmt&lt;&#x2F;code&gt;，Go 编译器会把你用到的 &lt;code&gt;fmt&lt;&#x2F;code&gt; 里的代码从&lt;strong&gt;库文件&lt;&#x2F;strong&gt;中找出来，并&lt;strong&gt;链接&lt;&#x2F;strong&gt;进最终的可执行程序里&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;363b6da6-8b78-4443-8ce5-699019703182&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bu-zou-6-7-ce-shi-he-diao-shi&quot;&gt;步骤6 &amp;amp; 7：测试和调试&lt;&#x2F;h3&gt;
&lt;p&gt;一旦你可以运行你的程序，你就可以测试它。 &lt;strong&gt;测试&lt;&#x2F;strong&gt;是评估您的软件是否按预期工作的过程。基本测试通常涉及尝试不同的输入组合，以确保软件在不同情况下正常运行。&lt;&#x2F;p&gt;
&lt;p&gt;如果程序没有按预期运行，那么您将不得不进行一些&lt;strong&gt;调试&lt;&#x2F;strong&gt; ，这是查找和修复编程错误的过程。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;er-pei-zhi-bian-yi-qi&quot;&gt;二. 配置编译器&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;84018bf1-b618-4406-8a38-e4266b1b2a5a&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;显示出必要的警告，有些警告非常有用，并且在必要时需要解决&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-liao-jie-hello-world&quot;&gt;三. 了解Hello World！&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;C&quot; class=&quot;language-C &quot;&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
	std::cout &amp;lt;&amp;lt; &amp;quot;Hello world!&amp;quot;;
	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第 1 行是一种特殊类型的行，称为预处理器指令。此 &lt;code&gt;#include&lt;&#x2F;code&gt; 预处理器指令表示我们希望使用 &lt;code&gt;iostream&lt;&#x2F;code&gt; 库的内容，该库是 C++ 标准库的一部分，允许我们从控制台读取和写入文本。我们需要这一行，以便在第 5 行使用 &lt;code&gt;std：：cout&lt;&#x2F;code&gt;。排除此行将导致第 5 行出现编译错误，否则编译器将不知道 &lt;code&gt;std：：cout&lt;&#x2F;code&gt; 是什么。&lt;&#x2F;p&gt;
&lt;p&gt;第 2 行为空，编译器将忽略该行。此行的存在只是为了帮助使程序对人类更具可读性（通过将 &lt;code&gt;#include&lt;&#x2F;code&gt; preprocessor 指令和程序的后续部分分开）。&lt;&#x2F;p&gt;
&lt;p&gt;第 3 行告诉编译器，我们将编写（定义）一个名称（标识符）为 &lt;code&gt;main&lt;&#x2F;code&gt; 的函数。正如您在上面所学到的，每个 C++ 程序都必须有一个 &lt;code&gt;main&lt;&#x2F;code&gt; 函数，否则将无法链接。此函数将生成一个类型为 &lt;code&gt;int&lt;&#x2F;code&gt; （整数） 的值&lt;&#x2F;p&gt;
&lt;p&gt;第 4 行和第 7 行告诉编译器哪些行是 &lt;em&gt;main&lt;&#x2F;em&gt; 函数的一部分。第 4 行的左大括号和第 7 行的右大括号之间的所有内容都被视为 &lt;code&gt;main&lt;&#x2F;code&gt; 函数的一部分。这称为函数体。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;问题： 程序运行时会发生什么？&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;main（）&lt;&#x2F;code&gt; 中的语句按顺序执行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;si-zhu-shi&quot;&gt;四. 注释&lt;&#x2F;h2&gt;
&lt;p&gt;在 C++ 中，有两种不同样式的注释，它们都有相同的目的：帮助程序员以某种方式记录代码。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;单行注释开头
该注释指示编译器忽略从该符号到行尾的所有内容，单行注释用于对单行代码进行快速注释。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;std::cout &amp;lt;&amp;lt; &amp;quot;Hello world!\n&amp;quot;;                 &amp;#x2F;&amp;#x2F; std::cout lives in the iostream library
std::cout &amp;lt;&amp;lt; &amp;quot;It is very nice to meet you!\n&amp;quot;; &amp;#x2F;&amp;#x2F; this is much easier to read
std::cout &amp;lt;&amp;lt; &amp;quot;Yeah!\n&amp;quot;;                        &amp;#x2F;&amp;#x2F; don&amp;#x27;t you think so?
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;多行注释&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;&#x2F;*&lt;&#x2F;code&gt; 和 &lt;code&gt;*&#x2F;&lt;&#x2F;code&gt; 对符号表示 C 样式的多行注释。符号之间的所有内容都将被忽&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;正确使用注释&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;通常，注释应该用于三件事。首先，对于给定的库、程序或函数，注释最适合_用于描述库_ 、程序或函数的作用。这些通常位于文件或库的顶部，或紧靠在函数之前。例如&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;所有这些注释都使读者可以很好地了解库、程序或函数试图完成什么，而不必查看实际代码&lt;&#x2F;em&gt;。用户（可能是其他人，或者如果您尝试重用以前编写的代码，则可能是您）可以&lt;em&gt;一目了然地判断代码是否与他或她要完成的任务相关&lt;&#x2F;em&gt;。这在作为&lt;em&gt;团队的一部分&lt;&#x2F;em&gt;工作时尤其重要，因为不&lt;em&gt;是每个人都熟悉所有代码&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在语句级别，应该使用注释来描述代码执行某项作_的原因_ 。错误的 statement _注释解释了代码_正在做什么。如果您编写的代码非常复杂，以至于需要一个注释_来解释语句_的作用，则可能需要重写您的语句，而不是注释它。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;“好代码说明‘做什么’，好注释说明‘为什么’。”&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wu-zhi&quot;&gt;五. 值&lt;&#x2F;h2&gt;
&lt;p&gt;对值最常见的作之一是将它们&lt;em&gt;打印到屏幕&lt;&#x2F;em&gt;上&lt;&#x2F;p&gt;
&lt;p&gt;计算机中的主内存称为&lt;strong&gt;随机存取存储器&lt;&#x2F;strong&gt; （通常简称 &lt;strong&gt;RAM&lt;&#x2F;strong&gt;）。当我们运行一个程序时，作系统会将程序加载到 RAM 中。此时&lt;em&gt;将加载硬编码到程序本身中的任何数据&lt;&#x2F;em&gt;（例如，诸如 “Hello， world！” 之类的文本）。&lt;&#x2F;p&gt;
&lt;p&gt;系统还保留了一些额外的 RAM 供程序在运行时使用。此内存的常见用途是存储用户输入的值，存储从文件或网络读取的数据，或存储程序运行时计算的值（例如两个值的总和），以便以后可以再次使用。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;文本是只读值，因此无法修改其值。因此，如果我们想在内存中存储数据，我们需要其他方法来做到这一点&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;char *s = &amp;quot;hello&amp;quot;;   &amp;#x2F;&amp;#x2F; 指向字符串常量，不能修改
s[0] = &amp;#x27;H&amp;#x27;;          &amp;#x2F;&amp;#x2F; ❌ 未定义行为，可能崩溃
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;char s[] = &amp;quot;hello&amp;quot;;  &amp;#x2F;&amp;#x2F; 拷贝到数组，位于可写内存中
s[0] = &amp;#x27;H&amp;#x27;;          &amp;#x2F;&amp;#x2F; ✅ 可以修改
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Go中&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;b := []byte(&amp;quot;hello&amp;quot;)
b[0] = &amp;#x27;H&amp;#x27;           &amp;#x2F;&amp;#x2F; ✅ 可以修改
s2 := string(b)
fmt.Println(s2)      &amp;#x2F;&amp;#x2F; 输出 &amp;quot;Hello&amp;quot;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;liu-dui-xiang-he-bian-liang&quot;&gt;六. 对象和变量&lt;&#x2F;h2&gt;
&lt;p&gt;在 C++ 中，不建议直接访问内存。相反，我们通过对象间接访问内存。 &lt;strong&gt;对象&lt;&#x2F;strong&gt;表示可以保存值的存储区域（通常是 RAM 或 CPU 寄存器）。对象还具有关联的属性&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int x; &amp;#x2F;&amp;#x2F; define a variable named x (of type int)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译器为我们处理有关此变量的所有其他细节，包括确定对象需要多少内存、对象将放置在哪种存储中（例如在 RAM 或 CPU 寄存器中）、它相对于其他对象的放置位置、何时创建和销毁它等&lt;&#x2F;p&gt;
&lt;p&gt;执行从 &lt;code&gt;main（）&lt;&#x2F;code&gt; 的顶部开始。为 &lt;code&gt;x&lt;&#x2F;code&gt; 分配内存。然后程序结束。&lt;&#x2F;p&gt;
&lt;p&gt;什么是对象？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;An object is a region of storage (usually memory) that can store a value.&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;什么是变量&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;A variable is an object that has a name.&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;什么是数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;A value is a letter (e.g. &lt;&#x2F;code&gt;a&lt;code&gt;), number (e.g. &lt;&#x2F;code&gt;5&lt;code&gt;), text (e.g. &lt;&#x2F;code&gt;Hello&lt;code&gt;), or instance of some other useful concept that can be represented as data.&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-bian-liang-fu-zhi-he-chu-shi-hua&quot;&gt;七. 变量赋值和初始化&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;分配变量&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int main()
{
    int x;    &amp;#x2F;&amp;#x2F; define an integer variable named x (preferred)
    int y, z; &amp;#x2F;&amp;#x2F; define two integer variables, named y and z

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;赋值&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int width; &amp;#x2F;&amp;#x2F; define an integer variable named width
width = 5; &amp;#x2F;&amp;#x2F; assignment of value 5 into variable width

&amp;#x2F;&amp;#x2F; variable width now has value 5
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这被称为&lt;strong&gt;复制分配&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一旦为变量指定了值，就可以通过 &lt;code&gt;std：：cout&lt;&#x2F;code&gt; 和 &lt;code&gt;&amp;lt;&amp;lt;&lt;&#x2F;code&gt; 运算符打印该变量的值&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;C++ 中有 5 种常见的初始化形式：&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a;         &amp;#x2F;&amp;#x2F; default-initialization (no initializer)

&amp;#x2F;&amp;#x2F; Traditional initialization forms:
int b = 5;     &amp;#x2F;&amp;#x2F; copy-initialization (initial value after equals sign)
int c ( 6 );   &amp;#x2F;&amp;#x2F; direct-initialization (initial value in parenthesis)

&amp;#x2F;&amp;#x2F; Modern initialization forms (preferred):
int d { 7 };   &amp;#x2F;&amp;#x2F; direct-list-initialization (initial value in braces)
int e {};      &amp;#x2F;&amp;#x2F; value-initialization (empty braces)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;写法&lt;&#x2F;th&gt;&lt;th&gt;名称&lt;&#x2F;th&gt;&lt;th&gt;值&lt;&#x2F;th&gt;&lt;th&gt;特点&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int a;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;默认初始化&lt;&#x2F;td&gt;&lt;td&gt;未定义&lt;&#x2F;td&gt;&lt;td&gt;不安全，局部变量是垃圾值&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int b = 5;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;复制初始化&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;支持隐式转换&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int c(6);&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;直接初始化&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;类似函数调用&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int d{7};&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;直接列表初始化 ✅推荐&lt;&#x2F;td&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;安全，防止隐式类型转换&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int e{};&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;值初始化 ✅推荐&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;初始化为零&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct MyClass {
    MyClass(int x) { ... }          &amp;#x2F;&amp;#x2F; 构造函数
    MyClass(const MyClass&amp;amp; other) { ... } &amp;#x2F;&amp;#x2F; 拷贝构造函数
};

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;MyClass a = 5;   &amp;#x2F;&amp;#x2F; copy-initialization（可能调用拷贝构造函数）
MyClass b(5);    &amp;#x2F;&amp;#x2F; direct-initialization（直接调用构造函数）
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;旧的编译器可能会让 &lt;code&gt;a = 5&lt;&#x2F;code&gt; 先调用构造函数再调用拷贝构造函数，多一步；&lt;br &#x2F;&gt;
但 &lt;strong&gt;现代编译器（尤其 C++17 后）会优化掉这一步&lt;&#x2F;strong&gt;，效果基本一样。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;写法&lt;&#x2F;th&gt;&lt;th&gt;是否推荐&lt;&#x2F;th&gt;&lt;th&gt;备注&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;MyClass a = x;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;✅ C++17 后可以放心用&lt;&#x2F;td&gt;&lt;td&gt;语法清晰&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;MyClass a(x);&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;✅ 更偏向现代风格&lt;&#x2F;td&gt;&lt;td&gt;少见歧义&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;MyClass a{x};&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;✅ 最安全，禁止隐式转换&lt;&#x2F;td&gt;&lt;td&gt;推荐用于新项目&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;&lt;strong&gt;问题 : When should I initialize with { 0 } vs {}?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct Foo {
    Foo() : v(42) {}
    int v;
};

Foo f1{};   &amp;#x2F;&amp;#x2F; ✅ 调用默认构造，v = 42
Foo f2{0};  &amp;#x2F;&amp;#x2F; ❌ 编译错误：找不到接受 int 的构造函数

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们还注意到，最佳做法是完全避免这种语法。但是，由于您可能会遇到使用此样式的其他代码，因此多讨论一下它仍然很有用，如果不是其他原因，只是为了强调您应该避免使用它的一些原因。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a = 5, b = 6;          &amp;#x2F;&amp;#x2F; copy-initialization
int c ( 7 ), d ( 8 );      &amp;#x2F;&amp;#x2F; direct-initialization
int e { 9 }, f { 10 };     &amp;#x2F;&amp;#x2F; direct-list-initialization
int i {}, j {};            &amp;#x2F;&amp;#x2F; value-initialization
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a, b = 5;     &amp;#x2F;&amp;#x2F; wrong: a is not initialized to 5!
int a = 5, b = 5; &amp;#x2F;&amp;#x2F; correct: a and b are initialized to 5
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    [[maybe_unused]] double pi { 3.14159 };  &amp;#x2F;&amp;#x2F; Don&amp;#x27;t complain if pi is unused
    [[maybe_unused]] double gravity { 9.8 }; &amp;#x2F;&amp;#x2F; Don&amp;#x27;t complain if gravity is unused
    [[maybe_unused]] double phi { 1.61803 }; &amp;#x2F;&amp;#x2F; Don&amp;#x27;t complain if phi is unused

    std::cout &amp;lt;&amp;lt; pi &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    std::cout &amp;lt;&amp;lt; phi &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    &amp;#x2F;&amp;#x2F; The compiler will no longer warn about gravity not being used

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;[[maybe_unused]]  可以接受编译而没有被使用的变量&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Prefer `\n` over `std::endl` when outputting text to the console.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;缓冲区&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;std::cin&lt;&#x2F;code&gt; 使用的是&lt;strong&gt;输入缓冲区&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当你输入内容后，&lt;strong&gt;按下回车&lt;&#x2F;strong&gt;，整个一行文本会被放入缓冲区中；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::cin&lt;&#x2F;code&gt; 会从这个缓冲区中逐个提取数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;使用未初始化变量&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void doNothing(int&amp;amp;) &amp;#x2F;&amp;#x2F; Don&amp;#x27;t worry about what &amp;amp; is for now, we&amp;#x27;re just using it to trick the compiler into thinking variable x is used
{
}

int main()
{
    &amp;#x2F;&amp;#x2F; define an integer variable named x
    int x; &amp;#x2F;&amp;#x2F; this variable is uninitialized

    doNothing(x); &amp;#x2F;&amp;#x2F; make the compiler think we&amp;#x27;re assigning a value to this variable

    &amp;#x2F;&amp;#x2F; print the value of x to the screen (who knows what we&amp;#x27;ll get, because x is uninitialized)
    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ba-biao-shi-fu-ming-ming-zui-jia-shi-jian&quot;&gt;八：标识符命名最佳实践&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int value; &amp;#x2F;&amp;#x2F; conventional

int Value; &amp;#x2F;&amp;#x2F; unconventional (should start with lower case letter)
int VALUE; &amp;#x2F;&amp;#x2F; unconventional (should start with lower case letter and be in all lower case)
int VaLuE; &amp;#x2F;&amp;#x2F; unconventional (see your psychiatrist) ;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int my_variable_name;   &amp;#x2F;&amp;#x2F; conventional (separated by underscores&amp;#x2F;snake_case)
int my_function_name(); &amp;#x2F;&amp;#x2F; conventional (separated by underscores&amp;#x2F;snake_case)

int myVariableName;     &amp;#x2F;&amp;#x2F; conventional (intercapped&amp;#x2F;camelCase)
int myFunctionName();   &amp;#x2F;&amp;#x2F; conventional (intercapped&amp;#x2F;camelCase)

int my variable name;   &amp;#x2F;&amp;#x2F; invalid (whitespace not allowed)
int my function name(); &amp;#x2F;&amp;#x2F; invalid (whitespace not allowed)

int MyVariableName;     &amp;#x2F;&amp;#x2F; unconventional (should start with lower case letter)
int MyFunctionName();   &amp;#x2F;&amp;#x2F; unconventional (should start with lower case letter)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;避免使用缩写，除非它们是常见且明确的&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jiu-wen-zi-he-yun-suan-fu&quot;&gt;九： 文字和运算符&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; 5 &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; print the value of a literal

    int x{ 5 };
    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; print the value of a variable
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;直接打印 值 和 变量的区别&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因此，两个 output 语句执行相同的作（打印值 5）。但是对于 Literals，可以直接打印值 &lt;code&gt;5&lt;&#x2F;code&gt;。对于变量，必须从&lt;em&gt;变量表示的内存中获取值&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这也解释了为什么 Literals 是 constant，而 variable 可以更改。文本的值直接放置在可执行文件中，可执行文件本身在创建后无法更改。变量的值被放置在内存中，&lt;em&gt;并且可以在可执行文件运行时更改 memory 的值。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;文本值无法更改！！！！&lt;&#x2F;p&gt;
&lt;p&gt;变量值可以在后续被其它执行代码更改！！！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;di-yi-ge-xiang-mu&quot;&gt;*第一个项目&lt;&#x2F;h2&gt;
&lt;p&gt;返回输入数字的二倍&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

&amp;#x2F;&amp;#x2F; worst version
int main()
{
	std::cout &amp;lt;&amp;lt; &amp;quot;Enter an integer: &amp;quot;;

	int num{ };
	std::cin &amp;gt;&amp;gt; num;

	num = num * 2; &amp;#x2F;&amp;#x2F; double num&amp;#x27;s value, then assign that value back to num

	std::cout &amp;lt;&amp;lt; &amp;quot;Double that number is: &amp;quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为什么这是不好的！&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;丢失了原始输入，无法重用&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;比如你想再做一步 &lt;code&gt;num * 3&lt;&#x2F;code&gt;，但这时候 &lt;code&gt;num&lt;&#x2F;code&gt; 早就不是用户输入了，是翻倍后的；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原始输入已经被覆盖，无法再用&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;2.变量含义“变了”，容易让人困惑&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原来 &lt;code&gt;num&lt;&#x2F;code&gt; 表示“用户输入的值”；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;后来 &lt;code&gt;num&lt;&#x2F;code&gt; 被改成了 “输入值 × 2”；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同一个变量&lt;&#x2F;strong&gt;，含义却在中途改变 → 看代码的人容易糊涂。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bian-cheng-si-xiang&quot;&gt;*编程思想&lt;&#x2F;h2&gt;
&lt;p&gt;编程的首要目标是使您的程序正常工作。一个不工作的程序，无论它写得有多好，都是没有用的。&lt;&#x2F;p&gt;
&lt;p&gt;但是，我喜欢一句话：“你必须写一次程序，才能知道你第一次应该怎么写它。这说明了这样一个事实，即最佳解决方案通常并不明显，而且我们对问题的第一个解决方案通常没有应有的那么好。&lt;&#x2F;p&gt;
&lt;p&gt;当我们专注于弄清楚如何使我们的程序工作时，将大量时间投入到我们甚至不知道我们是否会保留的代码上没有多大意义。所以我们走捷径。我们跳过了错误处理和注释等内容。我们在整个解决方案中散布调试代码，以帮助我们诊断问题和查找错误。我们边走边学 -- 我们认为可能有效的事情终究是行不通的，我们不得不回头尝试另一种方法。&lt;&#x2F;p&gt;
&lt;p&gt;最终结果是，我们的初始解决方案通常结构不合理、健壮（防错）、可读性或简洁性。因此，一旦您的程序开始工作，您的工作就真的没有完成（除非该程序是一次性的&#x2F;一次性的）。下一步是清理代码。这包括以下内容：删除 （或注释掉） 临时&#x2F;调试代码、添加注释、处理错误情况、格式化代码以及确保遵循最佳实践。即使这样，您的程序也可能没有想象中那么简单 —— 也许有可以合并的冗余逻辑，或者可以组合的多个语句，或者不需要的变量，或者可以简化的一千个其他小事情。很多时候，新程序员专注于优化性能，而他们应该优化可维护性。&lt;&#x2F;p&gt;
&lt;p&gt;这些教程中介绍的解决方案很少在第一次就表现出色。相反，它们是不断完善的结果，直到找不到其他可以改进的地方。在许多情况下，读者仍然可以找到许多其他改进建议！&lt;&#x2F;p&gt;
&lt;p&gt;所有这一切实际上是在说：如果&#x2F;当您的解决方案没有从您的大脑中得到出色的优化时，请不要感到沮丧。这很正常。完美的编程是一个迭代过程（需要重复的过程）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;写代码是先求能跑，再求好；想写出好代码，必须接受写烂再改的过程。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-chu-shi-hua-he-fu-zhi-de-qu-bie&quot;&gt;问题： 初始化和赋值的区别&lt;&#x2F;h4&gt;
&lt;p&gt;Initialization 为变量提供初始值（在创建时）。赋值 在定义变量后为变量提供新值&lt;&#x2F;p&gt;
&lt;p&gt;由于变量只创建一次，因此只能初始化一次。可以根据需要多次为变量分配值。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wen-ti-wei-ding-yi-de-xing-wei-shen-me-hou-guo&quot;&gt;问题：未定义的行为？什么后果？&lt;&#x2F;h4&gt;
&lt;p&gt;当程序员执行 C++ 语言未指定的内容时，将发生未定义的行为。后果几乎是任何东西，从崩溃到产生错误的答案，再到无论如何都能正常工作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-han-shu&quot;&gt;一. 函数&lt;&#x2F;h2&gt;
&lt;p&gt;您已经知道每个可执行程序都必须有一个名为 &lt;code&gt;main（）&lt;&#x2F;code&gt; 的函数（这是程序运行时开始执行的位置）。然而，随着程序开始变得越来越长，将所有代码放在 &lt;code&gt;main（）&lt;&#x2F;code&gt; 函数中变得越来越难以管理。函数为我们提供了一种将程序拆分为小的、模块化的块的方法，这些块更易于组织、测试和使用。大多数程序使用许多功能。C++ 标准库附带了大量已编写的函数供您使用 - 但是，编写自己的函数也同样常见。您自己编写的函数称为&lt;strong&gt;用户定义的函数&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;C++ 程序可以以相同的方式工作（并借用一些相同的命名法）。当程序遇到函数调用时，它将在一个函数中按顺序执行语句。 &lt;strong&gt;函数调用&lt;&#x2F;strong&gt;告诉 CPU 中断当前函数并执行另一个函数。CPU 实质上是在当前执行点 “放置书签”，执行函数调用中指定的函数，然后&lt;strong&gt;返回到&lt;&#x2F;strong&gt;它添加书签的点并继续执行。&lt;&#x2F;p&gt;
&lt;p&gt;发起函数调用的函数是&lt;strong&gt;调用方&lt;&#x2F;strong&gt; ，被&lt;strong&gt;调用&lt;&#x2F;strong&gt; （执行）的函数是&lt;strong&gt;被调用方&lt;&#x2F;strong&gt; 。函数调用有时也称为&lt;strong&gt;调用&lt;&#x2F;strong&gt; ，调用方&lt;strong&gt;调用&lt;&#x2F;strong&gt;被调用方。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt; &amp;#x2F;&amp;#x2F; for std::cout

void doB()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;In doB()\n&amp;quot;;
}


void doA()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Starting doA()\n&amp;quot;;

    doB();

    std::cout &amp;lt;&amp;lt; &amp;quot;Ending doA()\n&amp;quot;;
}

&amp;#x2F;&amp;#x2F; Definition of function main()
int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Starting main()\n&amp;quot;;

    doA();

    std::cout &amp;lt;&amp;lt; &amp;quot;Ending main()\n&amp;quot;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一层层封装 进入弹出&lt;&#x2F;p&gt;
&lt;h2 id=&quot;er-ju-bu-xing&quot;&gt;二. 局部性&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int add(int x, int y) &amp;#x2F;&amp;#x2F; x and y created and initialized here
{
    int z{ x + y };   &amp;#x2F;&amp;#x2F; z created and initialized here

    return z;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;就像一个人的一生被定义为他们出生和死亡之间的时间一样，一个物体的&lt;strong&gt;一生&lt;&#x2F;strong&gt;被定义为其被创造和毁灭之间的时间。请注意，&lt;em&gt;变量创建和销毁发生在程序运行时（称为运行时），而不是在编译时。因此，lifetime 是一个运行时属性。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void doSomething()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello!\n&amp;quot;;
}

int main()
{
    int x{ 0 };    &amp;#x2F;&amp;#x2F; x&amp;#x27;s lifetime begins here

    doSomething(); &amp;#x2F;&amp;#x2F; x is still alive during this function call

    return 0;
} &amp;#x2F;&amp;#x2F; x&amp;#x27;s lifetime ends here
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在上面的程序中，&lt;code&gt;x&lt;&#x2F;code&gt; 的生命周期从定义点到函数 &lt;code&gt;main&lt;&#x2F;code&gt; 的末尾。这包括执行函数 &lt;code&gt;doSomething&lt;&#x2F;code&gt; 期间所花费的时间。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;销毁的对象将变为无效。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在对象被销毁后，对对象的任何使用都将导致未定义的行为。  &lt;strong&gt;在销毁后的某个时间点，对象使用的内存将被释放 （释放以供重用）。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;局部变量的生命周期在它超出范围时结束，因此局部变量在此时被销毁。 &lt;em&gt;请注意，并非所有类型的变量在超出范围时都会被销毁&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&quot;One Task&quot;&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-ming-ming-chong-tu&quot;&gt;三. 命名冲突&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;a.cpp&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void myFcn(int x)
{
    std::cout &amp;lt;&amp;lt; x;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;main.cpp&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void myFcn(int x)
{
    std::cout &amp;lt;&amp;lt; 2 * x;
}

int main()
{
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每个文件按编译的时候 不会出现问题但是 当链接器执行时，它会将 &lt;em&gt;a.cpp&lt;&#x2F;em&gt; 和 &lt;em&gt;main.cpp&lt;&#x2F;em&gt; 中的所有定义链接在一起，并发现函数 &lt;code&gt;myFcn（）&lt;&#x2F;code&gt; 的冲突定义。然后，链接器将中止并显示错误。请注意，即使从未调用 &lt;code&gt;myFcn（），&lt;&#x2F;code&gt; 也会发生此错误！&lt;&#x2F;p&gt;
&lt;p&gt;在给定的范围区域内，所有标识符都必须是唯一的，否则将导致命名冲突。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;si-ming-ming-kong-jian&quot;&gt;四. 命名空间&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;命名空间&lt;&#x2F;strong&gt;提供了另一种类型的范围区域（称为&lt;strong&gt;命名空间范围&lt;&#x2F;strong&gt; ），它允许您在其中声明或定义名称以消除歧义。在命名空间中声明的名称与其他范围内声明的名称隔离，从而允许此类名称存在而不会发生冲突。&lt;&#x2F;p&gt;
&lt;p&gt;在 C++ 中，未在类、函数或命名空间中定义的任何名称都被视为隐式定义的命名空间的一部分，该命名空间称为&lt;strong&gt;全局命名空间&lt;&#x2F;strong&gt; （有时也称为&lt;strong&gt;全局范围&lt;&#x2F;strong&gt; ）。&lt;&#x2F;p&gt;
&lt;p&gt;例如，可以在不同的命名空间内定义两个具有相同声明的函数，并且不会发生命名冲突或歧义。&lt;&#x2F;p&gt;
&lt;p&gt;命名空间只能包含声明和定义。可执行语句仅允许作为定义的一部分（例如函数的一部分）。&lt;&#x2F;p&gt;
&lt;p&gt;命名空间通常用于对大型项目中的相关标识符进行分组，以帮助确保它们不会无意中与其他标识符发生冲突。&lt;em&gt;例如，如果你把所有的数学函数都放在一个名为 &lt;code&gt;math&lt;&#x2F;code&gt; 的命名空间中，那么你的数学函数不会与 &lt;code&gt;math&lt;&#x2F;code&gt; 命名空间外的同名函数发生冲突。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局命名空间&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;函数 &lt;code&gt;main（）&lt;&#x2F;code&gt; 和 &lt;code&gt;myFcn（）&lt;&#x2F;code&gt; 的两个版本都是在全局命名空间内定义的。示例中遇到的命名冲突是因为 &lt;code&gt;myFcn（）&lt;&#x2F;code&gt; 的两个版本最终都位于全局命名空间内*，这违反了范围区域中的所有名称都必须唯一的规则*&lt;&#x2F;p&gt;
&lt;p&gt;尽管可以在全局命名空间中定义变量，但通常应该避免这种情况&lt;&#x2F;p&gt;
&lt;p&gt;事实证明，&lt;code&gt;std：：cout&lt;&#x2F;code&gt; 的名字并不是真正的 &lt;code&gt;std：：cout&lt;&#x2F;code&gt;。它实际上只是 &lt;code&gt;cout&lt;&#x2F;code&gt;， &lt;code&gt;而 std&lt;&#x2F;code&gt; 是标识符 &lt;code&gt;cout&lt;&#x2F;code&gt; 所属的命名空间的名称。因为 &lt;code&gt;cout&lt;&#x2F;code&gt; 是在 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间中定义的，所以名称 &lt;code&gt;cout&lt;&#x2F;code&gt; 不会与我们在 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间之外创建的任何名为 &lt;code&gt;cout&lt;&#x2F;code&gt; 的对象或函数冲突（例如在全局命名空间中）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;当您使用在非全局命名空间（例如 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间）中定义的标识符时，您需要告诉编译器该标识符位于命名空间内。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;显式命名空间限定符 std：：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;告诉编译器我们想使用 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间中的 &lt;code&gt;cout&lt;&#x2F;code&gt; 的最直接方法是显式使用 &lt;code&gt;std：：&lt;&#x2F;code&gt; 前缀&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello world!&amp;quot;; &amp;#x2F;&amp;#x2F; when we say cout, we mean the cout defined in the std namespace
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;访问命名空间内标识符的另一种方法是使用 using 指令语句。这是我们的原始 “Hello world” 程序，带有 using 指令：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std; &amp;#x2F;&amp;#x2F; this is a using-directive that allows us to access names in the std namespace with no namespace prefix

int main()
{
    cout &amp;lt;&amp;lt; &amp;quot;Hello world!&amp;quot;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;using 指令&lt;&#x2F;strong&gt;允许我们在不使用命名空间前缀的情况下访问命名空间中的名称。所以在上面的例子中，当编译器去确定标识符 &lt;code&gt;cout&lt;&#x2F;code&gt; 是什么时，它将与 &lt;code&gt;std：：cout&lt;&#x2F;code&gt; 匹配，由于 using 指令，它只能作为 &lt;code&gt;cout&lt;&#x2F;code&gt; 访问。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;why&quot;&gt;Why?&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt; &amp;#x2F;&amp;#x2F; imports the declaration of std::cout into the global scope

using namespace std; &amp;#x2F;&amp;#x2F; makes std::cout accessible as &amp;quot;cout&amp;quot;

int cout() &amp;#x2F;&amp;#x2F; defines our own &amp;quot;cout&amp;quot; function in the global namespace
{
    return 5;
}

int main()
{
    cout &amp;lt;&amp;lt; &amp;quot;Hello, world!&amp;quot;; &amp;#x2F;&amp;#x2F; Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的程序没有编译，因为编译器现在无法判断我们想要的是定义的 &lt;code&gt;cout&lt;&#x2F;code&gt; 函数，还是 &lt;code&gt;std：：cout&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以这种方式使用 using 指令时，我们定义_的任何_标识符_都可能与_ &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间中的任何同名标识符冲突&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;using namespace std;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我接下来代码中要用 std 命名空间里的所有东西，不用再加 std:: 前缀了”&lt;&#x2F;p&gt;
&lt;p&gt;等价&lt;code&gt;std::cout&lt;&#x2F;code&gt; → &lt;code&gt;cout&lt;&#x2F;code&gt;，&lt;code&gt;std::cin&lt;&#x2F;code&gt; → &lt;code&gt;cin&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt; &amp;#x2F;&amp;#x2F; imports the declaration of std::cout into the global scope

using namespace std; &amp;#x2F;&amp;#x2F; makes std::cout accessible as &amp;quot;cout&amp;quot;



class  mm
{
public:
	 mm();
	~ mm();
    int cout();

private:
};

int mm::cout() {
    return 5;
}

 mm:: mm()
{
}

 mm::~ mm()
{
}

int main()
{
    class mm  a;
    a.cout(); &amp;#x2F;&amp;#x2F; Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?
    cout &amp;lt;&amp;lt; &amp;quot;11111111&amp;quot;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大体是这个意思&lt;&#x2F;p&gt;
&lt;h3 id=&quot;suo-jin&quot;&gt;缩进&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;iostream&amp;gt;   &amp;#x2F;&amp;#x2F; 在全局作用域中，不需要缩进

void foo()           &amp;#x2F;&amp;#x2F; 也是在全局作用域中定义，不缩进
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Inside foo\n&amp;quot;;  &amp;#x2F;&amp;#x2F; 在函数作用域（foo 的内部），所以缩进一级
}

int main()           &amp;#x2F;&amp;#x2F; 也是在全局作用域中定义，不缩进
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Inside main\n&amp;quot;; &amp;#x2F;&amp;#x2F; 也是在函数作用域内部，缩进一级
    foo();                        &amp;#x2F;&amp;#x2F; 继续缩进一级
    return 0;
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#include&lt;&#x2F;code&gt; 和函数定义 &lt;code&gt;void foo()&lt;&#x2F;code&gt;、&lt;code&gt;int main()&lt;&#x2F;code&gt; —— 这些是&lt;strong&gt;最外层的代码（global scope）&lt;&#x2F;strong&gt;，不缩进。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;函数内部的代码是函数的“嵌套作用域”（nested scope）—— 所以要&lt;strong&gt;缩进一级&lt;&#x2F;strong&gt;，表示它们&lt;strong&gt;属于这个函数内部&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;缩进不仅提高可读性，还帮助你视觉上快速看出哪段代码属于哪个作用域。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Day2&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wu-yu-chu-li-qi&quot;&gt;五. 预处理器&lt;&#x2F;h2&gt;
&lt;p&gt;在编译之前，每个代码 （.cpp） 文件都会经历&lt;strong&gt;一个预处理&lt;&#x2F;strong&gt;阶段。在此阶段中，称为 &lt;strong&gt;preprocessor&lt;&#x2F;strong&gt; 的程序对代码文件的文本进行各种更改。预处理器实际上不会以任何方式修改原始代码文件 —— 相反，&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;预处理器所做的所有更改要么临时发生在内存中，要么使用临时文件。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;从历史上看，预处理器是独立于编译器的程序，但在现代编译器中，预处理器可能直接内置到编译器本身中&lt;&#x2F;p&gt;
&lt;p&gt;它去除注释，并确保每个代码文件都以换行符结尾。但是，预处理器确实有一个非常重要的角色：它是处理 &lt;code&gt;#include&lt;&#x2F;code&gt; 指令的程序（我们稍后将详细讨论）。&lt;&#x2F;p&gt;
&lt;p&gt;当预处理器处理完代码文件时，结果称为&lt;strong&gt;翻译单元&lt;&#x2F;strong&gt; 。此翻译单元是编译器随后编译的内容。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello, world!\n&amp;quot;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当预处理器在此程序上运行时，预处理器会将 &lt;code&gt;#include&amp;lt;iostream&amp;gt;&lt;&#x2F;code&gt; 替换为名为 “iostream” 的文件内容，然后预处理包含的内容和文件的其余部分。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;#define&lt;&#x2F;em&gt; 指令可用于创建宏。在 C++ 中， &lt;strong&gt;宏&lt;&#x2F;strong&gt;是定义如何将输入文本转换为替换输出文本的规则。&lt;&#x2F;p&gt;
&lt;p&gt;宏有两种基本类型： &lt;em&gt;类对象宏_和_类函数宏&lt;&#x2F;em&gt; 。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Function-like macros&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;作用类似于函数，并且具有类似的用途。它们的使用通常被认为是不安全的，几乎他们能做的任何事情都可以由普通函数完成。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;em&gt;Object-like macros&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define IDENTIFIER
#define IDENTIFIER substitution_text
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;宏的标识符使用与普通标识符相同的命名规则：它们可以使用字母、数字和下划线，不能以数字开头，也不应以下划线开头。按照约定，宏名称通常全部大写，并用下划线分隔。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

#define MY_NAME &amp;quot;Alex&amp;quot;

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;My name is: &amp;quot; &amp;lt;&amp;lt; MY_NAME &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;预处理器将上述内容转换为以下内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; The contents of iostream are inserted here

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;My name is: &amp;quot; &amp;lt;&amp;lt; &amp;quot;Alex&amp;quot; &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;带有替换文本的类对象宏被使用（在 C 中）作为为文字分配名称的一种方式。这不再是必需的，因为 C++ 中有更好的方法可用:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;内联变量：&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; 在多个文件之间共享全局常量&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bu-dai-ti-huan-wen-ben-de-lei-dui-xiang-hong&quot;&gt;不带替换文本的类对象宏&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define USE_YEN
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这种形式的宏的工作方式可能如您所料：标识符的大多数后续出现都被删除并替换为任何内容！
这似乎很无用，而且对于进行文本替换_毫无用_处。但是，这不是这种形式的指令通常的用途。我们稍后将讨论此表单的用途。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tiao-jian-bian-yi&quot;&gt;条件编译&lt;&#x2F;h3&gt;
&lt;p&gt;_条件编译_预处理器指令允许您指定在什么条件下会编译或不编译。有很多不同的条件编译指令，但我们只介绍最常用的几种：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;#ifdef&lt;&#x2F;em&gt;、&lt;em&gt;#ifndef&lt;&#x2F;em&gt; 和 &lt;em&gt;#endif&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;#ifdef&lt;&#x2F;em&gt; preprocessor 指令允许预处理器检查之前是否通过 #define 定义了标识符。如果是这样，则会编译 &lt;em&gt;#ifdef&lt;&#x2F;em&gt; 和 Matching &lt;em&gt;#endif&lt;&#x2F;em&gt; 之间的代码。否则，将忽略该代码。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ifdef&quot;&gt;ifdef&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout &amp;lt;&amp;lt; &amp;quot;Joe\n&amp;quot;; &amp;#x2F;&amp;#x2F; will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout &amp;lt;&amp;lt; &amp;quot;Bob\n&amp;quot;; &amp;#x2F;&amp;#x2F; will be excluded since PRINT_BOB is not defined
#endif

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为 PRINT_JOE 已被 #defined，所以将编译 &lt;code&gt;std：：cout &amp;lt;&amp;lt; “Joe\n”&lt;&#x2F;code&gt; 行。由于尚未 #defined PRINT_BOB，因此将忽略 &lt;code&gt;std：：cout &amp;lt;&amp;lt; “Bob\n”&lt;&#x2F;code&gt; 行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;#ifndef&lt;&#x2F;em&gt; 与 &lt;em&gt;#ifdef&lt;&#x2F;em&gt; 相反，因为它允许您检查标识符_是否尚未_ _#define_d。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ifndef&quot;&gt;ifndef&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
#ifndef PRINT_BOB
    std::cout &amp;lt;&amp;lt; &amp;quot;Bob\n&amp;quot;;
#endif

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此程序打印 “Bob”，因为 PRINT_BOB 从未 _#define_d。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;if-0&quot;&gt;if 0&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Joe\n&amp;quot;;

#if 0 &amp;#x2F;&amp;#x2F; Don&amp;#x27;t compile anything starting here
    std::cout &amp;lt;&amp;lt; &amp;quot;Bob\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Steve\n&amp;quot;;
#endif &amp;#x2F;&amp;#x2F; until this point

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的代码只打印 “Joe”，因为 &lt;em&gt;#if 0&lt;&#x2F;em&gt; 预处理器指令将 “Bob” 和 “Steve” 排除在编译之外。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;if-1&quot;&gt;if 1&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Joe\n&amp;quot;;

#if 1 &amp;#x2F;&amp;#x2F; always true, so the following code will be compiled
    std::cout &amp;lt;&amp;lt; &amp;quot;Bob\n&amp;quot;;
    &amp;#x2F;* Some
     * multi-line
     * comment here
     *&amp;#x2F;
    std::cout &amp;lt;&amp;lt; &amp;quot;Steve\n&amp;quot;;
#endif

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;shi-yong-chang-jing&quot;&gt;试用场景&lt;&#x2F;h4&gt;
&lt;ol&gt;
&lt;li&gt;控制调试信息&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define DEBUG

#ifdef DEBUG
std::cout &amp;lt;&amp;lt; &amp;quot;Debug info\n&amp;quot;;
#endif

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;控制 &lt;strong&gt;平台相关代码&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#ifdef _WIN32
    &amp;#x2F;&amp;#x2F; Windows 特有代码
#else
    &amp;#x2F;&amp;#x2F; Linux&amp;#x2F;macOS 特有代码
#endif

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c ++&quot; class=&quot;language-c ++ &quot;&gt;&lt;code class=&quot;language-c ++&quot; data-lang=&quot;c ++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void foo()
{
#define MY_NAME &amp;quot;Alex&amp;quot;
}

int main()
{
	std::cout &amp;lt;&amp;lt; &amp;quot;My name is: &amp;quot; &amp;lt;&amp;lt; MY_NAME &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;尽管看起来 &lt;em&gt;#define MY_NAME “Alex”&lt;&#x2F;em&gt; 是在函数 &lt;em&gt;foo&lt;&#x2F;em&gt; 中定义的，但预处理器并不理解函数等 C++概念。因此，此程序的行为与在函数 &lt;em&gt;foo&lt;&#x2F;em&gt; 之前或之后定义 &lt;em&gt;#define MY_NAME “Alex”&lt;&#x2F;em&gt; 的行为相同。为避免混淆，您通常需要在函数之外 #define 标识符。&lt;&#x2F;p&gt;
&lt;p&gt;即使 PRINT 是在 &lt;em&gt;main.cpp&lt;&#x2F;em&gt; 中定义的，也不会对 &lt;em&gt;function.cpp&lt;&#x2F;em&gt; 中的任何代码产生任何影响（PRINT 仅 #defined 从定义点到 main.cpp 末尾）。当我们在以后的课程中讨论 Header Guard 时，这将产生重要影响。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;实际用处！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;wave.h&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef WAVE_H
#define WAVE_H

#include &amp;quot;square.h&amp;quot;

#endif

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;square.h&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;main.cpp&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;quot;square.h&amp;quot;
#include &amp;quot;wave.h&amp;quot;

int main()
{
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;作用防止头文件被重复编译&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;liu-tou-wen-jian&quot;&gt;六. 头文件&lt;&#x2F;h2&gt;
&lt;p&gt;当程序仅包含几个小文件时，在每个文件的顶部手动添加一些前向声明还不错。但是，随着程序变大（并使用更多的文件和函数），必须手动将大量（可能不同）前向声明添加到每个文件的顶部变得非常乏味。例如，如果你有一个 5 个文件的程序，每个程序需要 10 个正向声明，你将不得不复制&#x2F;粘贴 50 个正向声明。现在考虑这样一种情况：您有 100 个文件，每个文件都需要 100 个正向声明。这根本无法扩展！&lt;&#x2F;p&gt;
&lt;p&gt;C++ 代码文件（扩展名为 .cpp）并不是 C++程序中唯一常见的文件。另一种类型的文件称为&lt;strong&gt;头文件&lt;&#x2F;strong&gt; 。&lt;em&gt;头文件通常具有 .h 扩展名&lt;&#x2F;em&gt;，但您偶尔会看到&lt;em&gt;它们具有 .hpp 扩展名或根本没有扩展名。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;言外之意：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你的程序只有几个 &lt;code&gt;.cpp&lt;&#x2F;code&gt; 文件，手动写上这些前向声明还行。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;但当项目变大，比如有 &lt;strong&gt;100 个源文件（.cpp）&lt;&#x2F;strong&gt;，每个文件需要调用很多别的函数，你就需要&lt;strong&gt;复制粘贴大量前向声明到每个文件顶部&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这是非常繁琐、容易出错、无法维护的。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;解决方案&lt;&#x2F;em&gt;：&lt;&#x2F;p&gt;
&lt;p&gt;用头文件！&lt;&#x2F;p&gt;
&lt;p&gt;你可以把这些前向声明写进一个 &lt;code&gt;.h&lt;&#x2F;code&gt; 文件：&lt;&#x2F;p&gt;
&lt;p&gt;这样，&lt;strong&gt;声明只写一次、重复使用&lt;&#x2F;strong&gt;，项目才容易扩展。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;user-attachments&#x2F;assets&#x2F;2b1e9536-7720-4af5-a63b-bfcbfbb83d3b&quot; alt=&quot;Image&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;目前，您应该避免将函数或变量定义放在头文件中。这样做通常会导致在头文件包含在多个源文件中的情况下违反单一定义规则&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;编译 &lt;code&gt;main.cpp&lt;&#x2F;code&gt; 时，&lt;code&gt;#include “add.h”&lt;&#x2F;code&gt; 将替换为 &lt;code&gt;add.h&lt;&#x2F;code&gt; 的内容，然后进行编译。因此，编译器将编译如下所示的内容&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; from add.h:
int add(int x, int y)
{
    return x + y;
}

&amp;#x2F;&amp;#x2F; contents of iostream header here

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;The sum of 3 and 4 is &amp;quot; &amp;lt;&amp;lt; add(3, 4) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;add.cpp&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;int add(int x, int y)
{
    return x + y;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;避免 #including .cpp 文件。&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;使用不带 .h 扩展名的标准库头文件。用户定义的标头仍应使用 .h 扩展名。&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;biao-tou-bao-hu&quot;&gt;标头保护&lt;&#x2F;h3&gt;
&lt;p&gt;好消息是，我们可以通过一种称为 &lt;strong&gt;header guard&lt;&#x2F;strong&gt;（也称为 &lt;strong&gt;include guard&lt;&#x2F;strong&gt;）的机制来避免上述问题。Header guard 是条件编译指令，采用以下形式：&lt;&#x2F;p&gt;
&lt;h2 id=&quot;she-ji-nin-de-di-yi-ge-cheng-xu&quot;&gt;*设计您的第一个程序&lt;&#x2F;h2&gt;
&lt;p&gt;新程序员通常很难弄清楚如何将这个想法转化为实际代码。但事实证明，您已经拥有从日常生活中获得的许多解决问题的技能。&lt;&#x2F;p&gt;
&lt;p&gt;要记住的最重要的事情（也是最难做到的）是在_开始编码之前_设计你的程序。在许多方面，编程就像架构。如果您尝试在不遵循建筑计划的情况下建造房屋会发生什么？很有可能，除非你非常有才华，否则你最终会得到一个有很多问题的房子：墙壁不直、屋顶漏水等......同样，如果你在有一个好的游戏计划之前尝试编程，你可能会发现你的代码有很多问题，你将不得不花费大量时间来解决本可以通过提前思考完全避免的问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji-bu-zou-1-ding-yi-nin-de-mu-biao&quot;&gt;设计步骤 1：定义您的目标&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;写程序前，一定要先明确目标。&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
你应该能用一两句话清楚说明程序的功能，最好从用户角度描述预期结果。比如：“帮用户管理联系人”，或者“模拟物体下落时间”。这个步骤看似简单，但非常关键。最糟糕的情况就是你写了一个根本不符合预期需求的程序。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji-bu-zou-2-ding-yi-yao-qiu&quot;&gt;设计步骤 2：定义要求&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;“Requirements（需求）”指的是两个方面：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;约束条件&lt;&#x2F;strong&gt;：你写程序时必须遵守的限制，比如预算、时间、内存等；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能要求&lt;&#x2F;strong&gt;：程序必须具备哪些能力来满足用户的需求。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;重点是：&lt;strong&gt;需求应该关注“做什么”，而不是“怎么做”&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji-bu-zou-3-ding-yi-nin-de-gong-ju-mu-biao-he-bei-fen-ji-hua&quot;&gt;设计步骤 3：定义您的工具、目标和备份计划&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;定义您的程序将在什么目标架构和&#x2F;或作系统上运行。&lt;&#x2F;li&gt;
&lt;li&gt;确定您将使用的工具集。&lt;&#x2F;li&gt;
&lt;li&gt;确定您是单独编写程序还是作为团队的一部分编写程序&lt;&#x2F;li&gt;
&lt;li&gt;定义您的测试&#x2F;反馈&#x2F;发布策略。&lt;&#x2F;li&gt;
&lt;li&gt;确定如何备份代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;也就是说，如果你要处理任何非平凡的复杂性，你应该有一个备份代码的计划。将源目录压缩或复制到同一存储设备上的其他位置是不够的 - 如果存储设备死机或损坏，您将丢失所有内容。最好将副本或压缩到可移动存储设备（例如闪存驱动器）中，但在发生盗窃、火灾或重大自然灾害时，您仍然有可能丢失所有内容。&lt;&#x2F;p&gt;
&lt;p&gt;最好的备份策略包括将代码的副本获取到位于不同物理位置的计算机上。有很多简单的方法可以做到这一点：压缩并通过电子邮件发送给自己，将其上传到云存储服务（例如 Dropbox），使用文件传输协议（例如 SFTP）将其上传到您控制的服务器，或使用驻留在另一台机器或云中的版本控制系统（例如 github）。版本控制系统还有一个额外的优势，不仅可以恢复您的文件，还可以将它们回滚到以前的版本。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji-bu-zou-4-jiang-kun-nan-wen-ti-fen-jie-wei-jian-dan-wen-ti&quot;&gt;设计步骤 4：将困难问题分解为简单问题&lt;&#x2F;h3&gt;
&lt;p&gt;事实证明，这些任务层次结构在编程中非常有用，因为一旦有了任务层次结构，您基本上就定义了整个程序的结构。顶级任务（在本例中为 “Clean the house” 或 “Go to work”） 变为 main（） （因为它是你试图解决的主要问题）。子项将成为程序中的函数&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;- Get from bed to work  
    从床上到工作地点
    - Bedroom things  卧室物品
        - Turn off alarm  关闭闹钟
        - Get out of bed  起床
        - Pick out clothes  挑选衣服
    - Bathroom things  浴室用品
        - Take a shower  洗个澡
        - Get dressed  穿衣服
        - Brush your teeth  刷牙
    - Breakfast things  早餐
        - Make coffee or tea  冲泡咖啡或茶
        - Eat cereal  吃麦片
    - Transportation things  交通
        - Get on your bicycle  骑上你的自行车
        - Travel to work  上班旅行
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果事实证明其中一个项目（功能）太难实现，只需将该项目拆分为多个子项目&#x2F;子功能即可。最终，您应该达到程序中的每个函数都很容易实现的地步。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;she-ji-bu-zou-5-que-ding-shi-jian-de-shun-xu&quot;&gt;设计步骤 5：确定事件的顺序&lt;&#x2F;h3&gt;
&lt;p&gt;现在，您的程序已经有了结构，是时候确定如何将所有任务链接在一起了。第一步是确定将要执行的事件的顺序。例如，当您早上起床时，您按什么顺序执行上述任务？它可能看起来像这样：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Bedroom things  卧室物品&lt;&#x2F;li&gt;
&lt;li&gt;Bathroom things  浴室用品&lt;&#x2F;li&gt;
&lt;li&gt;Breakfast things  早餐&lt;&#x2F;li&gt;
&lt;li&gt;Transportation things  交通&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shi-shi-bu-zou-1-gai-shu-nin-de-zhu-yao-gong-neng&quot;&gt;实施步骤 1：概述您的主要功能&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int main()
{
&amp;#x2F;&amp;#x2F;    doBedroomThings();
&amp;#x2F;&amp;#x2F;    doBathroomThings();
&amp;#x2F;&amp;#x2F;    doBreakfastThings();
&amp;#x2F;&amp;#x2F;    doTransportationThings();

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-xian-bu-zou-2-shi-xian-mei-ge-gong-neng&quot;&gt;实现步骤 2：实现每个功能&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;定义函数原型（输入和输出）&lt;&#x2F;li&gt;
&lt;li&gt;编写函数&lt;&#x2F;li&gt;
&lt;li&gt;测试函数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;shi-shi-bu-zou-3-zui-zhong-ce-shi&quot;&gt;实施步骤 3：最终测试&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;让您的程序易于启动&lt;&#x2F;strong&gt; 。通常，新程序员对他们希望程序完成的所有事情都有一个宏伟的愿景。“我想写一个带有图形和声音的角色扮演游戏，以及随机的怪物和地牢，有一个你可以参观的城镇来出售你在地牢中找到的物品”。如果你试图写一些太复杂而无法开始的东西，你会因为没有进展而变得不知所措和气馁。相反，让你的第一个目标尽可能简单，这绝对是你能实现的。例如，“我希望能够在屏幕上显示 2 维字段”。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;随时间推移添加功能&lt;&#x2F;strong&gt; 。一旦您的简单程序运行良好，您就可以为其添加功能。例如，一旦您可以显示您的字段，请添加一个可以四处走动的角色。一旦你可以四处走动，添加可能阻碍你前进的墙壁。一旦你有了城墙，就用它们建造一个简单的城镇。一旦你有一个城镇，添加商人。通过逐步添加每个功能，您的程序将逐渐变得更加复杂，而不会在此过程中让您不知所措。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;一次专注于一个区域&lt;&#x2F;strong&gt; 。不要试图一次编写所有内容，也不要将注意力分散到多个任务上。一次专注于一项任务。有一个工作任务和五个尚未开始的任务比有六个部分工作的任务要好得多。如果你分散注意力，你更有可能犯错误并忘记重要的细节。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;随时测试每段代码&lt;&#x2F;strong&gt; 。新程序员通常会一次性编写整个程序。然后，当他们第一次编译它时，编译器会报告数百个错误。这不仅令人生畏，如果您的代码不起作用，可能很难弄清楚原因。相反，编写一段代码，然后立即编译和测试它。如果它不起作用，您将确切地知道问题所在，并且很容易解决。确定代码有效后，请转到下一部分并重复。完成代码编写可能需要更长的时间，但是当您完成时，整个事情应该可以正常工作，并且您不必花费两倍的时间来试图找出它为什么不行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;不要投资于完善早期代码&lt;&#x2F;strong&gt; 。功能（或程序）的初稿很少是好的。此外，随着您添加功能并找到更好的方法来构建事物，程序往往会随着时间的推移而发展。如果您过早地投资于完善代码（添加大量文档、完全符合最佳实践、进行优化），那么在需要更改代码时，您可能会失去所有投资。相反，让您的功能最低限度地工作，然后继续前进。当您对自己的解决方案充满信心时，可以进行连续的润色。不要追求完美 -- 非平凡的程序永远不会完美，总有更多的事情可以改进它们。达到 “足够好” 并继续前进。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;针对可维护性进行优化，而不是针对性能进行优化&lt;&#x2F;strong&gt; 。有一句名言（由 Donald Knuth 引用）说“过早优化是万恶之源”。新程序员通常会花费太多时间思考如何对他们的代码进行微优化（例如，试图找出 2 个语句中哪一个更快）。这很少重要。大多数性能优势来自良好的程序结构、针对手头的问题使用正确的工具和功能以及遵循最佳实践。应使用额外的时间来提高代码的可维护性。找到冗余并删除它。将长函数拆分为较短的函数。用更好的代码替换笨拙或难以使用的代码。最终结果将是代码更容易改进和优化（在您确定了实际需要优化的位置之后）和更少的错误。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;总结：&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从简单开始&lt;&#x2F;strong&gt;：不要一开始就写复杂系统，先实现最基础、最小的功能，逐步迭代。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逐步增加功能&lt;&#x2F;strong&gt;：先把核心功能做好，再逐步加入角色、障碍、城镇等扩展内容。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一次专注一件事&lt;&#x2F;strong&gt;：不要分心做多个任务，集中精力完成一个功能，比多个半成品更好。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;边写边测试&lt;&#x2F;strong&gt;：写一点，编译测试一点，问题容易定位，避免一堆错误一起出现。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;别急着打磨代码&lt;&#x2F;strong&gt;：先实现功能，不用一开始就追求完美，功能稳定后再优化。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先可维护性而非性能&lt;&#x2F;strong&gt;：早期不要过度优化，写结构清晰、易维护的代码更重要。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;yi-yu-fa-he-yu-yi-cuo-wu&quot;&gt;一. 语法和语义错误&lt;&#x2F;h2&gt;
&lt;p&gt;学习查找和删除您编写的程序中的错误是成为一名成功程序员极其重要的部分&lt;&#x2F;p&gt;
&lt;p&gt;行时语义错误并不容易通过观察代码来发现。这就是调试技术可以派上用场的地方。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tong-guo-yun-xing-cheng-xu-cha-zhao-wen-ti&quot;&gt;通过运行程序查找问题&lt;&#x2F;h3&gt;
&lt;p&gt;幸运的是，如果我们无法通过代码检查找到问题，我们可以采取另一种途径：我们可以在程序运行时观察其行为，并尝试从中&lt;em&gt;诊断问题&lt;&#x2F;em&gt;。这种方法可以概括为：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;弄清楚如何重现问题&lt;&#x2F;li&gt;
&lt;li&gt;运行程序并收集信息以缩小问题所在范围&lt;&#x2F;li&gt;
&lt;li&gt;重复上一步，直到找到问题&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;zhong-xian-wen-ti&quot;&gt;重现问题&lt;&#x2F;h3&gt;
&lt;p&gt;发现问题的第一步也是最重要的一步是能够_重现问题_ 。重现问题意味着使问题以一致的方式出现。原因很简单：除非你能观察到问题的发生，否则很难发现它。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;guan-zhu-wen-ti&quot;&gt;关注问题&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;diao-shi-ce-lue-1-zhu-shi-diao-ni-de-dai-ma&quot;&gt;调试策略 1：注释掉你的代码&lt;&#x2F;h3&gt;
&lt;p&gt;让我们从一个简单的开始。如果您的程序表现出错误的行为，减少必须搜索的代码量的一种方法是注释掉一些代码，然后查看问题是否仍然存在。如果问题保持不变，则注释掉的代码可能没有责任。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;diao-shi-ce-lue-2-yan-zheng-dai-ma-liu&quot;&gt;调试策略 2：验证代码流&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;std::cerr &amp;lt;&amp;lt; &quot;getValue() called\n&quot;;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;iostream&amp;gt;

int getValue()
{
    std::cerr &amp;lt;&amp;lt; &amp;quot;getValue() called\n&amp;quot;;
    return 4;
}

int main()
{
    std::cout &amp;lt;&amp;lt; getValue &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;diao-shi-ce-lue-3-da-yin-zhi&quot;&gt;调试策略 3：打印值&lt;&#x2F;h3&gt;
&lt;p&gt;对于某些类型的 bug，程序可能会计算或传递错误的值。&lt;&#x2F;p&gt;
&lt;p&gt;我们还可以输出变量（包括参数）或表达式的值，以确保它们是正确的&lt;&#x2F;p&gt;
&lt;p&gt;虽然向程序添加调试语句以进行诊断是一种常见的基本技术，也是一种功能性技术（尤其是当调试器由于某种原因不可用时），但它并不是那么好，原因有很多：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Debug 语句会使您的代码变得混乱。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Debug 语句会使程序的输出变得混乱。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;调试语句需要修改代码以添加和删除，这可能会引入新的错误。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;调试语句必须在使用完后删除它们，这使得它们不可重用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;3-5-geng-duo-diao-shi-ce-lue&quot;&gt;3.5 – 更多调试策略&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;hong&quot;&gt;宏&lt;&#x2F;h4&gt;
&lt;p&gt;在整个程序中更轻松地禁用和启用调试的一种方法是使用预处理器指令&lt;em&gt;将调试语句设为条件：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

#define ENABLE_DEBUG &amp;#x2F;&amp;#x2F; comment out to disable debugging

int getUserInput()
{
#ifdef ENABLE_DEBUG
	std::cerr &amp;lt;&amp;lt; &amp;quot;getUserInput() called\n&amp;quot;;
#endif
	std::cout &amp;lt;&amp;lt; &amp;quot;Enter a number: &amp;quot;;
	int x{};
	std::cin &amp;gt;&amp;gt; x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
	std::cerr &amp;lt;&amp;lt; &amp;quot;main() called\n&amp;quot;;
#endif
	int x{ getUserInput() };
	std::cout &amp;lt;&amp;lt; &amp;quot;You entered: &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在我们只需通过注释 &#x2F; 取消注释 &lt;em&gt;#define ENABLE_DEBUG&lt;&#x2F;em&gt; 来启用调试。这允许我们重用以前添加的 debug 语句，然后在完成它们时禁用它们，而不必实际从代码中删除它们。如果这是一个多文件程序，则 #define ENABLE_DEBUG 将放入包含在所有代码文件中的头文件中，以便我们可以在单个位置注释&#x2F;取消注释 #define 并将其传播到所有代码文件。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ri-zhi-wen-jian&quot;&gt;日志文件&lt;&#x2F;h4&gt;
&lt;p&gt;通过预处理器进行条件化调试的另一种方法是将调试信息发送到日志。 &lt;strong&gt;日志&lt;&#x2F;strong&gt;是已发生事件的顺序记录，通常带有时间戳。生成日志的过程称为&lt;strong&gt;日志记录&lt;&#x2F;strong&gt; 。通常，日志会写入磁盘上的文件（称为&lt;strong&gt;日志文件&lt;&#x2F;strong&gt; ），以便以后查看。大多数应用程序和作系统都会写入日志文件，这些文件可用于帮助诊断发生的问题。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;写入日志文件的信息与程序的输出是分开的&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;C++ 包含一个名为 `std：：clog` 的输出流，该流旨在用于写入日志记录信息。但是，默认情况下，`std：：clog` 会写入标准错误流（与 `std：：cerr` 相同）。虽然您可以将其重定向到 file，但这是您通常最好使用众多现有可用第三方日志记录工具之一的领域。你使用哪一个取决于你。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;plog&amp;#x2F;Log.h&amp;gt; &amp;#x2F;&amp;#x2F; Step 1: include the logger headers
#include &amp;lt;plog&amp;#x2F;Initializers&amp;#x2F;RollingFileInitializer.h&amp;gt;
#include &amp;lt;iostream&amp;gt;

int getUserInput()
{
	PLOGD &amp;lt;&amp;lt; &amp;quot;getUserInput() called&amp;quot;; &amp;#x2F;&amp;#x2F; PLOGD is defined by the plog library

	std::cout &amp;lt;&amp;lt; &amp;quot;Enter a number: &amp;quot;;
	int x{};
	std::cin &amp;gt;&amp;gt; x;
	return x;
}

int main()
{
	plog::init(plog::debug, &amp;quot;Logfile.txt&amp;quot;); &amp;#x2F;&amp;#x2F; Step 2: initialize the logger

	PLOGD &amp;lt;&amp;lt; &amp;quot;main() called&amp;quot;; &amp;#x2F;&amp;#x2F; Step 3: Output to the log as if you were writing to the console

	int x{ getUserInput() };
	std::cout &amp;lt;&amp;lt; &amp;quot;You entered: &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;tiao-yue&quot;&gt;跳跃！&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;7-1-fu-he-yu-ju&quot;&gt;7.1  复合语句&lt;&#x2F;h2&gt;
&lt;p&gt;一组_零个或多个语句_ ，编译器将其视为单个语句&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-ta-kuai-nei-de-kuai&quot;&gt;其他块内的块&lt;&#x2F;h3&gt;
&lt;p&gt;虽然函数不能嵌套在其他函数中，但块_可以_嵌套在其他块中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int add(int x, int y)
{ &amp;#x2F;&amp;#x2F; block
    return x + y;
} &amp;#x2F;&amp;#x2F; end block

int main()
{ &amp;#x2F;&amp;#x2F; outer block

    &amp;#x2F;&amp;#x2F; multiple statements
    int value {};

    { &amp;#x2F;&amp;#x2F; inner&amp;#x2F;nested block
        add(3, 4);
    } &amp;#x2F;&amp;#x2F; end inner&amp;#x2F;nested block

    return 0;

} &amp;#x2F;&amp;#x2F; end outer block
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;当块嵌套时，封闭块通常称为&lt;strong&gt;外部块&lt;&#x2F;strong&gt; ，封闭块称为&lt;strong&gt;内部块&lt;&#x2F;strong&gt;或&lt;strong&gt;嵌套块&lt;&#x2F;strong&gt; 。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-kuai-you-tiao-jian-di-zhi-xing-duo-ge-yu-ju&quot;&gt;使用块有条件地执行多个语句&lt;&#x2F;h3&gt;
&lt;p&gt;块最常见的用例之一是与 &lt;code&gt;if 语句&lt;&#x2F;code&gt;结合使用。默认情况下，如果条件的计算结果为 &lt;code&gt;true&lt;&#x2F;code&gt;， &lt;code&gt;则 if 语句&lt;&#x2F;code&gt;将执行单个语句。但是，如果我们希望在条件计算结果为 &lt;code&gt;true&lt;&#x2F;code&gt; 时执行多个语句，则可以将这个语句替换为一个语句块。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{ &amp;#x2F;&amp;#x2F; start of outer block
    std::cout &amp;lt;&amp;lt; &amp;quot;Enter an integer: &amp;quot;;
    int value {};
    std::cin &amp;gt;&amp;gt; value;

    if (value &amp;gt;= 0)
    { &amp;#x2F;&amp;#x2F; start of nested block
        std::cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;quot; is a positive integer (or zero)\n&amp;quot;;
        std::cout &amp;lt;&amp;lt; &amp;quot;Double this number is &amp;quot; &amp;lt;&amp;lt; value * 2 &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    } &amp;#x2F;&amp;#x2F; end of nested block
    else
    { &amp;#x2F;&amp;#x2F; start of another nested block
        std::cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;quot; is a negative integer\n&amp;quot;;
        std::cout &amp;lt;&amp;lt; &amp;quot;The positive of this number is &amp;quot; &amp;lt;&amp;lt; -value &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    } &amp;#x2F;&amp;#x2F; end of another nested block

    return 0;
} &amp;#x2F;&amp;#x2F; end of outer block
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;kuai-qian-tao-ji-bie&quot;&gt;块嵌套级别&lt;&#x2F;h3&gt;
&lt;p&gt;甚至可以将块放在块内，块内放在块内：&lt;&#x2F;p&gt;
&lt;p&gt;函数的&lt;strong&gt;嵌套级别&lt;&#x2F;strong&gt; （也称为&lt;strong&gt;嵌套深度&lt;&#x2F;strong&gt; ）是您在函数中任何点（包括外部块）可以位于内部的最大嵌套块数。在上面的函数中，有 4 个块，但嵌套级别是 3，因为在这个程序中，你在任何时候都不能超过 3 个块。&lt;&#x2F;p&gt;
&lt;p&gt;最好将嵌套级别保持在 3 或更低。正如过长的函数是重构（分成更小的函数）的良好候选者一样，过度嵌套的块很难阅读，并且是重构的良好候选者（嵌套最多的块成为单独的函数）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yong-hu-ding-yi-de-ming-ming-kong-jian-he-fan-wei-jie-xi-yun-suan-fu&quot;&gt;用户定义的命名空间和范围解析运算符&lt;&#x2F;h3&gt;
&lt;p&gt;让我们重新审视一个命名冲突的示例，然后展示如何使用命名空间进行改进。在下面的示例中，&lt;code&gt;foo.cpp&lt;&#x2F;code&gt; 和 &lt;code&gt;goo.cpp&lt;&#x2F;code&gt; 是包含执行不同作但具有相同名称和参数的函数的源文件。&lt;&#x2F;p&gt;
&lt;p&gt;解决此问题的一种方法是重命名其中一个函数，这样名称就不会再发生冲突。但这也需要更改所有函数调用的名称，这可能会很痛苦，并且容易出错。避免冲突的更好方法是将函数放入自己的命名空间中。因此，标准库被移动到 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间中。&lt;&#x2F;p&gt;
&lt;p&gt;foo.cpp&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; This doSomething() adds the value of its parameters
int doSomething(int x, int y)
{
    return x + y;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;goo.cpp&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; This doSomething() subtracts the value of its parameters
int doSomething(int x, int y)
{
    return x - y;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果将两个 &lt;em&gt;.cpp&lt;&#x2F;em&gt;  文件 编译在一起 一定会产生冲突！ &lt;em&gt;main.cpp&lt;&#x2F;em&gt;不知道使用哪个&lt;em&gt;doSomething（）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;解决此问题的一种方法是重命名其中一个函数，这样名称就不会再发生冲突。但这也需要更改所有函数调用的名称，这可能会很痛苦，并且容易出错。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;避免冲突的更好方法是将函数放入自己的命名空间中。因此，标准库被移动到 &lt;code&gt;std&lt;&#x2F;code&gt; 命名空间中。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;7-2ding-yi-nin-zi-ji-de-ming-ming-kong-jian&quot;&gt;7.2定义您自己的命名空间&lt;&#x2F;h2&gt;
&lt;p&gt;C++ 允许我们通过 &lt;code&gt;namespace&lt;&#x2F;code&gt; 关键字定义我们自己的命名空间。您在自己的程序中创建的命名空间被随意称为&lt;strong&gt;用户定义的命名空间&lt;&#x2F;strong&gt; （尽管将它们称为&lt;strong&gt;程序定义的命名空间&lt;&#x2F;strong&gt;更准确）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;namespace NamespaceIdentifier
{
    &amp;#x2F;&amp;#x2F; content of namespace here
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们建议命名空间名称以大写字母开头。但是，任何一种风格都应该被视为可以接受。&lt;&#x2F;p&gt;
&lt;p&gt;！！！修改一下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;namespace Foo &amp;#x2F;&amp;#x2F; define a namespace named Foo
{
    &amp;#x2F;&amp;#x2F; This doSomething() belongs to namespace Foo
    int doSomething(int x, int y)
    {
        return x + y;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;！！！修改一下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;namespace Goo &amp;#x2F;&amp;#x2F; define a namespace named Goo
{
    &amp;#x2F;&amp;#x2F; This doSomething() belongs to namespace Goo
    int doSomething(int x, int y)
    {
        return x - y;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是！ 在这种情况下，编译器满足了（通过我们的 forward 声明），但链接器在全局命名空间中找不到 &lt;code&gt;doSomething&lt;&#x2F;code&gt; 的定义。这是因为我们的两个 &lt;code&gt;doSomething&lt;&#x2F;code&gt; 版本都不再位于全局命名空间中！它们现在位于各自的命名空间范围内！&lt;&#x2F;p&gt;
&lt;p&gt;告诉编译器在特定命名空间中查找标识符的最佳方法是使用&lt;strong&gt;范围解析运算符&lt;&#x2F;strong&gt; （：:).范围解析运算符告诉编译器，应在左侧作数的范围内查找右侧作数指定的标识符。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

void print() &amp;#x2F;&amp;#x2F; this print() lives in the global namespace
{
	std::cout &amp;lt;&amp;lt; &amp;quot; there\n&amp;quot;;
}

namespace Foo
{
	void print() &amp;#x2F;&amp;#x2F; this print() lives in the Foo namespace
	{
		std::cout &amp;lt;&amp;lt; &amp;quot;Hello&amp;quot;;
	}

	void printHelloThere()
	{
		print();   &amp;#x2F;&amp;#x2F; calls print() in Foo namespace
		::print(); &amp;#x2F;&amp;#x2F; calls print() in global namespace
	}
}

int main()
{
	Foo::printHelloThere();

	return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;请注意，因为命名空间 &lt;code&gt;Goo&lt;&#x2F;code&gt; 在命名空间 &lt;code&gt;Foo&lt;&#x2F;code&gt; 内，所以我们以 &lt;code&gt;Foo：：Goo：：add&lt;&#x2F;code&gt; 的形式访问 &lt;code&gt;add&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

namespace Foo
{
    namespace Goo &amp;#x2F;&amp;#x2F; Goo is a namespace inside the Foo namespace
    {
        int add(int x, int y)
        {
            return x + y;
        }
    }
}

int main()
{
    std::cout &amp;lt;&amp;lt; Foo::Goo::add(1, 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;ming-ming-kong-jian-bie-ming&quot;&gt;命名空间别名&lt;&#x2F;h3&gt;
&lt;p&gt;因为在嵌套命名空间中键入变量或函数的限定名称可能很痛苦，所以 C++ 允许你创建&lt;strong&gt;命名空间别名&lt;&#x2F;strong&gt; ，这允许我们暂时将一长串命名空间缩短为更短的命名空间：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

namespace Foo::Goo
{
    int add(int x, int y)
    {
        return x + y;
    }
}

int main()
{
    namespace Active = Foo::Goo; &amp;#x2F;&amp;#x2F; active now refers to Foo::Goo

    std::cout &amp;lt;&amp;lt; Active::add(1, 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; This is really Foo::Goo::add()

    return 0;
} &amp;#x2F;&amp;#x2F; The Active alias ends here
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;别名的好处：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

namespace Foo::Goo
{
}

namespace V2
{
    int add(int x, int y)
    {
        return x + y;
    }
}

int main()
{
    namespace Active = V2; &amp;#x2F;&amp;#x2F; active now refers to V2

    std::cout &amp;lt;&amp;lt; Active::add(1, 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; We don&amp;#x27;t have to change this

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;在多团队组织中，经常使用两级甚至三级命名空间来防止不同团队生成的代码之间的命名冲突。这些通常采用以下形式之一：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;项目或库 ：： 模块 （例如 &lt;code&gt;Foologger：：Lang&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;公司或组织 ：： 项目或库 （例如 &lt;code&gt;Foosoft：：Foologger&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;Company or org ：： 项目或库 ：： 模块 （例如 &lt;code&gt;Foosoft：：Foologger：：Lang&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;7-3-ju-bu-bian-liang&quot;&gt;7.3 局部变量&lt;&#x2F;h2&gt;
&lt;p&gt;局部变量具有&lt;strong&gt;块范围&lt;&#x2F;strong&gt; ，这意味着它们在从其&lt;em&gt;定义点到定义它们的块末尾的_范围内_&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在&lt;em&gt;最有限的现有范围内定义变量&lt;&#x2F;em&gt;。&lt;em&gt;避免创建仅以限制变量范围&lt;&#x2F;em&gt;为目的的新区块。&lt;&#x2F;p&gt;
&lt;p&gt;不要这样&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;{
    temp := compute() &amp;#x2F;&amp;#x2F; 只想让 temp 只在这个块里生效
    use(temp)
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而是这样&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;temp := compute()
use(temp)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;7-4-quan-ju-bian-liang&quot;&gt;7.4 全局变量&lt;&#x2F;h2&gt;
&lt;p&gt;全局变量也可以在用户定义的命名空间中定义。这是与上面相同的示例，&lt;em&gt;但 &lt;code&gt;g_x&lt;&#x2F;code&gt; 已从全局范围移动到用户定义的命名空间 &lt;code&gt;Foo&lt;&#x2F;code&gt; 中：&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

namespace Foo &amp;#x2F;&amp;#x2F; Foo is defined in the global scope
{
    int g_x {}; &amp;#x2F;&amp;#x2F; g_x is now inside the Foo namespace, but is still a global variable
}

void doSomething()
{
    &amp;#x2F;&amp;#x2F; global variables can be seen and used everywhere in the file
    Foo::g_x = 3;
    std::cout &amp;lt;&amp;lt; Foo::g_x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
}

int main()
{
    doSomething();
    std::cout &amp;lt;&amp;lt; Foo::g_x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    &amp;#x2F;&amp;#x2F; global variables can be seen and used everywhere in the file
    Foo::g_x = 5;
    std::cout &amp;lt;&amp;lt; Foo::g_x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;!!! 首选在命名空间内定义全局变量，而不是在全局命名空间中定义全局变量。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;ju-bian-liang-ju-you-jing-tai-chi-xu-shi-jian&quot;&gt;局变量具有静态持续时间&lt;&#x2F;h3&gt;
&lt;p&gt;全局变量在程序启动时（ &lt;code&gt;在 main（）&lt;&#x2F;code&gt; 开始执行之前）创建，并在程序结束时销毁。这称为&lt;strong&gt;静态持续时间&lt;&#x2F;strong&gt; 。具有_静态持续时间_的变量有时称为&lt;strong&gt;静态变量&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;按照惯例，一些开发人员在全局变量标识符前面加上 “g” 或 “g_” 以指示它们是全局变量。此前缀有几个用途&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;在命名全局变量（尤其是在全局命名空间中定义的变量）时，请考虑使用“g”或“g_”前缀，以帮助将它们与局部变量和函数参数区分开来。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;const int g_x;     &amp;#x2F;&amp;#x2F; error: constant variables must be initialized
constexpr int g_w; &amp;#x2F;&amp;#x2F; error: constexpr variables must be initialized

const int g_y{ 1 };     &amp;#x2F;&amp;#x2F; const global variable g_y, initialized with a value
constexpr int g_z{ 2 }; &amp;#x2F;&amp;#x2F; constexpr global variable g_z, initialized with a value
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;普通全局变量&lt;&#x2F;strong&gt;、&lt;strong&gt;&lt;code&gt;const&lt;&#x2F;code&gt; 全局变量&lt;&#x2F;strong&gt; 和 &lt;strong&gt;&lt;code&gt;constexpr&lt;&#x2F;code&gt; 全局变量&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int g_x;        &amp;#x2F;&amp;#x2F; 默认初始化为 0（在全局作用域）
int g_x {};     &amp;#x2F;&amp;#x2F; 显式初始化为 0
int g_x { 1 };  &amp;#x2F;&amp;#x2F; 显式初始化为 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;const int g_y;       &amp;#x2F;&amp;#x2F; ❌ 错：必须初始化
const int g_y { 2 }; &amp;#x2F;&amp;#x2F; ✅ 正确：初始化为 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;7-5-bian-liang-yin-cang-ming-cheng-yin-cang&quot;&gt;7.5 变量隐藏（名称隐藏）&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;局部变量的隐藏&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{ &amp;#x2F;&amp;#x2F; outer block
    int apples{ 5 }; &amp;#x2F;&amp;#x2F; here&amp;#x27;s the outer block apples

    { &amp;#x2F;&amp;#x2F; nested block
        &amp;#x2F;&amp;#x2F; apples refers to outer block apples here
        std::cout &amp;lt;&amp;lt; apples &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; print value of outer block apples

        int apples{ 0 }; &amp;#x2F;&amp;#x2F; define apples in the scope of the nested block

        &amp;#x2F;&amp;#x2F; apples now refers to the nested block apples
        &amp;#x2F;&amp;#x2F; the outer block apples is temporarily hidden

        apples = 10; &amp;#x2F;&amp;#x2F; this assigns value 10 to nested block apples, not outer block apples

        std::cout &amp;lt;&amp;lt; apples &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; print value of nested block apples
    } &amp;#x2F;&amp;#x2F; nested block apples destroyed


    std::cout &amp;lt;&amp;lt; apples &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; prints value of outer block apples

    return 0;
} &amp;#x2F;&amp;#x2F; outer block apples destroyed
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果块内没有  &lt;code&gt;int apples{ 0 };&lt;&#x2F;code&gt; 则会影响块外变量&lt;&#x2F;p&gt;
&lt;h4 id=&quot;quan-ju-bian-liang-de-yin-cang&quot;&gt;全局变量的隐藏&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;
int value { 5 }; &amp;#x2F;&amp;#x2F; global variable

void foo()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;global variable value: &amp;quot; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;; &amp;#x2F;&amp;#x2F; value is not shadowed here, so this refers to the global value
}

int main()
{
    int value { 7 }; &amp;#x2F;&amp;#x2F; hides the global variable value (wherever local variable value is in scope)

    ++value; &amp;#x2F;&amp;#x2F; increments local value, not global value

    std::cout &amp;lt;&amp;lt; &amp;quot;local variable value: &amp;quot; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;

    foo();

    return 0;
} &amp;#x2F;&amp;#x2F; local value is destroyed
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;（：:) 来告诉编译器我们指的是全局变量而不是局部变量。&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bi-mian-bian-liang-yin-ying&quot;&gt;避免变量阴影&lt;&#x2F;h4&gt;
&lt;p&gt;通常应避免局部变量的阴影，因为在使用或修改错误的变量时，这可能会导致无意中的错误。某些编译器会在变量被隐藏时发出警告。&lt;&#x2F;p&gt;
&lt;p&gt;出于我们建议避免隐藏局部变量的相同原因，我们也建议避免隐藏全局变量。如果你的所有全域名称都使用 “g_” 前缀，这是很容易避免的。&lt;&#x2F;p&gt;
&lt;p&gt;*&lt;strong&gt;内层变量不要和外层重名&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;7-6-nei-bu-lian-jie&quot;&gt;7.6 – 内部链接&lt;&#x2F;h2&gt;
&lt;p&gt;全局变量和函数标识符可以具有&lt;code&gt;内部链接&lt;&#x2F;code&gt;或&lt;code&gt;外部链接&lt;&#x2F;code&gt;
局部变量并没有链接！&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; file1.cpp
int g_val = 100;  &amp;#x2F;&amp;#x2F; 外部链接变量

&amp;#x2F;&amp;#x2F; file2.cpp
extern int g_val; &amp;#x2F;&amp;#x2F; 引用 file1 中的变量

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; file1.cpp
static int g_val = 42;  &amp;#x2F;&amp;#x2F; 内部链接，只能 file1 访问

static void helper() {} &amp;#x2F;&amp;#x2F; 内部链接函数
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;ju-you-nei-bu-lian-jie-de-quan-ju-bian-liang&quot;&gt;具有内部链接的全局变量&lt;&#x2F;h4&gt;
&lt;p&gt;具有内部链接的全局变量有时称为&lt;strong&gt;内部变量&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;要使非常量全局变量内部化，我们使用 &lt;code&gt;static&lt;&#x2F;code&gt; 关键字。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nei-lian-bian-liang&quot;&gt;内联变量&lt;&#x2F;h4&gt;
&lt;p&gt;函数标识符也具有链接。函数默认为 external linkage&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;WHY？ 为什么要费心给标识符内部链接呢？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;我们要确保其他文件无法访问某个标识符。这可能是我们不想弄乱的全局变量，或者是我们不想被调用的辅助函数。&lt;&#x2F;p&gt;
&lt;p&gt;对避免命名冲突迂腐。因为具有内部链接的标识符不会暴露给链接器，所以它们只能与同一翻译单元中的名称发生冲突，而不能在整个程序中发生冲突&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑为所有你不希望其他文件访问的标识符提供内部链接&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当您有明确的理由禁止从其他文件访问时，为 identifiers 提供内部链接。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;7-7-wai-bu-lian-jie-he-ke-bian-qian-xiang-sheng-ming&quot;&gt;7.7 外部链接和可变前向声明&lt;&#x2F;h2&gt;
&lt;p&gt;具有外部链接的标识符对链接器可见。这允许链接器执行两项作：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;将一个翻译单元中使用的标识符与另一个翻译单元中的相应定义连接起来。&lt;&#x2F;li&gt;
&lt;li&gt;删除重复的内联标识符，以便保留一个规范定义&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;han-shu-mo-ren-ju-you-wai-bu-lian-jie&quot;&gt;函数默认具有外部链接&lt;&#x2F;h3&gt;
&lt;p&gt;具有外部链接的全局变量有时称为&lt;strong&gt;外部变量&lt;&#x2F;strong&gt; 。要使全局变量为 external（从而被其他文件访问），我们可以使用 &lt;code&gt;extern&lt;&#x2F;code&gt; 关键字来做到这一点：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int g_x { 2 }; &amp;#x2F;&amp;#x2F; non-constant globals are external by default (no need to use extern)

extern const int g_y { 3 }; &amp;#x2F;&amp;#x2F; const globals can be defined as extern, making them external
extern constexpr int g_z { 3 }; &amp;#x2F;&amp;#x2F; constexpr globals can be defined as extern, making them external (but this is pretty useless, see the warning in the next section)

int main()
{
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果要定义未初始化的非 const 全局变量，请不要使用 extern 关键字，否则 C++ 会认为你正在尝试为该变量进行前向声明。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;xiang-qian-sheng-ming&quot;&gt;向前声明&lt;&#x2F;h4&gt;
&lt;p&gt;“&lt;strong&gt;向前声明（forward declaration）&lt;&#x2F;strong&gt;”是告诉编译器：“某个变量或函数&lt;strong&gt;在别的地方有定义&lt;&#x2F;strong&gt;，你先记着，现在先别报错。”&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; a.cpp
int g_x = 10;  &amp;#x2F;&amp;#x2F; 真正定义并初始化 g_x（外部链接）

&amp;#x2F;&amp;#x2F; main.cpp
extern int g_x;  &amp;#x2F;&amp;#x2F; 👉 向前声明：g_x 在别处定义
int main() {
    std::cout &amp;lt;&amp;lt; g_x &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;  &amp;#x2F;&amp;#x2F; 可以用
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;向前声明 &lt;strong&gt;不等于定义&lt;&#x2F;strong&gt;，只是告诉编译器：“等下你会看到它的定义”。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;向前声明是&lt;strong&gt;多文件协作的关键技术&lt;&#x2F;strong&gt;，让你能在一个文件中使用另一个文件里的变量或函数。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免在带有初始化器的非 const 全局变量上使用 &lt;code&gt;extern&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int g_x { 1 };        &amp;#x2F;&amp;#x2F; extern by default
extern int g_x { 1 }; &amp;#x2F;&amp;#x2F; explicitly extern (may cause compiler warning)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是，编译器可能会发出有关后一个语句的警告，即使它在技术上是有效的&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅将 &lt;code&gt;extern&lt;&#x2F;code&gt; 用于全局变量前向声明或 const 全局变量定义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;不要将 &lt;code&gt;extern&lt;&#x2F;code&gt; 用于非 const 全局变量定义（它们是隐式的 &lt;code&gt;extern&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;7-8-wei-shen-me-quan-ju-bian-liang-shi-xie-e-de&quot;&gt;7.8 — 为什么全局变量是邪恶的&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;“避免使用全局变量！而且有充分的理由：全局变量是该语言中历史上最被滥用的概念之一&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;非 const 全局变量。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;非 const 全局变量危险的最大原因是它们的值可以被调用_的任何_函数更改，并且程序员没有简单的方法可以知道这种情况会发生&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果在大型项目中 可能会造成的问题！&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int g_mode; &amp;#x2F;&amp;#x2F; declare global variable (will be zero-initialized by default)

void doSomething()
{
    g_mode = 2; &amp;#x2F;&amp;#x2F; set the global g_mode variable to 2
}

int main()
{
    g_mode = 1; &amp;#x2F;&amp;#x2F; note: this sets the global g_mode variable to 1.  It does not declare a local g_mode variable!

    doSomething();

    &amp;#x2F;&amp;#x2F; Programmer still expects g_mode to be 1
    &amp;#x2F;&amp;#x2F; But doSomething changed it to 2!

    if (g_mode == 1)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;No threat detected.\n&amp;quot;;
    }
    else
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Launching nuclear missiles...\n&amp;quot;;
    }

    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;请注意，程序员将变量 &lt;code&gt;g_mode&lt;&#x2F;code&gt; 设置为 &lt;em&gt;1&lt;&#x2F;em&gt;，然后调用 &lt;code&gt;doSomething（）。&lt;&#x2F;code&gt; 除非程序员明确知道 &lt;code&gt;doSomething（）&lt;&#x2F;code&gt; 将更改 &lt;code&gt;g_mode&lt;&#x2F;code&gt; 的值，否则他或她可能不希望 &lt;code&gt;doSomething（）&lt;&#x2F;code&gt; 更改该值！因此，&lt;code&gt;main（）&lt;&#x2F;code&gt; 的其余部分并不像程序员期望的那样工作（并且世界被抹去了）。&lt;&#x2F;p&gt;
&lt;p&gt;全局变量使程序的状态不可预测。每个函数调用都变得具有潜在的危险，程序员无法轻松知道哪些是危险的，哪些不是！&lt;em&gt;局部变量要安全得多，因为其他函数不能直接影响它们&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;全局变量还会降低程序的模块化程度和灵活性。一个只利用其参数且没有副作用的函数是完美的模块化的。模块化有助于理解程序的作用，以及可重用性。全局变量显著降低了模块化。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;全局变量会破坏模块化设计&lt;&#x2F;strong&gt;，而 ✅ &lt;strong&gt;纯函数（只用参数、不产生副作用）是理想的模块化单位&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容易测试&lt;&#x2F;strong&gt; ✅&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容易复用&lt;&#x2F;strong&gt; ✅&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行为可预测&lt;&#x2F;strong&gt; ✅&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一个函数&#x2F;模块只管自己，输入什么就输出什么，不依赖外部状态，也不影响其他模块。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;模块化 = 自成一体、无副作用、可独立测试复用&lt;&#x2F;strong&gt;，&lt;br &#x2F;&gt;
&lt;strong&gt;全局变量 = 容易打破这种模块化结构，导致 bug 多、维护难。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;quan-ju-bian-liang-de-chu-shi-hua-shun-xu-wen-ti&quot;&gt;全局变量的初始化顺序问题&lt;&#x2F;h3&gt;
&lt;p&gt;*静态变量（包括全局变量）的初始化作为程序启动的一部分进行，&lt;&#x2F;p&gt;
&lt;p&gt;在执行 &lt;code&gt;main&lt;&#x2F;code&gt; 函数之前。这分两个阶段进行。&lt;&#x2F;p&gt;
&lt;p&gt;有 constexpr 初始值设定项（包括 Literals）的全局变量被初始化为这些值。这称为&lt;strong&gt;常量初始化&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;没有初始化器的全局变量是零初始化的。零初始化被认为是静态初始化的一种形式，因为 &lt;code&gt;0&lt;&#x2F;code&gt; 是 constexpr 值。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;constexpr int a = 10; &amp;#x2F;&amp;#x2F; ✔ 编译时能确定，常量初始化
const int b = 5;      &amp;#x2F;&amp;#x2F; ✔ 也是常量初始化
int c = 0;            &amp;#x2F;&amp;#x2F; ✔ 0 也是 constexpr，叫做 zero-initialization
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;快、安全、顺序无依赖&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;第二个阶段称为&lt;strong&gt;动态初始化&lt;&#x2F;strong&gt; 。这个阶段更加复杂和细微，但其要点是初始化具有非 constexpr 初始值设定项的全局变量。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int getValue() { return 42; }
int x = getValue(); &amp;#x2F;&amp;#x2F; ❌ 不是 constexpr，必须运行 getValue()，这是动态初始化
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个阶段就&lt;strong&gt;可能会有初始化顺序问题&lt;&#x2F;strong&gt;，比如多个全局变量之间相互依赖，顺序搞错就可能出 bug。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶段&lt;&#x2F;th&gt;&lt;th&gt;什么时候发生&lt;&#x2F;th&gt;&lt;th&gt;初始化什么&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;静态初始化&lt;&#x2F;td&gt;&lt;td&gt;程序启动前（编译时）&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;constexpr&lt;&#x2F;code&gt; 值、字面值、未初始化变量设为 0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;动态初始化&lt;&#x2F;td&gt;&lt;td&gt;程序启动时（运行时）&lt;&#x2F;td&gt;&lt;td&gt;需要函数&#x2F;表达式结果的初始化&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;blockquote&gt;
&lt;p&gt;全局变量的使用：变量在程序中应该只表示一个事物，并且它的使用应该在整个程序中无处不在。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果你确实找到了 non-const 全局变量的好用法，那么一些有用的建议将最大限度地减少你可能遇到的麻烦。这个建议不仅适用于 non-const global variables，而且可以帮助所有 global variables。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;首先，在所有非命名空间的全局变量前面加上 “g” 或 “g_”，或者更好的是，将它们放在命名空间中，以减少命名冲突的可能性。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;7-9-nei-lian-han-shu&quot;&gt;7.9 内联函数&lt;&#x2F;h2&gt;
&lt;p&gt;将代码作为现有函数的一部分编写（称为“就地”或“内联”编写代码）。&lt;&#x2F;p&gt;
&lt;p&gt;创建一个新函数（可能还有子函数）来处理任务。&lt;&#x2F;p&gt;
&lt;p&gt;将代码放入新函数中提供了许多潜在的好处，如小函数：&lt;&#x2F;p&gt;
&lt;p&gt;但是，使用 new 函数的一个缺点是，每次调用函数时，都会产生一定量的性能开销。请考虑以下示例：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int min(int x, int y)
{
    return (x &amp;lt; y) ? x : y;
}

int main()
{
    std::cout &amp;lt;&amp;lt; min(5, 6) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    std::cout &amp;lt;&amp;lt; min(3, 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当遇到对 &lt;code&gt;min（）&lt;&#x2F;code&gt; 的调用时，CPU 必须存储它正在执行的当前指令的地址（以便它知道稍后返回何处）以及各种 CPU 寄存器的值（以便它们可以在返回时恢复）。然后，必须实例化参数 &lt;code&gt;x&lt;&#x2F;code&gt; 和 &lt;code&gt;y&lt;&#x2F;code&gt;，然后初始化。然后，执行路径必须跳转到 &lt;code&gt;min（）&lt;&#x2F;code&gt; 函数中的代码。当函数结束时，程序必须跳回到函数调用的位置，并且必须复制返回值以便输出。必须为每个函数调用执行此作。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;在完成某些任务（在本例中为进行函数调用）后，设置、促进和&#x2F;或清理所必须发生的所有额外工作都称为&lt;strong&gt;开销&lt;&#x2F;strong&gt; 。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;对于大型和&#x2F;或执行复杂任务的函数，与函数运行所需的时间相比，函数调用的开销通常微不足道。但是，对于小型函数（例如上面的 &lt;code&gt;min（），&lt;&#x2F;code&gt; 开销成本可能大于实际执行函数代码所需的时间！在经常&lt;em&gt;&lt;strong&gt;调用小型函数的情况下，使用函数可能会导致就地编写相同代码的显著性能损失。&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-lian-tuo-zhan&quot;&gt;内联拓展&lt;&#x2F;h3&gt;
&lt;p&gt;幸运的是，C++ 编译器有一个技巧可以用来避免这种开销成本： &lt;strong&gt;内联扩展&lt;&#x2F;strong&gt;是一个过程，其中函数调用被调用函数定义中的代码替换。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

int main()
{
    std::cout &amp;lt;&amp;lt; ((5 &amp;lt; 6) ? 5 : 6) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    std::cout &amp;lt;&amp;lt; ((3 &amp;lt; 2) ? 3 : 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对函数 &lt;code&gt;min（）&lt;&#x2F;code&gt; 的两次调用已替换为 &lt;code&gt;min（）&lt;&#x2F;code&gt; 函数主体中的代码 使我们能够避免这些调用的开销，同时保留代码的结果。&lt;&#x2F;p&gt;
&lt;p&gt;除了消除函数调用的成本之外，内联扩展还可以让编译器更有效地优化结果代码 -- 例如，由于表达式 &lt;code&gt;（（5 &amp;lt; 6） ？ 5 ： 6）&lt;&#x2F;code&gt; 现在是一个常量表达式，编译器可以进一步将 &lt;code&gt;main（）&lt;&#x2F;code&gt; 中的第一个语句优化为 &lt;code&gt;std：：cout &amp;lt;&amp;lt; 5 &amp;lt;&amp;lt; &#x27;\n&#x27;;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;！ 可以拓展 ！&lt;&#x2F;p&gt;
&lt;p&gt;！ 无法拓展 ！&lt;&#x2F;p&gt;
&lt;h4 id=&quot;inline&quot;&gt;inline&lt;&#x2F;h4&gt;
&lt;p&gt;使用 &lt;code&gt;inline&lt;&#x2F;code&gt; 关键字声明的函数称为&lt;strong&gt;内联函数&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;

inline int min(int x, int y) &amp;#x2F;&amp;#x2F; inline keyword means this function is an inline function
{
    return (x &amp;lt; y) ? x : y;
}

int main()
{
    std::cout &amp;lt;&amp;lt; min(5, 6) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    std::cout &amp;lt;&amp;lt; min(3, 2) &amp;lt;&amp;lt; &amp;#x27;\n&amp;#x27;;
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用 &lt;code&gt;inline&lt;&#x2F;code&gt; 请求内联扩展是一种过早的优化形式，滥用实际上可能会损害性能。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;inline&lt;&#x2F;code&gt; 关键字只是一个提示，可帮助编译器确定在何处执行内联扩展。编译器完全可以自由地忽略该请求，而且它很可能会这样做。编译器还可以自由地对不使用 &lt;code&gt;inline&lt;&#x2F;code&gt; 关键字作为其常规优化集一部分的函数执行内联扩展。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;请勿使用 &lt;code&gt;inline&lt;&#x2F;code&gt; 关键字为您的函数请求内联扩展。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;“你别真的去调用函数，把函数体直接展开到调用处去，提高运行效率。”&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;使用场景&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数非常短小（如 getter&#x2F;setter、加减乘除等）；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;多次频繁调用；&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;希望避免函数调用带来的开销（如压栈、跳转等）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;&#x2F;th&gt;&lt;th&gt;描述&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;优点&lt;&#x2F;td&gt;&lt;td&gt;提高效率，省去函数调用开销&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;缺点&lt;&#x2F;td&gt;&lt;td&gt;增加代码体积，可能影响缓存命中率&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;使用建议&lt;&#x2F;td&gt;&lt;td&gt;小函数，头文件中，避免滥用&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不将所有函数内联并在头文件中定义呢？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;7-10-zuo-wei-nei-bu-bian-liang-de-quan-ju-chang-liang&quot;&gt;7.10 作为内部变量的全局常量&lt;&#x2F;h2&gt;
</description>
      </item>
      <item>
          <title>使用issue创建第一个博客</title>
          <pubDate>Wed, 28 May 2025 08:53:41 +0000</pubDate>
          <author>Zhonghe-zhao</author>
          <link>https://Zhonghe-zhao.github.io/DailyBlog/issue-1/</link>
          <guid>https://Zhonghe-zhao.github.io/DailyBlog/issue-1/</guid>
          <description xml:base="https://Zhonghe-zhao.github.io/DailyBlog/issue-1/">&lt;h2 id=&quot;xin-bo-ke-chuang-jian&quot;&gt;新博客创建&lt;&#x2F;h2&gt;
&lt;p&gt;非常喜欢使用issue来和博客建立关系！受yihong老师博客的影响，自己也创建了！并且购买了属于自己的域名&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;Zhonghe-zhao.github.io&#x2F;DailyBlog&#x2F;issue-1&#x2F;blog.zhaozhonghe.me&quot;&gt;我的博客&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;链接&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;yihong0618&#x2F;gitblog&quot;&gt;yihong老师博客&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
